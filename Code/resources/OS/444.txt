Traditional UNIX Scheduling
                           Process A                   Process B                        Process C
                           Process    Group                   Process  Group            Process    Group
     Time                  CPU        CPU                     CPU      CPU              CPU        CPU
                 Priority  count      count  Priority         count    count  Priority  count      count
     0            60       0          0      60               0        0        60      0          0
                           1          1
                           2          2
                           60         60
     1            90       30         30     60               0        0        60      0          0
                                                              1        1                           1
                                                              2        2                           2
                                                              60       60                          60
     2            74       15         15     90               30       30       75      0          30
                           16         16
                           17         17
                           75         75
     3            96       37         37     74               15       15       67      0          15
                                                                       16               1          16
                                                                       17               2          17
                                                                       75               60         75
     4            78       18         18     81               7        37       93      30         37
                           19         19
                           20         20
                           78         78
     5            98       39         39     70               3        18       76      15         18
                           Group 1                                     Group 2
              Colored rectangle represents executing process
     Figure 9.16      Example of Fair-Share Scheduler--Three Processes, Two Groups
9.3  TRADITIONAL UNIX SCHEDULING
     In this section we examine traditional UNIX scheduling, which is used in both
     SVR3 and 4.3 BSD UNIX. These systems are primarily targeted at the time-sharing
     interactive environment. The scheduling algorithm is designed to provide good
     response time for interactive users while ensuring that low-priority background
     jobs do not starve. Although this algorithm has been replaced in modern UNIX
     systems, it is worthwhile to examine the approach because it is representative of

practical time-sharing scheduling algorithms. The scheduling scheme for SVR4
includes an accommodation for real-time requirements, and so its discussion is
deferred to Chapter 10.
   The traditional UNIX scheduler employs multilevel feedback using round
robin within each of the priority queues. The system makes use of one-second
preemption. That is, if a running process does not block or complete within one
second, it is preempted. Priority is based on process type and execution history. The
following formulas apply:
                             CPUj(i) =      CPUj(i -  1)
                                               2
                           Pj(i) = Basej +  CPUj(i)   + nicej
                                            2
where
   CPUj(i)  measure of processor utilization by process j through interval i
   Pj(i)        priority of process j at beginning of interval i; lower values equal
               higher priorities
   Basej        base priority of process j
   nicej        user-controllable adjustment factor
   The priority of each process is recomputed once per second, at which time a
new scheduling decision is made. The purpose of the base priority is to divide all
processes into fixed bands of priority levels. The CPU and nice components are
restricted to prevent a process from migrating out of its assigned band (assigned by
the base priority level). These bands are used to optimize access to block devices
(e.g., disk) and to allow the OS to respond quickly to system calls. In decreasing
order of priority, the bands are:
  Swapper
  Block I/O device control
  File manipulation
  Character I/O device control
  User processes
   This hierarchy should provide the most efficient use of the I/O devices.
Within the user process band, the use of execution history tends to penalize proc-
essor-bound processes at the expense of I/O-bound processes. Again, this should
improve efficiency. Coupled with the round-robin preemption scheme, the sched-
uling strategy is well equipped to satisfy the requirements for general-purpose
time sharing.
   An example of process scheduling is shown in Figure 9.17. Processes A, B,
and C are created at the same time with base priorities of 60 (we will ignore the
nice value). The clock interrupts the system 60 times per second and increments
a counter for the running process. The example assumes that none of the proc-
esses block themselves and that no other processes are ready to run. Compare
this with Figure 9.16.

              Time         Process A        Process B                      Process C
                    0  Priority  CPU count  Priority  CPU count            Priority  CPU count
                           60         0     60                         0   60         0
                                      1
                                      2
                    1                 60
                           75         30    60                         0   60         0
                                                                       1
                                                                       2
                    2                                                  60
                           67         15    75                         30  60         0
                                                                                      1
                                                                                      2
                    3                                                                 60
                           63         7     67                         15  75         30
                                      8
                                      9
                    4                 67
                           76         33    63                         7   67         15
                                                                       8
                                                                       9
                    5                                                  67
                           68         16    76                         33  63         7
                       Colored rectangle represents executing process
              Figure 9.17  Example of a Traditional UNIX Process Scheduling
9.4  SUMMARY
     The OS must make three types of scheduling decisions with respect to the execu-
     tion of processes. Long-term scheduling determines when new processes are admit-
     ted to the system. Medium-term scheduling is part of the swapping function and
     determines when a program is brought partially or fully into main memory so that
     it may be executed. Short-term scheduling determines which ready process will
     be executed next by the processor. This chapter focuses on the issues relating to
     short-term scheduling.
