Segmentation
                                                   7.4 / SEGMENTATION                         325
        To summarize, with simple paging, main memory is divided into many small
     equal-size frames. Each process is divided into frame-size pages. Smaller processes
     require fewer pages; larger processes require more. When a process is brought in,
     all of its pages are loaded into available frames, and a page table is set up. This
     approach solves many of the problems inherent in partitioning.
7.4  SEGMENTATION
     A user program can be subdivided using segmentation, in which the program and its
     associated data are divided into a number of segments. It is not required that all seg-
     ments of all programs be of the same length, although there is a maximum segment
     length. As with paging, a logical address using segmentation consists of two parts, in
     this case a segment number and an offset.
        Because of the use of unequal-size segments, segmentation is similar to
     dynamic partitioning. In the absence of an overlay scheme or the use of virtual
     memory, it would be required that all of a program's segments be loaded into mem-
     ory for execution. The difference, compared to dynamic partitioning, is that with
     segmentation a program may occupy more than one partition, and these partitions
     need not be contiguous. Segmentation eliminates internal fragmentation but, like
     dynamic partitioning, it suffers from external fragmentation. However, because a
     process is broken up into a number of smaller pieces, the external fragmentation
     should be less.
        Whereas paging is invisible to the programmer, segmentation is usually visible
     and is provided as a convenience for organizing programs and data. Typically, the
     programmer or compiler will assign programs and data to different segments. For
     purposes of modular programming, the program or data may be further broken
     down into multiple segments. The principal inconvenience of this service is that the
     programmer must be aware of the maximum segment size limitation.
        Another consequence of unequal-size segments is that there is no simple rela-
     tionship between logical addresses and physical addresses. Analogous to paging, a
     simple segmentation scheme would make use of a segment table for each process
     and a list of free blocks of main memory. Each segment table entry would have
     to give the starting address in main memory of the corresponding segment. The
     entry should also provide the length of the segment, to assure that invalid addresses
     are not used. When a process enters the Running state, the address of its segment
     table is loaded into a special register used by the memory management hardware.
     Consider an address of n  m bits, where the leftmost n bits are the segment number
     and the rightmost m bits are the offset. In our example (Figure 7.11c), n  4 and
     m  12. Thus the maximum segment size is 212  4096. The following steps are
     needed for address translation:
       Extract the segment number as the leftmost n bits of the logical address.
       Use the segment number as an index into the process segment table to find the
        starting physical address of the segment.
       Compare the offset, expressed in the rightmost m bits, to the length of the seg-
        ment. If the offset is greater than or equal to the length, the address is invalid.

326  CHAPTER 7 / MEMORY MANAGEMENT
      The desired physical address is the sum of the starting physical address of the
     segment plus the offset.
     In our example, we have the logical address 0001001011110000, which is
     segment number 1, offset 752. Suppose that this segment is residing in main mem-
     ory starting at physical address 0010000000100000. Then the physical address is
     0010000000100000 + 001011110000  0010001100010000 (Figure 7.12b).
     To summarize, with simple segmentation, a process is divided into a number
     of segments that need not be of equal size. When a process is brought in, all of its
     segments are loaded into available regions of memory, and a segment table is set up.
7.5  SECURITY ISSUES
     Main memory and virtual memory are system resources subject to security threats
     and for which security countermeasures need to be taken. The most obvious secu-
     rity requirement is the prevention of unauthorized access to the memory contents
     of processes. If a process has not declared a portion of its memory to be sharable,
     then no other process should have access to the contents of that portion of memory.
     If a process declares that a portion of memory may be shared by other designated
     processes, then the security service of the OS must ensure that only the designated
     processes have access. The security threats and countermeasures discussed in
     Chapter 3 are relevant to this type of memory protection.
     In this section, we summarize another threat that involves memory protection.
     Part Seven provides more detail.
     Buffer Overflow Attacks
     One serious security threat related to memory management remains to be intro-
     duced: buffer overflow, also known as a buffer overrun, which is defined in the NIST
     (National Institute of Standards and Technology) Glossary of Key Information
     Security Terms as follows:
     buffer overrun: A condition at an interface under which more input can be
     placed into a buffer or data-holding area than the capacity allocated, overwrit-
     ing other information. Attackers exploit such a condition to crash a system or to
     insert specially crafted code that allows them to gain control of the system.
     A buffer overflow can occur as a result of a programming error when a process
     attempts to store data beyond the limits of a fixed-sized buffer and consequently
     overwrites adjacent memory locations. These locations could hold other program
     variables or parameters or program control flow data such as return addresses
     and pointers to previous stack frames. The buffer could be located on the stack,
     in the heap, or in the data section of the process. The consequences of this error
     include corruption of data used by the program, unexpected transfer of control in
     the program, possibly memory access violations, and very likely eventual program
