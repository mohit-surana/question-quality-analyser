Recommended Reading and Web Sites
      A cluster is a group of interconnected, whole computers working together as
      a unified computing resource that can create the illusion of being one machine. The
      term whole computer means a system that can run on its own, apart from the cluster.
16.9  RECOMMENDED READING AND WEB SITES
      [BERS96] provides a good technical discussion of the design issues involved in allo-
      cating applications to client and server and in middleware approaches; the book
      also discusses products and standardization efforts. [REAG00a] and [REAG00b]
      cover client/server computing and network design approaches for supporting client/
      server computing.
      A good overview of middleware technology and products is [BRIT04].
      [MENA05] provides a performance comparison of remote procedure calls and
      distributed message passing.
      Two worthwhile surveys of SOA are [BROW03] and [BIH06]. [CHER05] and
      [BIEB05] analyze the impact of migrating to a SOA. [HUTC08] discusses strategies
      for migrating to an SOA. [CARE08] looks at the role of data services in an SOA.
      [TANE85] is a survey of distributed operating systems that covers both dis-
      tributed process communication and distributed process management. [CHAN90]
      provides an overview of distributed message passing operating systems. [TAY90]
      is a survey of the approach taken by various operating systems in implementing
      remote procedure calls.
      A thorough treatment of clusters can be found in [BUYY99a] and [BUYY99b].
      The former has a good treatment of Beowulf, which is also nicely covered in
      [RIDG97]. A more detailed treatment of Beowulf is [STER99].Windows Cluster
      Server is described in [SHOR97]; [RAJA00] provides a more detailed treatment.
      [LAI06] provides a close examination of thin client architecture.
      BERS96   Berson, A. Client/Server Architecture. New York: McGraw-Hill, 1996.
      BIEB05   Bieberstein, N., et al. "Impact of Service-Oriented Architecture on Enterprise
      Systems, Organizational Structures, and Individuals." IBM Systems Journal, Vol.
      44, No. 4, 2005.
      BIH06   Bih, J. "Service Oriented Architecture (SOA): A New Paradigm to Implement
      Dynamic E-Business Solutions." ACM Ubiquity, August 2006; acm.org/ubiquity/
      views/v7i30_soa.html
      BRIT04   Britton, C. IT Architectures and Middleware. Reading, MA: Addison-
      Wesley, 2004.
      BROW03   Brown, A., Johnston, S., and Kelly, K. Using Service-Oriented Architecture
      and Component-Based Development to Build Web Service Applications. IBM
      Rational Software Technical Report, 2003. ibm.com/developerworks/rational/
      library/510.html
      BUYY99a  Buyya, R. High Performance Cluster Computing: Architectures and
      Systems. Upper Saddle River, NJ: Prentice Hall, 1999.
      BUYY99b  Buyya, R. High Performance Cluster Computing: Programming and
      Applications. Upper Saddle River, NJ: Prentice Hall, 1999.

         CARE08   Carey, M. "SOA What?" IEEE Computer, March 2008.
         CHAN90   Chandras, R. "Distributed Message Passing Operating Systems." Operating
                Systems Review, January 1990.
         CHER05   Cherbacko, L., et al. "Impact of Service Orientation at the Business Level."
                IBM Systems Journal, Vol 44., No. 4, 2005.
         HUTC08   Hutchinson, J., et al. "Migrating to SOAs by Way of Hybrid Systems." IT
                Pro, January/February 2008.
         LAI06   Lai,  A.,   and  Nieh,     J.  "On  the  Performance  of  Wide-Area  Thin-Client
                Computing." ACM Transactions on Computer Systems, May 2006.
         MENA05   Menasce, D. "MOM vs. RPC: Communication Models for Distributed
                Applications." IEEE Internet Computing, March/April 2005.
         RAJA00   Rajagopal, R. Introduction to Microsoft Windows NT Cluster Server. Boca
                Raton, FL: CRC Press, 2000.
         REAG00a       Reagan, P. Client/Server Computing. Upper Saddle River, NJ: Prentice
                Hall, 2000.
         REAG00b       Reagan, P. Client/Server Network: Design, Operation, and Management.
                Upper Saddle River, NJ: Prentice Hall, 2000.
         RIDG97   Ridge, D., et al. "Beowulf: Harnessing the Power of Parallelism in a Pile-of-
                PCs." Proceedings, IEEE Aerospace Conference, 1997.
         SHOR97   Short, R., Gamache, R., Vert, J., and Massa, M. "Windows NT Clusters for
                Availability and Scalability." Proceedings, COMPCON Spring 97, February 1997.
         STER99   Sterling, T., et al. How to Build a Beowulf. Cambridge, MA: MIT Press, 1999.
         TANE85   Tanenbaum,           A.,  and  Renesse,   R.  "Distributed  Operating  Systems."
                Computing Surveys, December 1985.
         TAY90   Tay, B., and Ananda, A. "A Survey of Remote Procedure Calls." Operating
                Systems Review, July 1990.
     Recommended Web sites:
         ·      SQL Standards: A central source of information about the SQL standards process and
                its current documents
         ·      IEEE Computer Society Task Force on Cluster Computing: An international forum to
                promote cluster computing research and education
         ·      Beowulf: An international forum to promote cluster computing research and education
16.10    KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS
Key Terms
applications programming          Client                          distributed message passing
     interface                    client/server                   failback
Beowulf                           cluster                         failover

fat client                            message                          server
file cache consistency                middleware                       thin client
graphical user interface              remote procedure call (RPC)
Review Questions
            16.1  What is client/server computing?
            16.2  What distinguishes client/server computing from any other form of distributed data
                  processing?
            16.3  What is the role of a communications architecture such as TCP/IP in a client/server
                  environment?
            16.4  Discuss the rationale for locating applications on the client, the server, or split between
                  client and server.
            16.5  What are fat clients and thin clients, and what are the differences in philosophy of the
                  two approaches?
            16.6  Suggest pros and cons for fat client and thin client strategies.
            16.7  Explain the rationale behind the three-tier client/server architecture.
            16.8  What is middleware?
            16.9  Because we have standards such as TCP/IP, why is middleware needed?
16.10             List some benefits and disadvantages of blocking and nonblocking primitives for
                  message passing.
16.11             List some benefits and disadvantages of nonpersistent and persistent binding for RPCs.
16.12             List some benefits and disadvantages of synchronous and asynchronous RPCs.
16.13             List and briefly define four different clustering methods.
Problems
            16.1  Let   be the percentage of program code that can be executed simultaneously by n
                  computers in a cluster, each computer using a different set of parameters or initial
                  conditions. Assume that the remaining code must be executed sequentially by a single
                  processor. Each processor has an execution rate of x MIPS.
                  a.   Derive an expression for the effective MIPS rate when using the system for
                       exclusive execution of this program, in terms of n,  , and x.
                  b.   If n  16 and x  4 MIPS, determine the value of                 that will yield a system
                       performance of 40 MIPS.
            16.2  An application program is executed on a nine-computer cluster. A benchmark pro-
                  gram takes time T on this cluster. Further, 25% of T is time in which the application
                  is running simultaneously on all nine computers. The remaining time, the application
                  has to run on a single computer.
                  a.   Calculate the effective speedup under the aforementioned condition as compared
                       to executing the program on a single computer. Also calculate, the percentage of
                       code that has been parallelized (programmed or compiled so as to use the cluster
                       mode) in the preceding program.
                  b.   Suppose that we are able to effectively use 18 computers rather than 9 comput-
                       ers on the parallelized portion of the code. Calculate the effective speedup that is
                       achieved.
            16.3  The following FORTRAN program is to be executed on a computer, and a parallel
                  version is to be executed on a 32-computer cluster.

         L1:          DO 10 I = 1, 1024
         L2:          SUM(I) = 0
         L3:          DO 20 J = 1, I
         L4: 20 SUM(I) = SUM(I) + I
         L5: 10 CONTINUE
     Suppose lines 2 and 4 each take two machine cycle times, including all processor and
     memory-access activities. Ignore the overhead caused by the software loop control
     statements (lines 1, 3, 5) and all other system overhead and resource conflicts.
     a.  What is the total execution time (in machine cycle times) of the program on a
         single computer?
     b.  Divide the I-loop iterations among the 32 computers as follows: Computer 1
         executes the first 32 iterations (I  1 to 32), processor 2 executes the next 32
         iterations, and so on. What are the execution time and speedup factor compared
         with part (a)? (Note that the computational workload, dictated by the J-loop, is
         unbalanced among the computers.)
     c.  Explain how to modify the parallelizing to facilitate a balanced parallel exe-
         cution of all the computational workload over 32 computers. A balanced load
         means an equal number of additions assigned to each computer with respect to
         both loops.
     d.  What is the minimum execution time resulting from the parallel execution on 32
         computers? What is the resulting speedup over a single computer?

     TOPICS IN CONCURRENCY
A.1  Mutual Exclusion: Software Approaches
     Dekker's Algorithm
     Peterson's Algorithm
A.2  Race Conditions and Semaphores
     Problem Statement
     First Attempt
     Second Attempt
     Third Attempt
     Fourth Attempt
     A Good Attempt
A.3  A Barbership Problem
     An Unfair Barbershop
     A Fair Barbershop
A.4  Problems
                                            A-1

     It was impossible to get a conversation going; everybody was talking
     too much.
                                                                   --Yogi Berra
A.1  MUTUAL EXCLUSION: SOFTWARE APPROACHES
     Software approaches can be implemented for concurrent processes that execute on
     a single processor or a multiprocessor machine with shared main memory. These
     approaches usually assume elementary mutual exclusion at the memory access level
     ([LAMP91], but see Problem A.3). That is, simultaneous accesses (reading and/or writing)
     to the same location in main memory are serialized by some sort of memory arbiter,
     although the order of access granting is not specified ahead of time. Beyond this, no
     support in the hardware, operating system, or programming language is assumed.
     Dekker's Algorithm
     Dijkstra [DIJK65] reported an algorithm for mutual exclusion for two processes,
     designed by the Dutch mathematician Dekker. Following Dijkstra, we develop
     the solution in stages. This approach has the advantage of illustrating many of the
     common bugs encountered in developing concurrent programs.
     FIRST ATTEMPT  As mentioned earlier, any attempt at mutual exclusion must rely
     on some fundamental exclusion mechanism in the hardware. The most common
     of these is the constraint that only one access to a memory location can be made
     at a time. Using this constraint, we reserve a global memory location labeled
     turn. A process (P0 or P1) wishing to execute its critical section first examines the
     contents of turn. If the value of turn is equal to the number of the process, then
     the process may proceed to its critical section. Otherwise, it is forced to wait. Our
     waiting process repeatedly reads the value of turn until it is allowed to enter its
     critical section. This procedure is known as busy waiting, or spin waiting, because
     the thwarted process can do nothing productive until it gets permission to enter its
     critical section. Instead, it must linger and periodically check the variable; thus it
     consumes processor time (busy) while waiting for its chance.
     After a process has gained access to its critical section and after it has com-
     pleted that section, it must update the value of turn to that of the other process.
     In formal terms, there is a shared global variable:
                                             int  turn  =  0;
     Figure A.1a shows the program for the two processes. This solution guarantees
     the mutual exclusion property but has two drawbacks. First, processes must strictly
     alternate in their use of their critical section; therefore, the pace of execution is dic-
     tated by the slower of the two processes. If P0 uses its critical section only once per
     hour but P1 would like to use its critical section at a rate of 1,000 times per hour, P1
     is forced to adopt the pace of P0. A much more serious problem is that if one process
     fails, the other process is permanently blocked. This is true whether a process fails in
     its critical section or outside of it.

    /*  PROCESS         0  /*                    /*   PROCESS        1  */
.                                            .
.                                            .
while      (turn   !=      0)                while       (turn  !=      1)
    /*  do     nothing        */   ;             /*   do    nothing        */;
/*  critical       section*/;                /*  critical       section*/;
turn    =   1;                               turn     =  0;
.                                            .
                                  (a) First  attempt
    /*  PROCESS         0  */                    /*   PROCESS        1  */
.                                            .
.                                            .
while      (flag[1])                         while       (flag[0])
    /*  do     nothing        */;                /*   do    nothing        */;
flag[0]     =   true;                        flag[1]     =   true;
/*critical         section*/;                /*  critical       section*/;
flag[0]     =   false;                       flag[1]     =   false;
.                                            .
                               (b) Second    attempt
    /*  PROCESS         0  */                    /*   PROCESS        1  */
.                                            .
.                                            .
flag[0]     =   true;                        flag[1]     =   true;
while      (flag[1])                         while       (flag[0])
    /*  do     nothing        */;                /*   do    nothing        */;
/*  critical       section*/;                /*  critical       section*/;
flag[0]     =   false;                       flag[1]     =   false;
.                                            .
                               (c) Third     attempt
    /*  PROCESS         0  */                    /*   PROCESS        1  */
.                                            .
.                                            .
flag[0]     =   true;                        flag[1]     =   true;
while      (flag[1])       {                 while       (flag[0])      {
    flag[0]     =  false;                        flag[1]     =  false;
    /*delay        */;                           /*delay        */;
    flag[0]     =  true;                         flag[1]     =  true;
}                                            }
/*critical         section*/;                /*  critical       section*/;
flag[0]     =   false;                       flag[1]     =   false;
.
                               (d) Fourth attempt
Figure A.1      Mutual Exclusion Attempts

     The foregoing construction is that of a coroutine. Coroutines are designed to be
     able to pass execution control back and forth between themselves (see Problem 5.2).
     While this is a useful structuring technique for a single process, it is inadequate to
     support concurrent processing.
     SECOND ATTEMPT           The flaw in the first attempt is that it stores the name of the
     process that may enter its critical section, when in fact we need state information
     about both processes. In effect, each process should have its own key to the critical
     section so that if one fails, the other can still access its critical section. To meet this
     requirement a Boolean vector flag is defined, with flag[0] corresponding to P0
     and flag[1] corresponding to P1. Each process may examine the other's flag but
     may not alter it. When a process wishes to enter its critical section, it periodically
     checks the other's flag until that flag has the value false, indicating that the other
     process is not in its critical section. The checking process immediately sets its own
     flag to true and proceeds to its critical section. When it leaves its critical section, it
     sets its flag to false.
     The shared global variable1 now is
     enum                            boolean  (false      =   0;  true           =  1);
     boolean                         flag[2]  =      {0,  0}
     Figure A.1b shows the algorithm. If one process fails outside the critical
     section, including the flag-setting code, then the other process is not blocked. In
     fact, the other process can enter its critical section as often as it likes, because the
     flag of the other process is always false. However, if a process fails inside its criti-
     cal section or after setting its flag to true just before entering its critical section,
     then the other process is permanently blocked.
     This solution is, if anything, worse than the first attempt because it does not
     even guarantee mutual exclusion. Consider the following sequence:
     P0 executes the while statement and finds flag[1] set to false
     P1 executes the while statement and finds flag[0] set to false
     P0 sets flag[0] to true and enters its critical section
     P1 sets flag[1] to true and enters its critical section
     Because both processes are now in their critical sections, the program is incor-
     rect. The problem is that the proposed solution is not independent of relative process
     execution speeds.
     THIRD ATTEMPT      Because a process can change its state after the other process
     has checked it but before the other process can enter its critical section, the second
     attempt failed. Perhaps we can fix this problem with a simple interchange of two
     statements, as shown in Figure A.1c.
     As before, if one process fails inside its critical section, including the flag-setting
     code controlling the critical section, then the other process is blocked, and if a process
     fails outside its critical section, then the other process is not blocked.
     1The enum declaration is used here to declare a data type (boolean) and to assign its values.

Next, let us check that mutual exclusion is guaranteed, using the point of view
of process P0. Once P0 has set flag[0] to true, P1 cannot enter its critical section
until after P0 has entered and left its critical section. It could be that P1 is already in
its critical section when P0 sets its flag. In that case, P0 will be blocked by the while
statement until P1 has left its critical section. The same reasoning applies from the
point of view of P1.
This guarantees mutual exclusion but creates yet another problem. If both
processes set their flags to true before either has executed the while state-
ment, then each will think that the other has entered its critical section, causing
deadlock.
FOURTH ATTEMPT        In the third attempt, a process sets its state without knowing
the state of the other process. Deadlock occurs because each process can insist on
its right to enter its critical section; there is no opportunity to back off from this
position. We can try to fix this in a way that makes each process more deferential:
Each process sets its flag to indicate its desire to enter its critical section but is
prepared to reset the flag to defer to the other process, as shown in Figure A.1d.
This is close to a correct solution but is still flawed. Mutual exclusion is still
guaranteed, using similar reasoning to that followed in the discussion of the third
attempt. However, consider the following sequence of events:
P0 sets flag[0] to true.
P1 sets flag[1] to true.
P0 checks flag[1].
P1 checks flag[0].
P0 sets flag[0] to false.
P1 sets flag[1] to false.
P0 sets flag[0] to true.
P1 sets flag[1] to true.
This sequence could be extended indefinitely, and neither process could enter
its critical section. Strictly speaking, this is not deadlock, because any alteration in
the relative speed of the two processes will break this cycle and allow one to enter
the critical section. This condition is referred to as livelock. Recall that deadlock
occurs when a set of processes wishes to enter their critical sections but no process
can succeed. With livelock, there are possible sequences of executions that succeed,
but it is also possible to describe one or more execution sequences in which no
process ever enters its critical section.
Although the scenario just described is not likely to be sustained for very long,
it is nevertheless a possible scenario. Thus we reject the fourth attempt.
A CORRECT SOLUTION    We need to be able to observe the state of both processes,
which is provided by the array variable flag. But, as the fourth attempt shows,
this is not enough. We must impose an order on the activities of the two processes
to avoid the problem of "mutual courtesy" that we have just observed. The
variable turn from the first attempt can be used for this purpose; in this case

     the variable indicates which process has the right to insist on entering its critical
     region.
     We can describe this solution, referred to as Dekker's algorithm, as follows.
     When P0 wants to enter its critical section, it sets its flag to true. It then checks the
     flag of P1. If that is false, P0 may immediately enter its critical section. Otherwise,
     P0 consults turn. If it finds that turn = 0, then it knows that it is its turn to insist
     and periodically checks P1's flag. P1 will at some point note that it is its turn to
     defer and set its to flag false, allowing P0 to proceed. After P0 has used its criti-
     cal section, it sets its flag to false to free the critical section and sets turn to 1 to
     transfer the right to insist to P1.
              boolean     flag    [2];
              int   turn;
              void  P0()
              {
                    while        (true)      {
                              flag     [0]   =   true;
                              while       (flag  [1])      {
                                          if    (turn   ==    1)  {
                                                 flag   [0]   =   false;
                                                 while        (turn  ==  1)  /*  do  nothing  */;
                                                 flag   [0]   =   true;
                                          }
                              }
                              /*    critical     section      */;
                              turn     =    1;
                              flag     [0]   =   false;
                              /*    remainder         */;
                    }
              }
              void  P1(    )
              {
                    while        (true)      {
                              flag     [1]   =   true;
                              while       (flag  [0])      {
                                          if    (turn   ==    0)  {
                                                 flag   [1]   =   false;
                                                 while        (turn  ==  0)  /*  do  nothing  */;
                                                 flag   [1]   =   true;
                                          }
                              }
                              /*    critical     section      */;
                              turn     =    0;
                              flag     [1]   =   false;
                              /*    remainder         */;
                    }
              }
              void  main      ()
              {
                    flag   [0]      =  false;
                    flag   [1]      =  false;
                    turn      =   1;
                    parbegin           (P0,     P1);
              }
              Figure A.2   Dekker's Algorithm

Figure A.2 provides a specification of Dekker's algorithm. The construct
parbegin (P1, P2, . . . , Pn) means the following: suspend the execution of the main
program; initiate concurrent execution of procedures P1, P2, . . . , Pn; when all of P1,
P2, . . . , Pn have terminated, resume the main program. A verification of Dekker's
algorithm is left as an exercise (see Problem A.1).
Peterson's Algorithm
Dekker's algorithm solves the mutual exclusion problem but with a rather com-
plex program that is difficult to follow and whose correctness is tricky to prove.
Peterson [PETE81] has provided a simple, elegant solution. As before, the global
array variable flag indicates the position of each process with respect to mutual
exclusion, and the global variable turn resolves simultaneity conflicts. The algo-
rithm is presented in Figure A.3.
That mutual exclusion is preserved is easily shown. Consider process P0. Once
it has set flag[0] to true, P1 cannot enter its critical section. If P1 already is
in its critical section, then flag[1] = true and P0 is blocked from entering its
critical section. On the other hand, mutual blocking is prevented. Suppose that P0 is
blocked in its while loop. This means that flag[1] is true and turn = 1. P0 can
boolean     flag  [2];
int   turn;
void  P0()
{
      while       (true)   {
              flag    [0]  =       true;
              turn      =  1;
              while        (flag   [1]    &&  turn  ==  1)  /*  do  nothing  */;
              /*    critical        section   */;
              flag    [0]  =       false;
              /*    remainder       */;
      }
}
void  P1()
{
      while       (true)   {
              flag    [1]  =       true;
              turn      =  0;
              while        (flag   [0]    &&  turn  ==  0)  /*  do  nothing  */;
              /*    critical        section   */;
              flag    [1]  =       false;
              /*    remainder       */
      }
}
void  main()
{
      flag   [0]  =   false;
      flag   [1]  =   false;
      parbegin       (P0,     P1);
}
Figure A.3   Peterson's Algorithm for Two Processes

     enter its critical section when either flag[1] becomes false or turn becomes 0.
     Now consider three exhaustive cases:
     1.  P1 has no interest in its critical section. This case is impossible, because it
         implies flag[1] = false.
     2.  P1 is waiting for its critical section. This case is also impossible, because if
         turn = 1, P1 is able to enter its critical section.
     3.  P1 is using its critical section repeatedly and therefore monopolizing access
         to it. This cannot happen, because P1 is obliged to give P0 an opportunity by
         setting turn to 0 before each attempt to enter its critical section.
     Thus we have a simple solution to the mutual exclusion problem for two processes.
     Furthermore, Peterson's algorithm is easily generalized to the case of n processes
     [HOFR90].
A.2  RACE CONDITIONS AND SEMAPHORES
     Although the definition of a race condition, provided in Section 5.1, seems straight-
     forward, experience has shown that students usually have difficulty pinpointing
     race conditions in their programs. The purpose of this section, which is based on
     [CARR01],2 is to step through a series of examples using semaphores that should
     help clarify the topic of race conditions.
     Problem Statement
     Assume that there are two processes, A and B, each of which consists of a number
     of concurrent threads. Each thread includes an infinite loop in which a message is
     exchanged with a thread in the other process. Each message consists of an integer
     placed in a shared global buffer. There are two requirements:
     1.  After a thread A1 of process A makes a message available to some thread B1
         in B, A1 can only proceed after it receives a message from B1. Similarly, after
         B1 makes a message available to A1, it can only proceed after it receives a
         message from A1.
     2.  Once a thread A1 makes a message available, it must make sure that no other
         thread in A overwrites the global buffer before the message is retrieved by a
         thread in B.
         In the remainder of this section, we show four attempts to implement this
     scheme using semaphores, each of which can result in a race condition. Finally, we
     show a correct solution.
     2I am grateful to Professor Ching-Kuang Shene of Michigan Technological University for permission to
     use this example.

First Attempt
Consider this approach:
semaphore        a   =  0,     b  =  0;
int     buf_a,      buf_b;
thread_A(. . .)                              thread_B(. . .)
{                                            {
     int   var_a;                                   int      var_b;
     ...                                            ...
     while    (true)        {                       while       (true)  {
        .  .  .                                           .  .  .
        var_a     =. . .;                                 var_b     =. . .;
        semSignal(b);                                     semSignal(a);
        semWait(a);                                       semWait(b);
        buf_a     =  var_a;                               buf_b     =  var_b;
        var_a     =  buf_b;                               var_b     =  buf_a;
        .  .  .;                                          .  .  .;
     }                                              }
}                                            }
     This is a simple handshaking protocol. When a thread A1 in A is ready to
exchange messages, it sends a signal to a thread in B and then waits for a thread B1
in B to be ready. Once a signal comes back from B1, which A perceives by perform-
ing semWait(a), then A1 assumes that B1 is ready and performs the exchange. B1
behaves similarly, and the exchange happens regardless of which thread is ready first.
     This attempt can lead to race conditions. For example, consider the following
sequence, with time going vertically down the table:
                               Thread    A1     Thread          B1
                        semSignal(b)
                        semWait(a)
                                             semSignal(a)
                                             semWait(b)
                        buf_a     =  var_a
                        var_a     =  buf_b
                                             buf_b     =  var_b
     In the preceding sequence, A1 reaches semWait(a) and is blocked. B1
reaches semWait(b) and is not blocked, but is switched out before it can update
its buf_b. Meanwhile, A1 executes and reads from buf_b before it has the
intended value. At this point, buf_b may have a value provided previously by
another thread or provided by B1 in a previous exchange. This is a race condition.
     A subtler race condition can be seen if two threads in A and B are active.
Consider the following sequence:

      Thread   A1                    Thread         A2                Thread          B1          Thread  B2
semSignal(b)
semWait(a)
                                                                  semSignal(a)
                                                                  semWait(b)
                                semSignal(b)
                                semWait(a)
                                                                  buf_b     =     var_b1
                                                                                                  semSignal(a)
buf_a  =  var_a1
                                buf_a      =     var_a2
              In this sequence, threads A1 and B1 attempt to exchange messages and
       go through the proper semaphore signaling instructions. However, immediately
       after the two semWait signals occur (in threads A1 and B1), thread A2 runs and
       executes semSignal(b) and semWait(a), which causes thread B2 to execute
       semSignal(a) to release A2 from semWait(a). At this point, either A1 or A2
       could update buf_a next, and we have a race condition. By changing the sequence
       of execution among the threads, we can readily find other race conditions.
              Lesson Learned: When a variable is shared by multiple threads, race condi-
       tions are likely to occur unless proper mutual exclusion protection is used.
       Second Attempt
       For this attempt, we use a semaphore to protect the shared variable. The purpose is
       to ensure that access to buf_a and buf_b are mutually exclusive. The program is as
       follows:
       semaphore             a   =  0,     b     =  0;  mutex  =  1;
       int     buf_a,           buf_b;
       thread_A(. . .)                                         thread_B(. . .)
       {                                                       {
            int        var_a;                                     int       var_b;
            .    .     .                                          .   .     .
            while            (true)     {                         while           (true)  {
                    .     .  .                                           .     .  .
                    var_a        =. . .;                                 var_b        =. . .;
                    semSignal(b);                                        semSignal(a);
                    semWait(a);                                          semWait(b);
                             semWait(mutex);                                      semWait(mutex);
                                 buf_a        =     var_a;                            buf_b    =  var_b;
                             semSignal(mutex);                                    semSignal(mutex);
                    semSignal(b);                                        semSignal(a);
                    semWait(a);                                          semWait(b);
                             semWait(mutex);                                      semWait(mutex);
                                 var_a        =     buf_b;                            var_b    =  buf_a;
                             semSignal(mutex);                                    semSignal(mutex);
                    .     .  .;                                          .     .  .;
            }                                                     }
       }                                                       }

    Before a thread can exchange a message, it follows the same handshak-
ing protocol as in the first attempt. The semaphore mutex protects buf_a
and buf_b in an attempt to assure that update precedes reading. But the protec-
tion is not adequate. Once both threads complete the first handshaking stage,
the values of semaphores a and b are both 1. There are three possibilities that
could occur:
1.  Two threads, say A1 and B1, complete the first handshaking and continue
    with the second stage of the exchange.
2.  Another pair of threads starts the first stage.
3.  One of the current pair will continue and exchange a message with a new-
    comer in the other pair.
    All of these possibilities can lead to race conditions. As an example of a race
condition based on the third possibility, consider the following sequence:
       Thread    A1                  Thread  A2                    Thread   B1
semSignal(b)
semWait(a)
                                                            semSignal(a)
                                                            semWait(b)
buf_a  =   var_a1
                                                            buf_b  =  var_b1
                              semSignal(b)
                              semWait(a)
                                                            semSignal(a)
                                                            semWait(b)
                              buf_a  =  var_a2
    In this example, after A1 and B1 go through the first handshake, they both
update the corresponding global buffers. Then A2 initiates the first handshaking
stage. Following this, B1 initiates the second handshaking stage. At this point, A2
updates buf_a before B1 can retrieve the value placed in buf_a by A1. This is a
race condition.
    Lesson Learned: Protecting a single variable may be insufficient if the use
of that variable is part of a long execution sequence. Protect the whole execution
sequence.
Third Attempt
For this attempt, we want to expand the critical section to include the entire mes-
sage exchange (two threads each update one of two buffers and read from the other
buffer). A single semaphore is insufficient because this could lead to deadlock, with
each side waiting on the other. The program is as follows:

      semaphore       aready        =  1,  adone   =   0,  bready  =  1   bdone     =  0;
      int     buf_a,     buf_b;
      thread_A(. . .)                                      thread_B(. . .)
      {                                                    {
           int     var_a;                                     int     var_b;
           ...                                                ...
           while      (true)     {                            while      (true)     {
                .  .  .                                            .  .  .
                var_a     =. . .;                                  var_b     =. . .;
                semWait(aready);                                   semWait(bready);
                      buf_a   =     var_a;                               buf_b   =     var_b;
                      semSignal(adone);                                  semSignal(bdone);
                      semWait(bdone);                                    semWait(adone);
                      var_a   =     buf_b;                               var_b   =     buf_a;
                semSignal(aready);                                 semSignal(bready);
                .  .  .;                                           .  .  .;
           }                                                  }
      }                                                    }
           The semaphore aready is intended to insure that no other thread in A can update
      buf_a while one thread from A enters its critical section. The semaphore adone is
      intended to insure that no thread from B will attempt to read buf_a until buf_a has
      been updated. The same considerations apply to bready and bdone. However, this
      scheme does not prevent race conditions. Consider the following sequence:
                                       Thread  A1                Thread     B1
                             buf_a     =   var_a
                             semSignal(adone)
                             semWait(bdone)
                                                           buf_b   =  var_b
                                                           semSignal(bdone)
                                                           semWait(adone)
                             var_a     =   buf_b;
                             semSignal(aready)
                             . . .loop      back. . .
                             semWait(aready)
                             buf_a     =   var_a
                                                           var_b   =  buf_a
           In this sequence, both A1 and B1 enter their critical sections, deposit their
      messages, and reach the second wait. Then A1 copies the message from B1 and leaves
      its critical section. At this point, A1 could loop back in its program, generate a new
      message, and deposit it in buf_a, as shown in the preceding execution sequence.
      Another possibility is that at this same point another thread of A could generate a mes-
      sage and put it in buf_a. In either case, a message is lost and a race condition occurs.

     Lesson Learned: If we have a number of cooperating thread groups, mutual
exclusion guaranteed for one group may not prevent interference from threads in
other groups. Further, if a critical section is repeatedly entered by one thread, then
the timing of the cooperation between threads must be managed properly.
Fourth Attempt
The third attempt fails to force a thread to remain in its critical section until the
other thread retrieves the message. Here is an attempt to achieve this objective:
semaphore       aready        =  1,  adone  =  0,  bready  =  1   bdone     =  0;
int     buf_a,     buf_b;
thread_A(. . .)                                    thread_B(. . .)
{                                                  {
     int     var_a;                                   int     var_b;
     ...                                              ...
     while      (true)     {                          while      (true)     {
          .  .  .                                          .  .  .
          var_a     =. . .;                                var_b     =. . .;
          semWait(bready);                                 semWait(aready);
                buf_a   =     var_a;                             buf_b   =     var_b;
                semSignal(adone);                                semSignal(bdone);
                semWait(bdone);                                  semWait(adone);
                var_a   =     buf_b;                             var_b   =     buf_a;
          semSignal(aready);                               semSignal(bready);
          .  .  .;                                         .  .  .;
     }                                                }
}                                                  }
     In this case, the first thread in A to enter its critical section decrements
bready to 0. No subsequent thread from A can attempt a message exchange until a
thread from B completes the message exchange and increments bready to 1. This
approach too can lead to race conditions, such as in the following sequence:
                Thread     A1               Thread    A2              Thread   B1
        semWait(bready)
        buf_a      =  var_a1
        semSignal(adone)
                                                                 semWait(aready)
                                                                 buf_b   =     var_b1
                                                                 semSignal(bdone)
                                                                 semWait(adone)
                                                                 var_b   =     buf_a
                                                                 semSignal(bready)
                                      semWait(bready)
                                      .  .  .
                                      semWait(bdone)
                                      var_a2   =   buf_b

             In this sequence, threads A1 and B1 enter corresponding critical sections in
      order to exchange messages. Thread B1 retrieves its message and signals bready.
      This enables another thread from A, A2, to enter its critical section. If A2 is faster
      than A1, then A2 may retrieve the message that was intended for A1.
             Lesson Learned: If the semaphore for mutual exclusion is not released by its
      owner, race conditions can occur. In this fourth attempt, a semaphore is locked by a
      thread in A and then unlocked by a thread in B. This is risky programming practice.
      A Good Attempt
      The reader may notice that the problem in this section is a variation of the bounded-
      buffer problem and can be approached in a manner similar to the discussion
      in Section 5.4. The most straightforward approach is to use two buffers, one for
      B-to-A messages and one for A-to-B messages. The size of each buffer needs to be
      one. To see the reason for this, consider that there is no ordering assumption for
      releasing threads from a synchronization primitive. If a buffer has more than one
      slot, then we cannot guarantee that the messages will be properly matched. For
      example, B1 could receive a message from A1 and then send a message to A1. But
      if the buffer has multiple slots, another thread in A may retrieve the message from
      the slot intended for A1.
             Using the same basic approach as was used in Section 5.4, we can develop the
      following program:
      semaphore         notFull_A     =     1,    notFull_B  =  1;
      semaphore         notEmpty_A       =    0,  notEmpty_B    =    0;
      int       buf_a,     buf_b;
      thread_A(. . .)                             thread_B(. . .)
      {                                           {
             int     var_a;                                     int     var_b;
             ...                                                ...
             while      (true)     {                            while       (true)     {
                  .  .  .                                            .   .  .
                  var_a     =. . .;                                  var_b      =. . .;
                  semWait(notFull_A);                                semWait(notFull_B);
                        buf_a   =     var_a;                                buf_b   =     var_b;
                        semSignal(notEmpty_A);                              semSignal(notEmpty_B);
                  semWait(notEmpty_B);                               semWait(notEmpty_A);
                        var_a   =     buf_b;                                var_b   =     buf_a;
                        semSignal(notFull_B);                               semSignal(notFull_A);
                  .  .  .;                                           .   .  .;
             }                                                  }
      }                                           }
             To verify that this solution works, we need to address three issues:
         1.  The message exchange section is mutually exclusive within the thread group.
             Because the initial value of notFull_A is 1, only one thread in A can pass
             through semWait(notFull_A) until the exchange is complete as signaled

         by a thread in B that executes semSignal(notFull_A). A similar reason-
         ing applies to threads in B. Thus, this condition is satisfied.
     2.  Once two threads enter their critical sections, they exchange messages with-
         out interference from any other threads. No other thread in A can enter its
         critical section until the thread in B is completely done with the exchange, and
         no other thread in B can enter its critical section until the thread in A is com-
         pletely done with the exchange. Thus, this condition is satisfied.
     3.  After one thread exits its critical section, no thread in the same group can
         rush in and ruin the existing message. This condition is satisfied because a
         one-slot buffer is used in each direction. Once a thread in A has executed
         semWait(notFull_A) and entered its critical section, no other thread in A
         can update buf_a until the corresponding thread in B has retrieved the value
         in buf_a and issued a semSignal(notFull_A).
         Lesson Learned: It is well to review the solutions to well-known problems,
     because a correct solution to the problem at hand may be a variation of a solution
     to a known problem.
A.3  A BARBERSHIP PROBLEM
     As another example of the use of semaphores to implement concurrency, we
     consider a simple barbershop problem.3 This example is instructive because the
     problems encountered when attempting to provide tailored access to barbershop
     resources are similar to those encountered in a real operating system.
         Our barbershop has three chairs, three barbers, and a waiting area that can
     accommodate four customers on a sofa and that has standing room for additional
     customers (Figure A.4). Fire codes limit the total number of customers in the shop
                                           Barber chairs
         Entrance                                               Cashier
                           Standing                                          Exit
                           room
                           area                           Sofa
         Figure A.4        The Barbershop
     3I am indebted to Professor Ralph Hilzer of California State University at Chico for supplying this treat-
     ment of the problem.

      to 20. In this example, we assume that the barbershop will eventually process 50
      customers.
         A customer will not enter the shop if it is filled to capacity with other custom-
      ers. Once inside, the customer takes a seat on the sofa or stands if the sofa is filled.
      When a barber is free, the customer that has been on the sofa the longest is served
      and, if there are any standing customers, the one that has been in the shop the long-
      est takes a seat on the sofa. When a customer's haircut is finished, any barber can
      accept payment, but because there is only one cash register, payment is accepted for
      one customer at a time. The barbers divide their time among cutting hair, accepting
      payment, and sleeping in their chair waiting for a customer.
      An Unfair Barbershop
      Figure A.5 shows an implementation using semaphores; the three procedures are
      listed side-by-side to conserve space. We assume that all semaphore queues are
      handled with a first-in-first-out policy.
         The main body of the program activates 50 customers, 3 barbers, and the cashier
      process. We now consider the purpose and positioning of the various synchronization
      operators:
      ·  Shop and sofa capacity: The capacity of the shop and the capacity of the sofa
         are governed by the semaphores max_capacity and sofa, respectively.
         Every time a customer attempts to enter the shop, the max_capacity sema-
         phore is decremented by 1; every time a customer leaves, the semaphore
         is incremented. If a customer finds the shop full, then that customer's pro-
         cess is blocked on max_capacity by the semWait function. Similarly, the
         semWait and semSignal operations surround the actions of sitting on and
         getting up from the sofa.
      ·  Barber chair capacity: There are three barber chairs, and care must be taken
         that they are used properly. The semaphore barber_chair assures that
         no more than three customers attempt to obtain service at a time, trying to
         avoid the undignified occurrence of one customer sitting on the lap of another.
         A customer will not get up from the sofa until at least one chair is free
         [semWait(barber_chair)], and each barber signals when a customer has
         left that barber's chair [semSignal(barber_chair)]. Fair access to the
         barber chairs is guaranteed by the semaphore queue organization: The first
         customer to be blocked is the first one allowed into an available chair. Note
         that, in the customer procedure, if semWait(barber_chair) occurred
         after semSignal(sofa), each customer would only briefly sit on the sofa
         and then stand in line at the barber chairs, creating congestion and leaving the
         barbers with little elbow room.
      ·  Ensuring customers are in barber chair: The semaphore cust_ready pro-
         vides a wakeup signal for a sleeping barber, indicating that a customer has just
         taken a chair. Without this semaphore, a barber would never sleep but would
         begin cutting hair as soon as a customer left the chair; if no new customer had
         grabbed the seat, the barber would be cutting air.

      semaphore     max_capacity        =   20;
      semaphore     sofa   =     4;
      semaphore     barber_chair        =   3;
      semaphore     coord     =  3;
      semaphore     cust_ready       =  0,  finished  =  0,  leave_b_chair        =  0,  payment  =  0,  receipt  =  0;
      void  customer()                                       void        barber()                                    Void   cashier()
      {                                                      {                                                       {
          semWait(max_capacity);                                      while  (true)                                      while  (true)
          enter_shop();                                               {                                                  {  semWait(payment);
          semWait(sofa);                                                 semWait(cust    ready);                            semWait(coord);
          sit_on_sofa();                                                 semWait(coord);                                    accept_pay();
          semWait(barber_chair);                                         cut_hair();                                        semSignal(coord);
          get_up_from_sofa();                                            semSignal(coord);                                  semSignal(receipt);
          semSignal(sofa);                                               semSignal(finished);                            }
          sit_in_barber_chair();                                         semWait(leave_b_chair);                     }
          semSignal(cust_ready);                                         semSignal(barber_chair);
          semWait(finished);                                          }
          leave_barber_chair();                              }
          semSignal(leave_b_chair);
          pay();
          semSignal(payment);
          semWait(receipt);
          exit_shop();
          semSignal(max_capacity)
      }
      void  main()
      {
          parbegin  (customer,. . .50           times,. . .customer,     barber,   barber,  barber,  cashier);
      }
      Figure A.5  An Unfair Barbershop
A-17

      ·  Holding customers in barber chair: Once seated, a customer remains in the
         chair until the barber gives the signal that the haircut is complete, using the
         semaphore finished.
      ·  Limiting one customer to a barber chair: The semaphore barber_chair
         is intended to limit the number of customers in barber chairs to three.
         However, by itself, barber_chair does not succeed in doing this. A cus-
         tomer that fails to get the processor immediately after his barber executes
         semSignal(finished) (i.e., one who falls into a trance or stops to chat
         with a neighbor) may still be in the chair when the next customer is given the
         go ahead to be seated. The semaphore leave_b_chair is intended to cor-
         rect this problem by restraining the barber from inviting a new customer into
         the chair until the lingering one has announced his departure from it. In the
         problems at the end of this chapter, we will find that even this precaution fails
         to stop the mettlesome customer lap sittings.
      ·  Paying and receiving: Naturally, we want to be careful when dealing with
         money. The cashier wants to be assured that each customer pays before leav-
         ing the shop, and the customer wants verification that payment was received
         (a receipt). This is accomplished, in effect, by a face-to-face transfer of the
         money. Each customer, upon arising from a barber chair, pays, then alerts the
         cashier that money has been passed over [semSignal(payment)], and then
         waits for a receipt [semWait(receipt)]. The cashier process repeatedly
         takes payments: It waits for a payment to be signaled, accepts the money, and
         then signals acceptance of the money. Several programming errors need to be
         avoided here. If semSignal(payment) occurred just before the action pay,
         then a customer could be interrupted after signaling; this would leave the cash-
         ier free to accept payment even though none had been offered. An even more
         serious error would be to reverse the positions of the semSignal(payment)
         and semWait(receipt) lines. This would lead to deadlock because that
         would cause all customers and the cashier to block at their respective semWait
         operators.
      ·  Coordinating barber and cashier functions: To save money, this barbershop
         does not employ a separate cashier. Each barber is required to perform that
         task when not cutting hair. The semaphore coord ensures that barbers per-
         form only one task at a time.
         Table A.1 summarizes the use of each of the semaphores in the program.
         The cashier process could be eliminated by merging the payment function
      into the barber procedure. Each barber would sequentially cut          hair and then
      accept  pay. However, with a single cash register, it is necessary to limit access to
      the accept     pay function to one barber at a time. This could be done by treating
      that function as a critical section and guarding it with a semaphore.
      A Fair Barbershop
      Figure A.5 is a good effort, but some difficulties remain. One problem is solved
      in the remainder of this section; others are left as exercises for the reader (see
      Problem A.6).

Table A.1  Purpose  of Semaphores in Figure A.5
Semaphore           Wait Operation                                    Signal Operation
max_capacity        Customer waits for space to enter shop.           Exiting customer signals customer
                                                                      waiting to enter.
sofa                Customer waits for seat on sofa.                  Customer leaving sofa signals cus-
                                                                      tomer waiting for sofa.
barber_chair        Customer waits for empty barber chair.            Barber signals when that barber's
                                                                      chair is empty.
cust_ready          Barber waits until a customer is in the chair.    Customer signals barber that
                                                                      customer is in the chair.
finished            Customer waits until his haircut is complete.     Barber signals when cutting hair
                                                                      of this customer is done.
leave_b_chair       Barber waits until customer gets up from the      Customer signals barber when
                    chair.                                            customer gets up from chair.
payment             Cashier waits for a customer to pay.              Customer signals cashier that he
                                                                      has paid.
receipt             Customer waits for a receipt for payment.         Cashier signals that payment has
                                                                      been accepted.
coord               Wait for a barber resource to be free to perform  Signal that a barber resource is
                    either the hair cutting or cashiering function.   free.
            There is a timing problem in Figure A.5 that could lead to unfair treat-
       ment of customers. Suppose that three customers are currently seated in the
       three barber chairs. In that case, the customers would most likely be blocked on
       semWait(finished), and due to the queue organization they would be released
       in the order they entered the barber chair. However, what if one of the barbers is
       very fast or one of the customers is quite bald? Releasing the first customer to enter
       the chair could result in a situation where one customer is summarily ejected from
       his seat and forced to pay full price for a partial haircut while another is restrained
       from leaving his chair even though his haircut is complete.
            The problem is solved with more semaphores, as shown in . We assign a unique
       customer number to each customer; this is equivalent to having each customer
       take a number upon entering the shop. The semaphore mutex1 protects access to
       the global variable count so that each customer receives a unique number. The
       semaphore finished is redefined to be an array of 50 semaphores. Once a cus-
       tomer is seated in a barber chair, he executes semWait(finished[custnr]) to
       wait on his own unique semaphore; when the barber is finished with that customer,
       the barber executes semSignal(finished[b_cust]) to release the correct
       customer.
            It remains to say how a customer's number is known to the barber. A customer
       places his number on the queue enqueue1 just prior to signaling the barber with the
       semaphore cust_ready. When a barber is ready to cut hair, dequeue1(b_cust)
       removes the top customer number from queue1 and places it in the barber's local
       variable b_cust.

      semaphore     max_capacity          =   20;
      semaphore     sofa   =   4;
      semaphore     barber_chair          =   3,   coord   =  3;
      semaphore     mutex1     =   1,     mutex2    =  1;
      semaphore     cust_ready         =  0,  leave_b_chair       =  0,  payment=   0,  receipt  =  0;
      semaphore     finished      [50]    =   {0};
      int   count;
      void  customer       ()                                 void   barber()                                        void  cashier()
      {                                                       {                                                      {
           int    custnr;                                         int    b_cust;                                        while  (true)
           semWait(max_capacity);                                 while  (true)                                         {
           enter_shop();                                          {                                                        semWait(payment);
           semWait(mutex1);                                            semWait(cust_ready);                                semWait(coord);
           custnr   =  count;                                          semWait(mutex2);                                    accept_pay();
           count++;                                                    dequeue1(b_cust);                                   semSignal(coord);
           semSignal(mutex1);                                          semSignal(mutex2);                                  semSignal(receipt);
           semWait(sofa);                                              semWait(coord);                                  }
           sit_on_sofa();                                              cut_hair();                                   }
           semWait(barber_chair);                                      semSignal(coord);
           get_up_from_sofa();                                         semSignal(finished[b_cust]);
           semSignal(sofa);                                            semWait(leave_b_chair);
           sit_in_barber_chair();                                      semSignal(barber_chair);
           semWait(mutex2);                                       }
           enqueue1(custnr);                                  }
           semSignal(cust_ready);
           semSignal(mutex2);
           semWait(finished[custnr]);
           leave_barber_chair();
           semSignal(leave_b_chair);
           pay();
           semSignal(payment);
           semWait(receipt);
           exit_shop();
                semSignal(max_capacity)
      }
      void  main()
      {    count   :=  0;
           parbegin    (customer,. . .50           times,. . .customer,  barber,    barber,      barber,  cashier);
      }
      Figure A.6   A Fair Barbershop

A.4  PROBLEMS
     A.1  Demonstrate the correctness of Dekker's algorithm.
          a.  Show that mutual exclusion is enforced. Hint: Show that when Pi enters its critical
              section, the following expression is true:
                             flag[i]    and     (  not    flag[1  -    i]  )
          b.  Show that a process requiring access to its critical section will not be delayed
              indefinitely. Hint: Consider the following cases: (1) A single process is attempting
              to enter the critical section; (2) both processes are attempting to enter the critical
              section, and (2a) turn  =  0 and flag[0]      =     false, and (2b) turn  =  0 and
              flag[0]  =     true.
     A.2  Consider Dekker's algorithm, written for an arbitrary number of processes by chang-
          ing the statement executed when leaving the critical section from
               turn = 1 - i         /* i.e. P0 sets turn to 1 and P1 sets turn to 0 */
          to
                       turn = (turn + 1) % n       /* n = number of processes */
          Evaluate the algorithm when the number of concurrently executing processes is
          greater than two.
     A.3  Demonstrate that the following software approaches to mutual exclusion do not
          depend on elementary mutual exclusion at the memory access level:
          a.  the bakery algorithm
          b.  Peterson's algorithm
     A.4  Answer the following questions relating to the fair barbershop (Figure A.6):
          a.  Does the code require that the barber who finishes a customer's haircut collect
              that customer's payment?
          b.  Do barbers always use the same barber chair?
     A.5  A number of problems remain with the fair barbershop of Figure A.6. Modify the
          program to correct the following problems.
          a.  The cashier may accept pay from one customer and release another if two or
              more are waiting to pay. Fortunately, once a customer presents payment, there is
              no way for him to un-present it, so in the end, the right amount of money ends up
              in the cash register. Nevertheless, it is desirable to release the right customer as
              soon as his payment is taken.
          b.  The semaphore leave_b_chair supposedly prevents multiple access to a sin-
              gle barber chair. Unfortunately, this semaphore does not succeed in all cases.
              For example, suppose that all three barbers have finished cutting hair and are
              blocked at semWait(leave_b_chair). Two of the customers are in an inter-
              rupted state just prior to leave     barber  chair. The third customer leaves his
              chair and executes semSignal(leave_b_chair). Which barber is released?
              Because the leave_b_chair queue is first in first out, the first barber that was
              blocked is released. Is that the barber that was cutting the signaling customer's
              hair? Maybe, but maybe not. If not, then a new customer will come along and sit
              on the lap of a customer that was just about to get up.
          c.  The program requires a customer first sits on the sofa even if a barber chair is
              empty. Granted, this is a rather minor problem, and fixing it makes code that is
              already a bit messy even messier. Nevertheless, give it a try.


          PROGRAMMING AND OPERATING
                       SYSTEM PROJECTS
     B.1  OS/161
     B.2  Simulations
     B.3  Programming Projects
          Textbook-Defined Projects
          Additional Major Programming Projects
          Small Programming Projects
     B.4  Research Projects
     B.5  Reading/Report Assignments
     B.6  Writing Assignments
     B.7  Discussion Topics
     B.8  BACI
B-1

     Analysis and observation, theory and experience must never disdain
     or exclude each other; on the contrary, they support each other.
                                              --ON WAR, Carl Von Clausewitz
     Many instructors believe that implementation or research projects are crucial to
     the clear understanding of operating system concepts. Without projects, it may be
     difficult for students to grasp some of the basic OS abstractions and interactions
     among components; a good example of a concept that many students find difficult
     to master is that of semaphores. Projects reinforce the concepts introduced in this
     book, give the student a greater appreciation of how the different pieces of an OS fit
     together, and can motivate students and give them confidence that they are capable
     of not only understanding but also implementing the details of an OS.
        In this text, I have tried to present the concepts of OS internals as clearly
     as possible and have provided numerous homework problems to reinforce those
     concepts. Many instructors will wish to supplement this material with projects. This
     appendix provides some guidance in that regard and describes support material
     available at the instructor's Web site. The support material covers eight types of
     projects and other student exercises:
     ·  OS/161 projects
     ·  Simulation projects
     ·  Programming projects
     ·  Research projects
     ·  Reading/report assignments
     ·  Writing assignments
     ·  Discussion topics
     ·  BACI
B.1  OS/161
     The Instructor's Resource Center (IRC) for this book provides support for using
     OS/161 as an active learning component.
        OS/161 is an educational operating system developed at Harvard University
     [HOLL02]. It aims to strike a balance between giving students experience in work-
     ing on a real operating system, and potentially overwhelming students with the
     complexity that exists in a fully-fledged operating system, such as Linux. Compared
     to most deployed operating systems, OS/161 is quite small (approximately 20,000
     lines of code and comments), and therefore it is much easier to develop an under-
     standing of the entire code base.
        The source code distribution contains a full operating system source tree,
     including the kernel, libraries, various utilities (ls, cat,...), and some test programs.
     OS/161 boots on the simulated machine in the same manner as a real system might
     boot on real hardware.

        System/161 simulates a "real" machine to run OS/161 on. The machine fea-
     tures a MIPS R2000/R3000 CPU including an MMU, but no floating-point unit or
     cache. It also features simplified hardware devices hooked up to the system bus.
     These devices are much simpler than real hardware, and thus make it feasible for
     students to get their hands dirty without having to deal with the typical level of
     complexity of physical hardware. Using a simulator has several advantages: Unlike
     other software students write, buggy OS software may result in completely locking
     up the machine, making it difficult to debug and requiring a reboot. A simulator
     enables debuggers to access the machine below the software architecture level as
     if debugging was built into the CPU. In some senses, the simulator is similar to an
     in-circuit emulator (ICE) that you might find in industry, only it is implemented in
     software. The other major advantage is the speed of reboots. Rebooting real hard-
     ware takes minutes, and hence the development cycle can be frustratingly slow on
     real hardware. System/161 boots OS/161 in mere seconds.
        The OS/161 and System/161 simulators can be hosted on a variety of plat-
     forms, including Unix, Linux, Mac OS X, and Cygwin (the free Unix environment
     for Windows).
        The IRC includes the following:
     ·  Package for instructor's Web server: A set of html and pdf files that can be
        easily uploaded to the instructor's site for the OS course, which provide all
        the online resources for OS/161 and S/161 access, user's guides for students,
        assignments, and other useful material.
     ·  Getting started for instructors: This guide lists all of the files that make up the
        Web site for the course and instructions on how to set up the Web site.
     ·  Getting started for students: This guide explains to students step-by-step how
        to download and install OS/161 and S/161 on their PC.
     ·  Background material for students: This consists of two documents that pro-
        vide an overview of the architecture of S/161 and the internals of OS/161.
        These overviews are intended to be sufficient so that the student is not over-
        whelmed with figuring out what these systems are.
     ·  Student exercises: A set of exercises that cover some of the key aspects of
        OS internals, including support for system calls, threading, synchronization,
        locks and condition variables, scheduling, virtual memory, files systems, and
        security
        The IRC OS/161 package was prepared by Andrew Peterson and other
     colleagues and students at the University of Toronto.
B.2  SIMULATIONS
     The IRC provides support for assigning projects based on a set of simulations devel-
     oped at the University of Texas, San Antonio. Table B.1 lists the simulations by
     chapter. The simulators are all written in Java and can be run either locally as a Java
     application or online through a browser.

Table B.1  OS Simulations by Chapter
                       Chapter 5 ­ Concurrency: Mutual Exclusion and Synchronization
Producer-consumer                                Allows the user to experiment with a bounded buffer
                                                 synchronization problem in the context of a single
                                                 producer and a single consumer
UNIX Fork-pipe                                   Simulates a program consisting of pipe, dup2,
                                                 close, fork, read, write, and print instructions
                       Chapter 6 ­ Concurrency: Deadlock and Starvation
Starving philosophers                            Simulates the dining philosophers problem
                                Chapter 8 ­ Virtual Memory
Address translation                              Used for exploring aspects of address translation. It
                                                 supports 1- and 2-level page tables and a translation
                                                 lookaside buffer
                       Chapter 9 ­ Uniprocessor Scheduling
Process scheduling                               Allows users to experiment with various process
                                                 scheduling algorithms on a collection of processes
                                                 and to compare such statistics as throughput and
                                                 waiting time
                       Chapter 11 ­ I/O Management and Disk Scheduling
Disk head scheduling                             Supports the standard scheduling algorithms such
                                                 as FCFS, SSTF, SCAN, LOOK, C-SCAN, and
                                                 C-LOOK as well as double buffered versions of these
                                Chapter 12 ­ File Management
Concurrent I/O                                   Simulates a program consisting of open, close,
                                                 read, write, fork, wait, pthread_create,
                                                 pthread_detach, and pthread_join instructions
                The IRC includes the following:
           1.   A brief overview of the simulations available.
           2.   How to port them to the local environment.
           3.   Specific assignments to give to students, telling them specifically what they are
                to do and what results are expected. For each simulation, this section provides
                one or two original assignments that the instructor can assign to students.
                These simulation assignments were developed by Adam Critchley (University
     of Texas at San Antonio).
B.3  PROGRAMMING PROJECTS
     Three sets of programming projects are provided.
     Textbook-Defined Projects
     Two major programming projects, one to build a shell, or command line interpreter,
     and one to build a process dispatcher are described in the online portion of the

     textbook. The projects can be assigned after Chapter 3 and after Chapter 9, respec-
     tively. The IRC provides further information and step-by-step exercises for devel-
     oping the programs.
         These projects were developed by Ian G. Graham of Griffith University,
     Australia.
     Additional Major Programming Projects
     A set of programming assignments, called machine problems (MPs), are available
     that are based on the Posix Programming Interface. The first of these assignments
     is a crash course in C, to enable the student to develop sufficient proficiency in C to
     be able to do the remaining assignments. The set consists of nine machine problems
     with different difficulty degrees. It may be advisable to assign each project to a team
     of two students.
         Each MP includes not only a statement of the problem but a number of C files
     that are used in each assignment, step-by-step instructions, and a set of questions for
     each assignment that the student must answer that indicate a full understanding of
     each project. The scope of the assignments includes:
     1.  Create a program to run in a shell environment using basic I/O and string
         manipulation functions.
     2.  Explore and extend a simple Unix shell interpreter.
     3.  Modify faulty code that utilizes threads.
     4.  Implement     a  multithreaded  application       using  thread  synchronization
         primitives.
     5.  Write a user­mode thread scheduler
     6.  Simulate a time-sharing system by using signals and timers
     7.  A six-week project aimed at creating a simple yet functional networked file
         system. Covers I/O and file system concepts, memory management, and net-
         working primitives.
         The IRC provides specific instructions for setting up the appropriate support
     files on the instructor's Web site of local server.
         These project assignments were developed at the University of Illinois at
     Urbana-Champaign, Department of Computer Science and adapted by Matt Sparks
     (University of Illinois at Urbana-Champagne) for use with this textbook.
     Small Programming Projects
     The instructor can also assign a number of small programming projects described in
     the IRC. The projects can be programmed by the students on any available compu-
     ter and in any appropriate language: They are platform and language independent.
         These small projects have certain advantages over the larger projects. Larger
     projects usually give students more of a sense of achievement, but students with
     less ability or fewer organizational skills can be left behind. Larger projects usually
     elicit more overall effort from the best students. Smaller projects can have a higher
     concepts-to-code ratio, and because more of them can be assigned, the opportu-
     nity exists to address a variety of different areas. Accordingly, the instructor's IRC

     contains a series of small projects, each intended to be completed in a week or
     so, which can be very satisfying to both student and teacher. These projects were
     developed at Worcester Polytechnic Institute by Stephen Taylor, who has used and
     refined the projects in the course of teaching operating systems a dozen times.
B.4  RESEARCH PROJECTS
     An effective way of reinforcing basic concepts from the course and for teaching
     students research skills is to assign a research project. Such a project could involve
     a literature search as well as a Web search of vendor products, research lab activi-
     ties, and standardization efforts. Projects could be assigned to teams or, for smaller
     projects, to individuals. In any case, it is best to require some sort of project proposal
     early in the term, giving the instructor time to evaluate the proposal for appropriate
     topic and appropriate level of effort. Student handouts for research projects should
     include
     ·  A format for the proposal
     ·  A format for the final report
     ·  A schedule with intermediate and final deadlines
     ·  A list of possible project topics
        The students can select one of the listed topics or devise their own comparable
     project. The IRC includes a suggested format for the proposal and final report as
     well as a list of possible research topics developed by Professor Tan N. Nguyen of
     George Mason University.
B.5  READING/REPORT ASSIGNMENTS
     Another excellent way to reinforce concepts from the course and to give students
     research experience is to assign papers from the literature to be read and analyzed.
     The IRC includes a suggested list of papers to be assigned, organized by chapter.
     The Premium Content Web site provides a copy of each of the papers. The IRC also
     includes a suggested assignment wording.
B.6  WRITING ASSIGNMENTS
     Writing assignments can have a powerful multiplier effect in the learning process
     in a technical discipline such as OS internals. Adherents of the Writing Across the
     Curriculum (WAC) movement (http://wac.colostate.edu/) report substantial bene-
     fits of writing assignments in facilitating learning. Writing assignments lead to more
     detailed and complete thinking about a particular topic. In addition, writing assign-
     ments help to overcome the tendency of students to pursue a subject with a mini-
     mum of personal engagement, just learning facts and problem-solving techniques
     without obtaining a deep understanding of the subject matter.

     The IRC contains a number of suggested writing assignments, organized
     by chapter. Instructors may ultimately find that this is an important part of their
     approach to teaching the material. I would greatly appreciate any feedback on this
     area and any suggestions for additional writing assignments.
B.7  DISCUSSION TOPICS
     One way to provide a collaborative experience is discussion topics, a number of
     which are included in the IRC. Each topic relates to material in the book. The
     instructor can set it up so that students can discuss a topic either in a class setting, an
     online chat room, or a message board. Again, I would greatly appreciate any feed-
     back on this area and any suggestions for additional discussion topics.
B.8  BACI
     In addition to all of the support provided at the IRC, the Ben-Ari Concurrent
     Interpreter (BACI) is a publicly available package that instructors may wish to use.
     BACI simulates concurrent process execution and supports binary and counting
     semaphores and monitors. BACI is accompanied by a number of project assign-
     ments to be used to reinforce concurrency concepts.
     Appendix O provides a more detailed introduction to BACI, with information
     about how to obtain the system and the assignments.


In studying the Imperium, Arrakis, and the whole culture which produced
Maud'Dib, many unfamiliar terms occur. To increase understanding is a laud-
able goal, hence the definitions and explanations given below
                                                                                 --DUNE, Frank Herbert
access method      The method that is used to             binary semaphore           A semaphore that takes
       find a file, a record, or a set of records.               on only the values 0 and 1. A binary
address space      The range of addresses avail-                 semaphore allows only one process or
       able to a computer program.                               thread to have access to a shared criti-
address translator     A    functional       unit  that          cal resource at a time.
       transforms      virtual  addresses     to   real   block      (1)      A  collection   of    contiguous
       addresses.                                                records that are recorded as a unit; the
application      programming    interface         (API)          units are separated by interblock gaps.
       A    standardized    library      of  program-            (2) A group of bits that are transmitted
       ming tools used by software developers                    as a unit.
       to write applications that are compat-             B-tree     A technique for organizing indexes.
       ible with a specific operating system or                  In  order       to  keep   access  time     to  a
       graphic user interface.                                   minimum, it stores the data keys in a
asynchronous operation          An operation that                balanced        hierarchy   that   continually
       occurs without a regular or predictable                   realigns itself as items are inserted and
       time relationship to a specified event,                   deleted. Thus, all nodes always have a
       for  example,   the      calling  of   an   error         similar number of keys.
       diagnostic  routine      that     may  receive     busy waiting           The repeated execution of a
       control at any time during the execu-                     loop of code while waiting for an event
       tion of a computer program.                               to occur.
base address     An address that is used as the           cache memory           A memory that is smaller
       origin in the calculation of addresses in                 and faster than main memory and that
       the execution of a computer program.                      is  interposed      between  the   processor
batch  processing      Pertaining        to  the   tech-         and main memory. The cache acts as a
       nique of executing a set of computer                      buffer for recently used memory loca-
       programs such that each is completed                      tions.
       before the next program of the set is              central    processing      unit  (CPU)    That     por-
       started.                                                  tion     of  a  computer    that   fetches  and
Beowulf      Defines a class of clustered com-                   executes instructions. It consists of an
       puting    that  focuses  on       minimizing              Arithmetic and Logic Unit (ALU), a
       the price-to-performance ratio of the                     control unit, and registers. Often sim-
       overall system without compromising                       ply referred to as a processor.
       its ability to perform the computation             chained list        A list in which data items may
       work for which it is being built. Most                    be dispersed but in which each item
       Beowulf systems are implemented on                        contains an identifier for locating the
       Linux computers.                                          next item.
                                                                                                             713

client      A process that requests services by        deadlock  (1) An impasse that occurs when
        sending messages to server processes.          multiple processes are waiting for the
cluster      A group of interconnected, whole          availability of a resource that will not
        computers     working        together  as   a  become          available     because        it  is   being
        unified      computing       resource   that   held by another process that is in a simi-
        can   create  the  illusion  of  being  one    lar wait state. (2) An impasse that occurs
        machine.     The   term  whole   computer      when multiple processes are waiting for
        means a system that can run on its own,        an action by or a response from another
        apart from the cluster.                        process that is in a similar wait state.
communications architecture          The hardware      deadlock avoidance         A dynamic technique
        and software structure that implements         that      examines         each      new         resource
        the communications function.                   request         for  deadlock.           If      the   new
compaction       A technique used when mem-            request could lead to a deadlock, then
        ory is divided into variable-size parti-       the request is denied.
        tions. From time to time, the operating        deadlock detection         A technique in which
        system shifts the partitions so that they      requested resources are always granted
        are contiguous and so that all of the free     when available. Periodically, the oper-
        memory is together in one block. See           ating system tests for deadlock.
        external fragmentation.                        deadlock  prevention          A    technique           that
concurrent       Pertaining      to  processes     or  guarantees           that  a  deadlock           will  not
        threads that take place within a com-          occur. Prevention is achieved by assur-
        mon interval of time during which they         ing that one of the necessary condi-
        may have to alternately share common           tions for deadlock is not met.
        resources.                                     demand paging       The transfer of a page from
consumable resource        A resource that can be      secondary       memory           to  main        memory
        created (produced) and destroyed (con-         storage at the moment of need. Com-
        sumed). When a resource is acquired by         pare prepaging.
        a process, the resource ceases to exist.       device driver   An       operating   system           mod-
        Examples of consumable resources are           ule (usually in the kernel) that deals
        interrupts, signals, messages, and infor-      directly with a device or I/O module.
        mation in I/O buffers.                         direct access   The capability to obtain data
critical    section   In   an  asynchronous     pro-   from a storage device or to enter data
        cedure of a computer program, a part           into      a     storage    device    in  a       sequence
        that  cannot  be     executed    simultane-    independent of their relative position,
        ously with an associated critical section      by means of addresses that indicate the
        of   another  asynchronous       procedure.    physical location of the data.
        See mutual exclusion.                          direct memory access (DMA)                   A form of
                                                       I/O in which a special module, called a
database      A collection of interrelated data,       DMA module, controls the exchange
        often with controlled redundancy, orga-        of        data  between       main   memory            and
        nized according to a schema to serve           an I/O device. The processor sends a
        one or more applications; the data are         request for the transfer of a block of
        stored so that they can be used by dif-        data to the DMA module and is inter-
        ferent programs without concern for the        rupted only after the entire block has
        data structure or organization. A com-         been transferred.
        mon approach is used to add new data           disabled interrupt   A condition, usually cre-
        and to modify and retrieve existing data.      ated by the operating system, during

       which the processor will ignore inter-           file  allocation   table     (FAT)     A  table     that
       rupt request signals of a specified class.              indicates the physical location on sec-
disk allocation table       A table that indicates             ondary storage of the space allocated
       which blocks on secondary storage are                   to a file. There is one file allocation
       free and available for allocation to files.             table for each file.
disk cache   A buffer, usually kept in main             file management system            A set of system
       memory, that functions as a cache of                    software that provides services to users
       disk blocks between disk memory and                     and     applications   in  the   use  of  files,
       the rest of main memory.                                including file access, directory mainte-
dispatch     To   allocate  time    on    a  proces-           nance, and access control.
       sor to jobs or tasks that are ready for          file  organization       The  physical       order   of
       execution.                                              records in a file, as determined by the
distributed  operating      system     A     common            access method used to store and retrieve
       operating   system   shared      by   a    net-         them.
       work  of    computers.     The   distributed     first come first served (FCFS)       Same as FIFO.
       operating system provides support for            first in first out (FIFO)         A queueing tech-
       interprocess    communication,        process           nique   in  which     the  next    item   to  be
       migration,  mutual   exclusion,       and   the         retrieved is the item that has been in
       prevention or detection of deadlock.                    the queue for the longest time.
dynamic relocation      A process that assigns          frame      In  paged     virtual  storage,   a   fixed-
       new absolute addresses to a computer                    length block of main memory that is
       program during execution so that the                    used to hold one page of virtual memory.
       program may be executed from a dif-
       ferent area of main storage.                     gang scheduling         The scheduling of a set of
                                                               related threads to run on a set of proces-
enabled interrupt      A condition, usually cre-               sors at the same time, on a one-to-one
       ated  by   the  operating  system,    during            basis.
       which the processor will respond to inter-
       rupt request signals of a specified class.       hash   file    A   file  in   which     records      are
encryption   The conversion of plain text or                   accessed according to the values of a
       data into unintelligible form by means of               key field. Hashing is used to locate a
       a reversible mathematical computation.                  record on the basis of its key value.
execution context      Same as process state.           hashing      The selection of a storage location
external fragmentation      Occurs when mem-                   for an item of data by calculating the
       ory is divided into variable-size parti-                address as a function of the contents
       tions corresponding to the blocks of                    of the data. This technique complicates
       data assigned to the memory (e.g., seg-                 the     storage   allocation    function      but
       ments in main memory). As segments                      results in rapid random retrieval.
       are moved into and out of the memory,            hit ratio    In a two-level memory, the fraction
       gaps will occur between the occupied                    of all memory accesses that are found
       portions of memory.                                     in the faster memory (e.g., the cache).
field  (1) Defined logical data that are part           indexed access      Pertaining to the organiza-
       of a record. (2) The elementary unit of                 tion and accessing of the records of a
       a record that may contain a data item, a                storage    structure   through     a  separate
       data aggregate, a pointer, or a link.                   index   to  the   locations   of   the   stored
file   A set of related records treated as a unit.             records.

indexed file  A       file  in    which  records      are   express          statements      in  a    job  that    are
     accessed according to the value of key                 used to identify the job or to describe
     fields. An index is required that indi-                its requirements to an operating system.
     cates the location of each record on the
     basis of each key value.                               kernel    A portion of the operating system
indexed    sequential       access      Pertaining    to    that includes the most heavily used por-
     the organization and accessing of the                  tions of software. Generally, the kernel
     records of a storage structure through                 is        maintained     permanently           in  main
     an index of the keys that are stored in                memory.The kernel runs in a privileged
     arbitrarily partitioned sequential files.              mode and responds to calls from pro-
indexed    sequential       file   A    file  in     which  cesses and interrupts from devices.
     records are ordered according to the val-              kernel mode      A privileged mode of execution
     ues of a key field.The main file is supple-            reserved for the kernel of the operating
     mented with an index file that contains                system. Typically, kernel mode allows
     a partial list of key values; the index                access to regions of main memory that
     provides a lookup capability to quickly                are       unavailable       to   processes      execut-
     reach the vicinity of a desired record.                ing in a less-privileged mode, and also
instruction cycle      The        time  period    during    enables execution of certain machine
     which one instruction is fetched from                  instructions that are restricted to the
     memory     and     executed        when      a   com-  kernel mode. Also referred to as system
     puter is given an instruction in machine               mode or privileged mode.
     language.
internal fragmentation            Occurs when mem-          last in first out (LIFO)         A queueing tech-
     ory is divided into fixed-size partitions              nique        in  which      the     next  item     to  be
     (e.g.,   page    frames      in    main  memory,       retrieved        is    the  item     most      recently
     physical blocks on disk). If a block of                placed in the queue.
     data is assigned to one or more parti-                 lightweight process      A thread.
     tions, then there may be wasted space                  livelock  A condition in which two or more
     in the last partition. This will occur if              processes        continuously            change    their
     the last portion of data is smaller than               state        in  response       to   changes       in  the
     the last partition.                                    other        process(es)     without      doing        any
interrupt    A suspension of a process, such as             useful work. This is similar to deadlock
     the execution of a computer program,                   in that no progress is made, but it dif-
     caused   by    an      event   external      to  that  fers in that neither process is blocked
     process and performed in such a way                    or waiting for anything.
     that the process can be resumed.                       locality of reference    The tendency of a pro-
interrupt handler      A routine, generally part            cessor to access the same set of mem-
     of the operating system. When an inter-                ory locations repetitively over a short
     rupt    occurs,  control      is   transferred   to    period of time.
     the     corresponding        interrupt   handler,      logical address  A reference to a memory
     which takes some action in response to                 location         independent         of   the  current
     the condition that caused the interrupt.               assignment           of     data     to   memory.      A
                                                            translation must be made to a physical
job  A set of computational steps packaged                  address before the memory access can
     to run as a unit.                                      be achieved.
job  control  language      (JCL)        A    problem-      logical record   A record independent of its
     oriented language that is designed to                  physical environment; portions of one

      logical record may be located in differ-          execute         in   a  different   mode     (kernel
      ent physical records or several logical           or process). When the mode switches
      records or parts of logical records may           from process to kernel, the program
      be located in one physical record.                counter,         processor     status    word,    and
                                                        other       registers     are  saved.    When     the
macrokernel      A large operating system core          mode switches from kernel to process,
      that provides a wide range of services.           this information is restored.
mailbox   A data structure shared among a               monitor     A programming language construct
      number of processes that is used as a             that encapsulates variables, access pro-
      queue for messages. Messages are sent             cedures, and initialization code within
      to the mailbox and retrieved from the             an       abstract    data    type.  The    monitor's
      mailbox    rather  than    passing    directly    variable may only be accessed via its
      from sender to receiver.                          access procedures and only one process
main memory      Memory that is internal to the         may         be  actively   accessing     the  moni-
      computer system, is program address-              tor at any one time. The access proce-
      able, and can be loaded into registers            dures are critical sections. A monitor
      for subsequent execution or processing.           may have a queue of processes that are
malicious software       Any software designed          waiting to access it.
      to  cause  damage      to  or    use  up     the  monolithic kernel       A large kernel contain-
      resources of a target computer. Mali-             ing         virtually   the    complete      operat-
      cious software (malware) is frequently            ing         system,  including      scheduling,   file
      concealed     within  or   masquerades       as   system,         device    drivers,  and      memory
      legitimate software. In some cases, it            management. All the functional com-
      spreads itself to other computers via             ponents of the kernel have access to
      e-mail or infected disks. Types of mali-          all of its internal data structures and
      cious software include viruses, Trojan            routines. Typically, a monolithic kernel
      horses, worms, and hidden software for            is implemented as a single process, with
      launching denial-of-service attacks.              all elements sharing the same address
memory    cycle  time    The     time  it   takes  to   space.
      read one word from or write one word              multilevel  security       A    capability        that
      to memory. This is the inverse of the             enforces access control across multiple
      rate at which words can be read from              levels of classification of data.
      or written to memory.                             multiprocessing      A mode of operation that
memory    partitioning      The  subdividing       of   provides for parallel processing by two
      storage into independent sections.                or more processors of a multiprocessor.
message   A block of information that may               multiprocessor       A  computer     that    has  two
      be exchanged between processes as a               or more processors that have common
      means of communication.                           access to a main storage.
microkernel      A   small   privileged     operat-     multiprogramming        A      mode      of   opera-
      ing system core that provides process             tion that provides for the interleaved
      scheduling, memory management, and                execution of two or more computer
      communication services and relies on              programs by a single processor. The
      other processes to perform some of the            same as multitasking, using different
      functions traditionally associated with           terminology.
      the operating system kernel.                      multiprogramming        level   The    number     of
mode  switch     A   hardware    operation      that    processes that are partially or fully res-
      occurs   that  causes     the  processor     to   ident in main memory.

multitasking     A mode of operation that pro-           page frame       A fixed-size contiguous block
      vides for the concurrent performance                     of main memory used to hold a page.
      or interleaved execution of two or more            paging   The transfer of pages between main
      computer tasks. The same as multipro-                    memory and secondary memory.
      gramming, using different terminology.             physical address     The absolute location of a
mutex     Similar to a binary semaphore.A key                  unit of data in memory (e.g., word or
      difference between the two is that the                   byte in main memory, block on second-
      process that locks the mutex (sets the                   ary memory).
      value to zero) must be the one to unlock           pipe    A circular buffer allowing two pro-
      it (sets the value to 1). In contrast, it is             cesses     to  communicate  on   the   pro-
      possible for one process to lock a binary                ducer­consumer    model.    Thus,  it  is    a
      semaphore and for another to unlock it.                  first-in-first-out queue, written by one
mutual     exclusion      A   condition    in  which           process and read by another. In some
      there is a set of processes, only one of                 systems, the pipe is generalized to allow
      which is able to access a given resource                 any item in the queue to be selected for
      or   perform    a   given  function      at  any         consumption.
      time. See critical section.                        preemption       Reclaiming a resource from a
                                                               process before the process has finished
nonprivileged state        An execution context                using it.
      that does not allow sensitive hardware             prepaging     The retrieval of pages other than
      instructions to be executed, such as the                 the one demanded by a page fault. The
      halt instruction and I/O instructions.                   hope is that the additional pages will be
nonuniform memory access (NUMA) multi-                         needed in the near future, conserving
      processor    A shared-memory multipro-                   disk I/O. Compare demand paging.
      cessor in which the access time from a             priority inversion   A circumstance in which
      given processor to a word in memory var-                 the operating system forces a higher-
      ies with the location of the memory word.                priority task to wait for a lower-priority
                                                               task.
object    request   broker    An     entity    in  an    privileged instruction  An instruction that
      object-oriented system that acts as an                   can be executed only in a specific mode,
      intermediary for requests sent from a                    usually by a supervisory program.
      client to a server.                                privileged mode      Same as kernel mode.
operating    system       Software   that  controls      process    A  program   in  execution.   A   pro-
      the    execution    of  programs     and     that        cess is controlled and scheduled by the
      provides services such as resource allo-                 operating system. Same as task.
      cation,  scheduling,    input/output         con-  process control block   The manifestation of
      trol, and data management.                               a process in an operating system. It is a
                                                               data structure containing information
page    In virtual storage, a fixed-length block               about the characteristics and state of
      that has a virtual address and that is                   the process.
      transferred     as  a   unit   between       main  process descriptor     Same as process control
      memory and secondary memory.                             block.
page  fault    Occurs when the page contain-             process image        All of the ingredients of a
      ing a referenced word is not in main                     process, including program, data, stack,
      memory.      This      causes  an    interrupt           and process control block.
      and requires that the proper page be               process migration    The transfer of a sufficient
      brought into main memory.                                amount of the state of a process from

one machine to another for the process               real-time system   An operating system that
to execute on the target machine.                    must schedule and manage real-time
process spawning       The  creation   of  a  new    tasks.
process by another process.                          real-time task    A task that is executed in
process state   All of the information that          connection with some process or func-
the operating system needs to manage                 tion or set of events external to the
a process and that the processor needs               computer system and that must meet
to properly execute the process. The                 one or more deadlines to interact effec-
process state includes the contents of               tively and correctly with the external
the        various  processor  registers,     such   environment.
as the program counter and data reg-                 record     A group of data elements treated as
isters; it also includes information of              a unit.
use to the operating system, such as the             reentrant  procedure        A   routine  that  may
priority of the process and whether the              be entered before the completion of
process is waiting for the completion of             a prior execution of the same routine
a particular I/O event. Same as execu-               and execute correctly.
tion context.                                        registers  High-speed memory internal to the
process switch   An operation that switches          CPU. Some registers are user visible--
the        processor   from    one    process  to    that        is,  available  to  the  programmer
another, by saving all the process con-              via the machine instruction set. Other
trol block, registers, and other informa-            registers are used only by the CPU, for
tion for the first and replacing them with           control purposes.
the process information for the second.              relative address   An address calculated as a
processor  In a computer, a functional unit          displacement from a base address.
that       interprets  and    executes     instruc-  remote procedure call (RPC)          A technique
tions. A processor consists of at least an           by         which  two  programs      on  different
instruction control unit and an arith-               machines interact using procedure call/
metic unit.                                          return syntax and semantics. Both the
program counter       Instruction address reg-       called and calling program behave as if
ister.                                               the partner program were running on
program status word (PSW)      A register or         the same machine.
set of registers that contains condition             rendezvous       In message passing, a condition
codes, execution mode, and other sta-                in which both the sender and receiver
tus information that reflects the state              of a message are blocked until the mes-
of a process.                                        sage is delivered.
programmed I/O        A form of I/O in which         resident set     That portion of a process that
the CPU issues an I/O command to an                  is actually in main memory at a given
I/O module and must then wait for the                time. Compare working set.
operation to be complete before pro-                 response time     In a data system, the elapsed
ceeding.                                             time between the end of transmission
                                                     of an enquiry message and the begin-
race condition     Situation in which multiple       ning of the receipt of a response mes-
processes access and manipulate shared               sage, measured at the enquiry terminal.
data with the outcome dependent on                   reusable resource      A resource that can be
the relative timing of the processes.                safely used by only one process at a
real address    A   physical  address   in    main   time and is not depleted by that use.
memory.                                              Processes         obtain       reusable  resource

     units that they later release for reuse                     medium in the same sequence as the
     by other processes. Examples of reus-                       data are ordered, or to obtain data in
     able resources include processors, I/O                      the same order as they were entered.
     channels, main and secondary memory,                 sequential file      A file in which records are
     devices,     and  data     structures    such    as         ordered according to the values of one
     files, databases, and semaphores.                           or more key fields and processed in the
round    robin    A    scheduling       algorithm     in         same sequence from the beginning of
     which processes are activated in a fixed                    the file.
     cyclic order; that is, all processes are in          server    (1)     A  process    that   responds   to
     a circular queue. A process that can-                       request from clients via messages. (2)
     not proceed because it is waiting for                       In a network, a data station that pro-
     some event (e.g., termination of a child                    vides   facilities  to   other  stations;  for
     process or an input/output operation)                       example, a file server, a print server, a
     returns control to the scheduler.                           mail server.
                                                          session    A collection of one or more pro-
scheduling      To select jobs or tasks that are                 cesses that represents a single interac-
     to  be  dispatched.        In  some    operating            tive user application or operating sys-
     systems, other units of work, such as                       tem function. All keyboard and mouse
     input/output operations, may also be                        input is directed to the foreground ses-
     scheduled.                                                  sion, and all output from the foreground
secondary memory            Memory located out-                  session is directed to the display screen.
     side the computer system itself; that is,            shell   The portion of the operating system that
     it cannot be processed directly by the                      interprets    interactive  user   commands
     processor. It must first be copied into                     and job control language commands. It
     main memory. Examples include disk                          functions as an interface between the
     and tape.                                                   user and the operating system.
segment     In virtual memory, a block that has           spin lock      Mutual exclusion mechanism in
     a virtual address. The blocks of a pro-                     which a process executes in an infinite
     gram may be of unequal length and may                       loop waiting for the value of a lock
     even be of dynamically varying lengths.                     variable to indicate availability.
segmentation      The division of a program or            spooling      The    use   of   secondary  memory
     application into segments as part of a                      as buffer storage to reduce processing
     virtual memory scheme.                                      delays when transferring data between
semaphore       An integer value used for sig-                   peripheral equipment and the proces-
     naling     among       processes.   Only     three          sors of a computer.
     operations      may    be      performed     on  a   stack    An ordered list in which items are
     semaphore,        all  of  which    are  atomic:            appended      to    and  deleted    from   the
     initialize,  decrement,        and   increment.             same end of the list, known as the top.
     Depending on the exact definition of                        That is, the next item appended to the
     the semaphore, the decrement opera-                         list is put on the top, and the next item
     tion may result in the blocking of a pro-                   to be removed from the list is the item
     cess, and the increment operation may                       that has been in the list the shortest
     result in the unblocking of a process.                      time. This method is characterized as
     Also known as a counting semaphore                          last in first out.
     or a general semaphore.                              starvation     A condition in which a process
sequential   access    The      capability    to  enter          is indefinitely delayed because other
     data into a storage device or a data                        processes are always given preference.

strong semaphore         A semaphore in which              time sharing      The concurrent use of a device
      all   processes     waiting    on      the  same            by a number of users.
      semaphore are queued and will even-                  time slice     The maximum amount of time
      tually    proceed   in  the    same    order    as          that a process can execute before being
      they executed the wait (P) operations                       interrupted.
      (FIFO order).                                        time slicing      A mode of operation in which
swapping        A process that interchanges the                   two    or  more    processes     are     assigned
      contents of an area of main storage                         quanta of time on the same processor.
      with the contents of an area in second-              trace    A sequence of instructions that are
      ary memory.                                                 executed when a process is running.
symmetric multiprocessing (SMP)              A form        translation       lookaside     buffer      (TLB)     A
      of    multiprocessing       that   allows       the         high-speed cache used to hold recently
      operating      system   to   execute   on   any             referenced page table entries as part of a
      available processor or on several avail-                    paged virtual memory scheme.The TLB
      able processors simultaneously.                             reduces the frequency of access to main
synchronous operation         An operation that                   memory to retrieve page table entries.
      occurs     regularly    or  predictably     with     trap   An unprogrammed conditional jump to
      respect to the occurrence of a specified                    a specified address that is automatically
      event in another process, for example,                      activated by hardware; the location from
      the calling of an input/output routine                      which the jump was made is recorded.
      that    receives   control     at  a   precoded      trap     door     Secret    undocumented            entry
      location in a computer program.                             point   into    a  program,    used      to  grant
synchronization      Situation in which two or                    access     without    normal     methods       of
      more processes coordinate their activi-                     access authentication.
      ties based on a condition.                           trojan horse      Secret undocumented routine
system     bus    A  bus    used   to    interconnect             embedded        within   a   useful   program.
      major      computer     components          (CPU,           Execution      of  the   program      results  in
      memory, I/O).                                               execution of the secret routine.
system mode       Same as kernel mode.                     trusted system        A computer and operating
                                                                  system that can be verified to imple-
task    Same as process.                                          ment a given security policy.
thrashing       A phenomenon in virtual mem-
      ory    schemes,   in    which     the  processor     user   mode       The     least-privileged   mode     of
      spends most of its time swapping pieces                     execution.      Certain     regions   of     main
      rather than executing instructions.                         memory and certain machine instruc-
thread     A    dispatchable      unit   of  work.    It          tions cannot be used in this mode.
      includes    a  processor     context        (which
      includes    the     program        counter  and      virtual  address       The   address    of   a  storage
      stack pointer) and its own data area for                    location in virtual memory.
      a stack (to enable subroutine branch-                virtual memory         The storage space that may
      ing).   A   thread    executes     sequentially             be regarded as addressable main stor-
      and is interruptible so that the proces-                    age by the user of a computer system
      sor    can  turn    to  another        thread.  A           in which virtual addresses are mapped
      process may consist of multiple threads.                    into real addresses. The size of virtual
thread switch        The act of switching proces-                 storage    is  limited   by  the     addressing
      sor control from one thread to another                      scheme of the computer system and
      within the same process.                                    by the amount of secondary memory

       available and not by the actual number             may be stored, transmitted, or operated
       of main storage locations.                         on within a given computer. Typically, if
virus  Secret     undocumented           routine          a processor has a fixed-length instruc-
       embedded   within    a  useful    program.         tion   set,  then  the  instruction  length
       Execution  of   the  program    results  in        equals the word length.
       execution of the secret routine.             working set        The working set with param-
                                                          eter  for a process at virtual time t,
weak semaphore         A  semaphore      in  which        W(t, ) is the set of pages of that pro-
       all  processes   waiting    on  the   same         cess that have been referenced in the
       semaphore proceed in an unspecified                last  time units. Compare resident set.
       order (i.e., the order is unknown or         worm  Program that can travel from com-
       indeterminate).                                    puter  to    computer    across  network
word   An ordered set of bytes or bits that               connections. May contain a virus or
       is the normal unit in which information            bacteria.

In matters of this kind everyone feels he is justified in writing and publishing
the first thing that comes into his head when he picks up a pen, and thinks his
own idea as axiomatic as the fact that two and two make four. If critics would
go to the trouble of thinking about the subject for years on end and testing
each conclusion against the actual history of war, as I have done, they would
undoubtedly be more careful of what they wrote.
                                                        --ON WAR, Carl von Clausewitz
                                ABBREVIATIONS
ACM      Association for Computing Machinery
IEEE     Institute of Electrical and Electronics Engineers
ABRA06   Abramson,T."Detecting Potential Deadlocks." Dr. Dobb's Journal, January 2006.
AGAR89   Agarwal,   A.     Analysis  of  Cache  Performance  for    Operating     Systems   and
         Multiprogramming. Boston: Kluwer Academic Publishers, 1989.
ANAN92   Ananda, A., Tay, B., and Koh, E. "A Survey of Asynchronous Remote Proce-
         dure Calls." Operating Systems Review, April 1992.
ANDE80   Anderson,     J.  Computer  Security   Threat  Monitoring  and  Surveillance.      Fort
         Washington, PA: James P. Anderson Co., April 1980.
ANDE89   Anderson, T., Laxowska, E., and Levy, H. "The Performance Implications of
         Thread    Management        Alternatives  for  Shared-Memory      Multiprocessors."
         IEEE Transactions on Computers, December 1989.
ANDE04   Anderson, T., Bershad, B., Lazowska, E., and Levy, H. "Thread Management
         for Shared-Memory Multiprocessors." In [TUCK04].
ANDR83   Andrews,   G.,    and  Schneider,  F.  "Concepts  and  Notations    for  Concurrent
         Programming." Computing Surveys, March 1983.
ANDR90   Andrianoff, S. "A Module on Distributed Systems for the Operating System
         Course." Proceedings, Twenty-First SIGCSE Technical Symposium on Computer
         Science Education, SIGSCE Bulletin, February 1990.
ANDR04   Andrews,   M.,    and  Whittaker,  J.  "Computer   Security."  IEEE      Security  and
         Privacy, September/October 2004.
ANTE06   Ante, S., and Grow, B. "Meet the Hackers." Business Week, May 29, 2006.
APPL09   Apple.  Inc.   "Grand  Central     Dispatch:   A  Better  Way   to  Do   Multicore."
         Technology Brief, August 2009.
ARDE80   Arden, B., editor. What Can Be Automated? Cambridge, MA: MIT Press, 1980.
ARTS89a  Artsy, Y., ed. Special Issue on Process Migration. Newsletter of the IEEE
         Computer Society Technical Committee on Operating Systems, Winter 1989.
ARTS89b  Artsy, Y. "Designing a Process Migration Facility: The Charlotte Experience."
         Computer, September 1989.
ATLA89   Atlas, A., and Blundon, B. "Time to Reach for It All." UNIX Review, January
         1989.
                                                                                            723

AXFO88  Axford, T. Concurrent Programming: Fundamental Techniques for Real-Time
        and Parallel Software Design. New York: Wiley, 1988.
AYCO06  Aycock, J. Computer Viruses and Malware. New York: Springer, 2006.
BACH86  Bach, M. The Design of the UNIX Operating System. Englewood Cliffs, NJ:
        Prentice Hall, 1986.
BACO03  Bacon, J., and Harris, T. Operating Systems: Concurrent and Distributed Soft-
        ware Design. Reading, MA: Addison-Wesley, 2003.
BAER80  Baer, J. Computer Systems Architecture. Rockville, MD: Computer Science
        Press, 1980.
BARB90  Barbosa, V. "Strategies for the Prevention of Communication Deadlocks in
        Distributed Parallel Programs." IEEE Transactions on Software Engineering,
        November 1990.
BARK89  Barkley, R., and Lee, T. "A Lazy Buddy System Bounded by Two Coalescing
        Delays per Class." Proceedings of the Twelfth ACM Symposium on Operating
        Systems Principles, December 1989.
BAYS77  Bays, C. "A Comparison of Next-Fit, First-Fit, and Best-Fit." Communications
        of the ACM, March 1977.
BECK97  Beck, L. System Software. Reading, MA: Addison-Wesley, 1997.
BELA66  Belady, L. "A Study of Replacement Algorithms for a Virtual Storage Com-
        puter." IBM Systems Journal, No. 2, 1966.
BELL94  Bellovin, S., and Cheswick, W. "Network Firewalls." IEEE Communications
        Magazine, September 1994.
BEN82   Ben-Ari, M. Principles of Concurrent Programming. Englewood Cliffs, NJ:
        Prentice Hall, 1982.
BEN06   Ben-Ari, M. Principles of Concurrent and Distributed Programming. Harlow,
        England: Addison-Wesley, 2006.
BERS96  Berson, A. Client/Server Architecture. New York: McGraw-Hill, 1996.
BIEB05  Bieberstein, N., et al. "Impact of Service-Oriented Architecture on Enterprise
        Systems, Organizational Structures, and Individuals." IBM Systems Journal,
        Vol. 44, No. 4, 2005.
BIH06   Bih, J. "Service Oriented Architecture (SOA): A New Paradigm to Imple-
        ment Dynamic E-Business Solutions." ACM Ubiquity, August 2006. acm.org/
        ubiquity/views/v7i30_soa.html
BIRR89  Birrell, A. An Introduction to Programming with Threads. SRC Research
        Report 35, Compaq Systems Research Center, Palo Alto, CA, January 1989.
        http://www.research.compaq.com/SRC
BLAC90  Black, D. "Scheduling Support for Concurrency and Parallelism in the Mach
        Operating System." Computer, May 1990.
BOLO89  Bolosky, W., Fitzgerald, R., and Scott, M. "Simple but Effective Techniques for
        NUMA Memory Management." Proceedings, Twelfth ACM Symposium on
        Operating Systems Principles, December 1989.
BONW94  Bonwick, J. "An Object-Caching Memory Allocator." Proceedings, USENIX
        Summer Technical Conference, 1994.
BORG90  Borg, A., Kessler, R., and Wall, D. "Generation and Analysis of Very Long
        Address Traces." Proceedings of the 17th Annual International Symposium on
        Computer Architecture, May 1990.

BOVE06   Bovet, D., and Cesati, M. Understanding the Linux Kernel. Sebastopol, CA:
         O'Reilly, 2006.
BREN89   Brent, R. "Efficient Implementation of the First-Fit Strategy for Dynamic
         Storage   Allocation."  ACM       Transactions  on  Programming  Languages        and
         Systems, July 1989.
BREW97   Brewer, E. "Clustering: Multiply and Conquer." Data Communications, July
         1997.
BRIA99   Briand, L., and Roy, D. Meeting Deadlines in Hard Real-Time Systems: The
         Rate Monotonic Approach. Los Alamitos, CA: IEEE Computer Society Press,
         1999.
BRIN01   Brinch   Hansen,  P.  Classic     Operating  Systems:    From  Batch  Processing  to
         Distributed Systems. New York: Springer-Verlag, 2001.
BRIT04   Britton, C. IT Architectures and Middleware. Reading, MA: Addison-Wesley,
         2004.
BROW03   Brown, A., Johnston, S., and Kelly, K. Using Service-Oriented Architecture
         and Component-Based Development to Build Web Service Applications. IBM
         Rational Software Technical Report, 2003. ibm.com/developerworks/rational/
         library/510.html
BROW72   Browne, P. "Computer Security--A Survey." ACM SIGMIS Database, Fall
         1972.
BUHR95   Buhr, P., and Fortier, M. "Monitor Classification." ACM Computing Surveys,
         March 1995.
BULM79   Bulmer, M. Principles of Statistics. New York: Dover, 1979.
BUON01   Buonadonna, P.; Hill, J.; and Culler, D. "Active Message Communication for
         Tiny Networked Sensors." Proceedings, IEEE INFOCOM 2001, April 2001.
BURR04   Burr,  W.,  Dodson,     D.,  and  Polk,  W.  Electronic  Authentication   Guideline.
         Gaithersburg, MD: National Institute of Standards and Technology, Special
         Publication 800-63, September 2004.
BUTT99   Buttazzo, G. "Optimal Deadline Assignment for Scheduling Soft Aperiodic
         Tasks in Hard Real-Time Environments." IEEE Transactions on Computers,
         October 1999.
BUYY99a  Buyya, R. High Performance Cluster Computing: Architectures and Systems.
         Upper Saddle River, NJ: Prentice Hall, 1999.
BUYY99b  Buyya, R. High Performance Cluster Computing: Programming and Applica-
         tions. Upper Saddle River, NJ: Prentice Hall, 1999.
CABR86   Cabrear,    L.  "The  Influence   of  Workload  on     Load    Balancing  Strategies."
         USENIX Conference Proceedings, Summer 1986.
CAO96    Cao, P., Felten, E., Karlin, A., and Li, K. "Implementation and Performance of
         Integrated Application-Controlled File Caching, Prefetching, and Disk Sched-
         uling." ACM Transactions on Computer Systems, November 1996.
CARE08   Carey, M. "SOA What?" IEEE Computer, March 2008.
CARR81   Carr, R., and Hennessey, J. "WSClock--A Simple and Efficient Algorithm
         for Virtual Memory Management." Proceedings of the Eighth Symposium on
         Operating System Principles, December 1981.
CARR84   Carr, R. Virtual Memory Management. Ann Arbor, MI: UMI Research Press,
         1984.

CARR89  Carriero, N., and Gelernter, D. "How to Write Parallel Programs: A Guide for
        the Perplexed." ACM Computing Surveys, September 1989.
CARR01  Carr, S., Mayo, J., and Shene, C. "Race Conditions: A Case Study." The Journal
        of Computing in Small Colleges, October 2001.
CARR05  Carrier, B. File System Forensic Analysis. Upper Saddle River, NJ: Addison-
        Wesley, 2005.
CASA94  Casavant, T., and Singhal, M. Distributed Computing Systems. Los Alamitos,
        CA: IEEE Computer Society Press, 1994.
CASS01  Cass, S. "Anatomy of Malice." IEEE Spectrum, November 2001.
CHAN85  Chandy, K., and Lamport, L. "Distributed Snapshots: Determining Global
        States   of  Distributed   Systems."     ACM    Transactions  on  Computer   Systems,
        February 1985.
CHAN90  Chandras, R. "Distributed Message Passing Operating Systems." Operating
        Systems Review, January 1990.
CHAP97  Chapin,      S.,  and  Maccabe,  A.,     eds.  "Multiprocessor    Operating  Systems:
        Harnessing        the  Power."  Special  issue  of  IEEE  Concurrency,  April­June
        1997.
CHEN92  Chen, J.; Borg, A.; and Jouppi, N. "A Simulation Based Study of TLB Perfor-
        mance." Proceedings of the 19th Annual International Symposium on Computer
        Architecture, May 1992.
CHEN94  Chen, P., Lee, E., Gibson, G., Katz, R., and Patterson, D. "RAID: High-Perfor-
        mance, Reliable Secondary Storage." ACM Computing Surveys, June 1994.
CHEN96  Chen, S., and Towsley, D. "A Performance Evaluation of RAID Architectures."
        IEEE Transactions on Computers, October 1996.
CHEN04  Chen, S., and Tang, T. "Slowing Down Internet Worms." Proceedings of the 24th
        International Conference on Distributed Computing Systems, 2004.
CHU72   Chu, W., and Opderbeck, H. "The Page Fault Frequency Replacement Algo-
        rithm." Proceedings, Fall Joint Computer Conference, 1972.
CLAR85  Clark, D., and Emer, J. "Performance of the VAX-11/780 Translation Buffer:
        Simulation        and  Measurement."     ACM    Transactions  on  Computer   Systems,
        February 1985.
CLAR98  Clarke, D., and Merusi, D. System Software Programming: The Way Things
        Work. Upper Saddle River, NJ: Prentice Hall, 1998.
CHER05  Cherbacko, L., et al. "Impact of Service Orientation at the Business Level."
        IBM Systems Journal, Vol. 44, No. 4, 2005.
CHES97  Chess, D. "The Future of Viruses on the Internet." Proceedings, Virus Bulletin
        International Conference, October 1997.
CHIN05  Chinchani, R., and Berg, E."A Fast Static Analysis Approach to Detect Exploit
        Code Inside Network Flows." Recent Advances in Intrusion Detection, 8th
        International Symposium, 2005.
COFF71  Coffman, E., Elphick, M., and Shoshani, A. "System Deadlocks." Computing
        Surveys, June 1971.
COHE94  Cohen, F. A Short Course on Computer Viruses. New York: Wiley, 1994.
COME79  Comer, D. "The Ubiquitous B-Tree." Computing Surveys, June 1979.
CONR02  Conry-Murray,          A.  "Behavior-Blocking   Stops  Unknown    Malicious  Code."
        Network Magazine, June 2002.

CONW63   Conway, M."Design of a Separable Transition-Diagram Compiler." Communi-
         cations of the ACM, July 1963.
CONW67   Conway, R., Maxwell, W., and Miller, L. Theory of Scheduling. Reading, MA:
         Addison-Wesley, 1967. Reprinted by Dover Publications, 2003.
CORB62   Corbato, F., Merwin-Daggett, M.; and Dealey, R. "An Experimental Time-
         Sharing System." Proceedings of the 1962 Spring Joint Computer Conference,
         1962. Reprinted in [BRIN01].
CORB68   Corbato, F. "A Paging Experiment with the Multics System." MIT Project
         MAC Report MAC-M-384, May 1968.
CORB96   Corbett, J. "Evaluating Deadlock Detection Methods for Concurrent Soft-
         ware." IEEE Transactions on Software Engineering, March 1996.
CORM09   Cormen,T., et al. Introduction to Algorithms. Cambridge, MA: MIT Press, 2009.
COST05   Costa, M., et al. "Vigilante: End-to-End Containment of Internet Worms."
         ACM Symposium on Operating Systems Principles, 2005.
COX89    Cox, A., and Fowler, R. "The Implementation of a Coherent Memory Abstrac-
         tion on a NUMA Multiprocessor: Experiences with PLATINUM." Proceed-
         ings, Twelfth ACM Symposium on Operating Systems Principles, December
         1989.
CUST94   Custer, H. Inside the Windows NT File System. Redmond, WA: Microsoft Press,
         1994.
DALE68   Daley,R.,and Dennis,R."Virtual Memory,Processes,and Sharing in MULTICS."
         Communications of the ACM, May 1968.
DALT96   Dalton, W., et al. Windows NT Server 4: Security, Troubleshooting, and Optimi-
         zation. Indianapolis, IN: New Riders Publishing, 1996.
DASG92   Dasgupta,    P.,  et   al.  "The  Clouds  Distributed  Operating  System."  IEEE
         Computer, November 1992.
DATT90   Datta,  A.,  and      Ghosh,  S.  "Deadlock  Detection  in   Distributed  Systems."
         Proceedings, Phoenix Conference on Computers and Communications, March
         1990.
DATT92   Datta, A.; Javagal, R.; and Ghosh, S. "An Algorithm for Resource Deadlock
         Detection in Distributed Systems." Computer Systems Science and Engineer-
         ing, October 1992.
DELL00   Dekker, E., and Newcomer, J. Developing Windows NT Device Drivers: A
         Programmer's Handbook. Reading, MA: Addison-Wesley, 2000.
DENN05   Denning, P. "The Locality Principle." Communications of the ACM, July 2005.
DENN68   Denning, P. "The Working Set Model for Program Behavior." Communications
         of the ACM, May 1968.
DENN70   Denning, P. "Virtual Memory." Computing Surveys, September 1970.
DENN71   Denning, P. "Third Generation Computer Systems." ACM Computing Surveys,
         December 1971.
DENN80a  Denning, P.; Buzen, J.; Dennis, J.; Gaines, R.; Hansen, P.; Lynch, W.; and
         Organick, E. "Operating Systems." In [ARDE80].
DENN80b  Denning, P. "Working Sets Past and Present." IEEE Transactions on Software
         Engineering, January 1980.
DENN84   Denning,     P.,  and  Brown,     R.  "Operating  Systems."  Scientific   American,
         September 1984.

DENN87   Denning, D. "An Intrusion-Detection Model." IEEE Transactions on Software
         Engineering, February 1987.
DIJK65   Dijkstra,  E.  Cooperating    Sequential  Processes.   Technological  University,
         Eindhoven, The Netherlands, 1965. (Reprinted in Great Papers in Computer
         Science, P. Laplante, ed., IEEE Press, New York, NY, 1996.) Also reprinted in
         [BRIN01].
DIJK68   Dijkstra, E. "The Structure of `THE' Multiprogramming System." Communi-
         cations of the ACM, May 1968. Reprinted in [BRIN01].
DIJK71   Dijkstra, E. "Hierarchical Ordering of sequential Processes." Acta informatica,
         Vol. 1, No. 2, 1971. Reprinted in [BRIN01].
DIMI98   Dimitoglou, G. "Deadlocks and Methods for Their Detection, Prevention, and
         Recovery in Modern Operating Systems." Operating Systems Review, July 1998.
DONA01   Donahoo, M., and Clavert, K. The Pocket Guide to TCP/IP Sockets. San Fran-
         cisco, CA: Morgan Kaufmann, 2001.
DOUG89   Douglas, F., and Ousterhout, J. "Process Migration in Sprite: A Status Report."
         Newsletter of the IEEE Computer Society Technical Committee on Operating
         Systems, Winter 1989.
DOUG91   Douglas, F., and Ousterhout, J. "Transparent Process Migration: Design Alter-
         natives and the Sprite Implementation." Software Practice and Experience,
         August 1991.
DOWD93   Dowdy, L., and Lowery, C. P.S. to Operating Systems. Upper Saddle River, NJ:
         Prentice Hall, 1993.
DOWN08   Downey,    A.  The    Little  Book  of    Semaphores.     www.greenteapress.com/
         semaphores/
DUBE98   Dube, R. A Comparison of the Memory Management Sub-Systems in FreeBSD
         and Linux. Technical Report CS-TR-3929, University of Maryland, September
         25, 1998.
EAGE86   Eager, D.; Lazowska, E.; and Zahnorjan, J. "Adaptive Load Sharing in Homo-
         geneous Distributed Systems." IEEE Transactions on Software Engineering,
         May 1986.
ECKE95   Eckerson,  W.  "Client  Server  Architecture."  Network   World  Collaboration,
         Winter 1995.
ECOS07   eCosCentric Limited, and Red Hat, Inc. eCos Reference Manual, 2007. http://
         www.ecoscentric.com/ecospro/doc/html/ref/ecos-ref.html
EISC07   Eischen, C. "RAID 6 Covers More Bases." Network World, April 9, 2007.
ENGE80   Enger, N., and Howerton, P. Computer Security. New York: Amacom, 1980.
ESKI90   Eskicioglu, M. "Design Issues of Process Migration Facilities in Distributed
         Systems." Newsletter of the IEEE Computer Society Technical Committee on
         Operating Systems and Application Environments, Summer 1990.
FEIT90a  Feitelson, D., and Rudolph, L. "Distributed Hierarchical Control for Parallel
         Processing." Computer, May 1990.
FEIT90b  Feitelson, D., and Rudolph, L. "Mapping and Scheduling in a Shared Parallel
         Environment Using Distributed Hierarchical Control." Proceedings, 1990 Inter-
         national Conference on Parallel Processing, August 1990.
FERR83   Ferrari, D., and Yih, Y. "VSWS: The Variable-Interval Sampled Working Set
         Policy." IEEE Transactions on Software Engineering, May 1983.

FIDG96  Fidge, C. "Fundamentals of Distributed System Observation." IEEE Software,
        November 1996.
FINK88  Finkel, R. An Operating Systems Vade Mecum. Englewood Cliffs, NJ: Prentice
        Hall, 1988.
FINK89  Finkel, R. "The Process Migration Mechanism of Charlotte." Newsletter of the
        IEEE Computer Society Technical Committee on Operating Systems, Winter
        1989.
FOLK98  Folk, M., and Zoellick, B. File Structures: An Object-Oriented Approach with
        C++. Reading, MA: Addison-Wesley, 1998.
FORR97  Forrest, S.; Hofmeyr, S.; and Somayaji,A."Computer Immunology." Communi-
        cations of the ACM, October 1997.
FOST91  Foster, L. "Automatic Generation of Self-Scheduling Programs." IEEE Trans-
        actions on Parallel and Distributed Systems, January 1991.
FRAN97  Franz, M. "Dynamic Linking of Software Components." Computer, March
        1997.
FRAS97  Fraser, B. Site Security Handbook. RFC 2196, September 1997.
FRIE96  Friedman, M. "RAID Keeps Going and Going and..." IEEE Spectrum, April
        1996.
GALL00  Galli, D. Distributed Operating Systems: Concepts and Practice. Upper Saddle
        River, NJ: Prentice Hall, 2000.
GANA98  Ganapathy, N., and Schimmel, C. "General Purpose Operating System Support
        for Multiple Page Sizes." Proceedings, USENIX Symposium, 1998.
GARG02  Garg, V. Elements of Distributed Computing. New York: Wiley, 2002.
GAUD00  Gaudin, S. "The Omega Files." Network World, June 26, 2000.
GAY03   Gay,   D.,  et  al.  "The  nesC  Language:  A  Holistic  Approach  to  Networked
        Embedded Systems." Proceedings of the ACM SIGPLAN 2003 Conference on
        Programming Language Design and Implementation, 2003.
GAY05   Gay, D.; Levis, P.; and Culler, D. "Software Design Patterns for TinyOS."
        Proceedings, Conference on Languages, Compilers, and Tools for Embedded
        Systems, 2005.
GEER06  Geer, D. "Hackers Get to the Root of the Problem." Computer, May 2006.
GEER09  Geer, D. "The OS Faces a Brave New World." Computer, October 2009.
GEHR87  Gehringer, E.; Siewiorek, D.; and Segall, Z. Parallel Processing: The Cm* Expe-
        rience. Bedford, MA: Digital Press, 1987.
GIBB87  Gibbons, P. "A Stub Generator for Multilanguage RPC in Heterogeneous
        Environments." IEEE Transactions on Software Engineering, January 1987.
GING90  Gingras,    A.  "Dining    Philosophers     Revisited."  ACM  SIGCSE   Bulletin,
        September 1990.
GOLD87  Goldberg, S. Probability: An Introduction. New York: Dover, 1987.
GOLD89  Goldman, P. "Mac VM Revealed." Byte, November 1989.
GOOD94  Goodheart, B., and Cox, J. The Magic Garden Explained: The Internals of
        UNIX System V Release 4. Englewood Cliffs, NJ: Prentice Hall, 1994.
GOPA85  Gopal, I."Prevention of Store-and-Forward Deadlock in Computer Networks."
        IEEE Transactions on Communications, December 1985.
GORM04  Gorman, M. Understanding the Linux Virtual Memory Manager. Upper Saddle
        River, NJ: Prentice Hall, 2004.

GOYE99   Goyeneche, J., and Souse, E. "Loadable Kernel Modules." IEEE Software,
         January/February 1999.
GRAH72   Graham, G., and Denning, P. "Protection--Principles and Practice." Proceed-
         ings, AFIPS Spring Joint Computer Conference, 1972.
GRAN04   Grance, T.; Kent, K.; and Kim, B. Computer Security Incident Handling Guide.
         NIST Special Publication SP 800-61, January 2004.
GRAY97   Gray, J. Interprocess Communications in UNIX: The Nooks and Crannies.
         Upper Saddle River, NJ: Prentice Hall, 1997.
GRIM01a  Grimmett, G., and Stirzaker, D. Probability and Random Processes. Oxford:
         Oxford University Press, 2001.
GRIM01b  Grimmett, G., and Stirzaker, D. One Thousand Exercises in Probability. Oxford:
         Oxford University Press, 2001.
GRIM05   Grimheden, M., and Torngren, M. "What is Embedded Systems and How
         Should It Be Taught?--Results from a Didactic Analysis." ACM Transactions
         on Embedded Computing Systems, August 2005.
GROS86   Grosshans, D. File Systems: Design and Implementation. Englewood Cliffs, NJ:
         Prentice Hall, 1986.
GROS09   Gross, D., and Harris, C. Fundamentals of Queueing Theory. New York: Wiley,
         2009.
GUNT00   Gunther, N. The Practical Performance Analyst. New York: Authors Choice
         Press, 2000.
GUPT78   Gupta, R., and Franklin, M. "Working Set and Page Fault Frequency Replace-
         ment    Algorithms:     A  Performance  Comparison."  IEEE        Transactions  on
         Computers, August 1978.
HALD91   Haldar, S., and Subramanian, D. "Fairness in Processor Scheduling in Time
         Sharing Systems." Operating Systems Review, January 1991.
HALL01   Hall, B. Beej's Guide to Network Programming Using Internet Sockets, 2001.
         http://beej.us/guide/bgnet
HALL10   Hall, B. Beej's Guide to Unix IPC, 2010. Document available in premium content
         section for this book.
HAMM91   Hamming, R. The Art of Probability: For Scientists and Engineers. Reading,
         MA: Addison-Wesley, 1991.
HARR06   Harris, W. "Multi-core in the Source Engine." bit-tech.net technical paper,
         November 2, 2006. bit-tech.net/gaming/2006/11/02/Multi_core_in_the_Source_
         Engin/1
HATF72   Hatfield, D. "Experiments on Page Size, Program Access Patterns, and Virtual
         Memory Performance." IBM Journal of Research and Development, January 1972.
HENN07   Hennessy,     J.,  and  Patterson,  D.  Computer   Architecture:  A  Quantitative
         Approach. San Mateo, CA: Morgan Kaufmann, 2007.
HENR84   Henry, G. "The Fair Share Scheduler." AT&T Bell Laboratories Technical Jour-
         nal, October 1984.
HERL90   Herlihy, M. "A Methodology for Implementing Highly Concurrent Data Struc-
         tures." Proceedings of the Second ACM SIGPLAN Symposium on Principles
         and Practices of Parallel Programming, March 1990.
HILL00   Hill, J., et al. "System Architecture Directions for Networked Sensors." Pro-
         ceedings, Architectural Support for Programming Languages and Operating
         Systems, 2000.

HOAR74   Hoare, C. "Monitors: An Operating System Structuring Concept." Communi-
         cations of the ACM, October 1974.
HOAR85   Hoare,  C.   Communicating       Sequential   Processes.   Englewood   Cliffs,    NJ:
         Prentice-Hall, 1985.
HOFR90   Hofri, M."Proof of a Mutual Exclusion Algorithm." Operating Systems Review,
         January 1990.
HOLL02   Holland, D.; Lim, A.; and Seltzer, M. "A New Instructional Operating System."
         Proceedings of SIGCSE 2002, 2002.
HOLT72   Holt,   R.  "Some  Deadlock      Properties  of  Computer   Systems."  Computing
         Surveys, September 1972.
HONE05   Honeynet Project. Knowing Your Enemy: Tracking Botnets. Honeynet White
         Paper, March 2005. http://honeynet.org/papers/bots
HONG89   Hong, J.; Tan, X.; and Towsley, D. "A Performance Analysis of Minimum Laxity
         and Earliest Deadline Scheduling in a Real-Time System." IEEE Transactions
         on Computers, December 1989.
HOWA73   Howard, J. "Mixed Solutions for the Deadlock Problem." Communications of
         the ACM, July 1973.
HP96     Hewlett Packard. White Paper on Clustering, June 1996.
HUCK83   Huck, T. Comparative Analysis of Computer Architectures. Stanford University
         Technical Report Number 83-243, May 1983.
HUCK93   Huck, J., and Hays, J."Architectural Support for Translation Table Management
         in Large Address Space Machines." Proceedings of the 20th Annual Interna-
         tional Symposium on Computer Architecture, May 1993.
HUTC08   Hutchinson, J., et al. "Migrating to SOAs by Way of Hybrid Systems." IT Pro,
         January/February 2008.
HWAN99   Hwang, K., et al. "Designing SSI Clusters with Hierarchical Checkpointing and
         Single I/O Space." IEEE Concurrency, January­March 1999.
HYMA66   Hyman, H. "Comments on a Problem in Concurrent Programming Control."
         Communications of the ACM, January 1966.
IBM86    IBM     National  Technical  Support,  Large     Systems.  Multiple  Virtual  Storage
         (MVS) Virtual Storage Tuning Cookbook. Dallas Systems Center Technical
         Bulletin G320-0597, June 1986.
INSO02a  Insolvibile, G. "Inside the Linux Packet Filter." Linux Journal, February,
         2002.
INSO02b  Insolvibile, G. "Inside the Linux Packet Filter, Part II." Linux Journal, March,
         2002.
ISLO80   Isloor, S., and Marsland, T. "The Deadlock Problem: An Overview." Computer,
         September 1980.
IYER01   Iyer, S., and Druschel, P. "Anticipatory Scheduling: A Disk Scheduling Frame-
         work to Overcome Deceptive Idleness in Synchronous I/O." Proceedings, 18th
         ACM Symposium on Operating Systems Principles, October 2001.
JACK10   Jackson, J. "Multicore Requires OS Rework, Windows Architect Advises."
         Network World, March 19, 2010.
JACO98a  Jacob,  B.,  and   Mudge,    T.  "Virtual  Memory:  Issues  of  Implementation."
         Computer, June 1998.
JACO98b  Jacob, B., and Mudge, T. "Virtual Memory in Contemporary Microprocessors."
         IEEE Micro, August 1998.

JAIN91   Jain, R. The Art of Computer Systems Performance Analysis: Techniques for
         Experimental Design, Measurement, Simulation, and Modeling. New York:
         Wiley, 1991.
JANS01   Jansen,   W.  Guidelines  on  Active  Content  and  Mobile  Code.  NIST  Special
         Publication SP 800-28, October 2001.
JHI07    Jhi, Y., et al. "Proactive Containment of Fast Scanning Worms through White
         Detection." Proceedings of 3rd International Conference on Security and Privacy
         in Communication Networks, September 2007.
JOHN91   Johnston, B.; Javagal, R.; Datta, A.; and Ghosh, S. "A Distributed Algorithm for
         Resource Deadlock Detection." Proceedings, Tenth Annual Phoenix Confer-
         ence on Computers and Communications, March 1991.
JOHN92   Johnson,T., and Davis,T."Space Efficient Parallel Buddy Memory Management."
         Proceedings,Third International Conference on Computers and Information, May
         1992.
JONE80   Jones, S., and Schwarz, P."Experience Using Multiprocessor Systems--A Status
         Report." Computing Surveys, June 1980.
JONE97   Jones, M. "What Really Happened on Mars?", 1997. http://research.microsoft.
         com/~mbj/Mars_Pathfinder/Mars_Pathfinder.html
JUL88    Jul, E.; Levy, H.; Hutchinson, N.; and Black, A. "Fine-Grained Mobility in the
         Emerald System." ACM Transactions on Computer Systems, February 1988.
JUL89    Jul, E. "Migration of Light-Weight Processes in Emerald." Newsletter of the
         IEEE Computer Society Technical Committee on Operating Systems, Winter
         1989.
JUNG04   Jung, J., et al. "Fast Portscan Detection Using Sequential Hypothesis Testing."
         Proceedings, IEEE Symposium on Security and Privacy, 2004.
KANG98   Kang, S., and Lee, J. "Analysis and Solution of Non-Preemptive Policies for
         Scheduling Readers and Writers." Operating Systems Review, July 1998.
KAPP00   Kapp, C. "Managing Cluster Computers." Dr. Dobb's Journal, July 2000.
KATZ89   Katz, R.; Gibson, G.; and Patterson, D. "Disk System Architecture for High
         Performance Computing." Proceedings of the IEEE, December 1989.
KAY88    Kay, J., and Lauder, P. "A Fair Share Scheduler." Communications of the ACM,
         January 1988.
KENT00   Kent, S."On the Trail of Intrusions into Information Systems." IEEE Spectrum,
         December 2000.
KEPH97a  Kephart, J.; Sorkin, G.; Chess, D.; and White, S. "Fighting Computer Viruses."
         Scientific American, November 1997.
KEPH97b  Kephart, J.; Sorkin, G.; Swimmer, B.; and White, S. "Blueprint for a Computer
         Immune System." Proceedings, Virus Bulletin International Conference, Octo-
         ber 1997.
KESS92   Kessler, R., and Hill, M. "Page Placement Algorithms for Large Real-Indexed
         Caches." ACM Transactions on Computer Systems, November 1992.
KHAL93   Khalidi, Y.; Talluri, M.; Williams, D.; and Nelson, M. "Virtual Memory Support
         for  Multiple  Page  Sizes."  Proceedings,  Fourth  Workshop  on   Workstation
         Operating Systems, October 1993.
KILB62   Kilburn, T.; Edwards, D.; Lanigan, M.; and Sumner, F. "One-Level Storage
         System." IRE Transactions, April 1962.

KLEI75  Kleinrock, L. Queueing Systems, Volume I: Theory. New York: Wiley, 1975.
KLEI76  Kleinrock, L. Queueing Systems, Volume II: Computer Applications. New York:
        Wiley, 1976.
KLEI95  Kleiman, S. "Interrupts as Threads." Operating System Review, April 1995.
KLEI96  Kleiman, S.; Shah, D.; and Smallders, B. Programming with Threads. Upper
        Saddle River, NJ: Prentice Hall, 1996.
KLEI04  Kleinrock, L. Queuing Systems, Volume Three: Computer Applications. New
        York: Wiley, 2004.
KNUT71  Knuth, D."An Experimental Study of FORTRAN Programs." Software Practice
        and Experience, Vol. 1, 1971.
KNUT97  Knuth,  D.    The   Art  of  Computer   Programming,    Volume    1:  Fundamental
        Algorithms. Reading, MA: Addison-Wesley, 1997.
KNUT98  Knuth, D. The Art of Computer Programming, Volume 3: Sorting and Search-
        ing. Reading, MA: Addison-Wesley, 1998.
KOOP96  Koopman,      P.  "Embedded    System   Design  Issues  (the  Rest  of  the  Story).
        Proceedings, 1996 International Conference on Computer Design, 1996.
KRIS94  Krishna, C., and Lee,Y., eds."Special Issue on Real-Time Systems." Proceedings
        of the IEEE, January 1994.
KUPE05  Kuperman, B., et al. "Detection and Prevention of Stack Buffer Overflow
        Attacks." Communications of the ACM, November 2005.
LAI06   Lai, A., and Nieh, J. "On the Performance of Wide-Area Thin-Client Comput-
        ing." ACM Transactions on Computer Systems, May 2006.
LAMP71  Lampson, B. "Protection." Proceedings, Fifth Princeton Symposium on Infor-
        mation Sciences and Systems, March 1971; Reprinted in Operating Systems
        Review, January 1974.
LAMP74  Lamport, L."A New Solution to Dijkstra's Concurrent Programming Problem."
        Communications of the ACM, August 1974.
LAMP78  Lamport, L. "Time, Clocks, and the Ordering of Events in a Distributed
        System." Communications of the ACM, July 1978.
LAMP80  Lampson, B., and Redell D. "Experience with Processes and Monitors in
        Mesa." Communications of the ACM, February 1980.
LAMP86  Lamport, L. "The Mutual Exclusion Problem." Journal of the ACM, April 1986.
LAMP91  Lamport, L. "The Mutual Exclusion Problem Has Been Solved." Communica-
        tions of the ACM, January 1991.
LAMP04  Lampson, B. "Computer Security in the Real World." Computer, June 2004.
LARM05  Larmour, J. "How eCos Can Be Shrunk to Fit." Embedded Systems Europe,
        May 2005. www.embedded.com/europe/esemay05.htm
LARO92  LaRowe, R.; Holliday, M.; and Ellis, C. "An Analysis of Dynamic Page Place-
        ment an a NUMA Multiprocessor." Proceedings, 1992 ACM SIGMETRICS
        and Performance '92, June 1992.
LEBL87  LeBlanc,  T.,     and  Mellor-Crummey,  J.  "Debugging  Parallel    Programs  with
        Instant Replay." IEEE Transactions on Computers, April 1987.
LEE93   Lee,Y., and Krishna, C., eds. Readings in Real-Time Systems. Los Alamitos, CA:
        IEEE Computer Society Press, 1993.
LELA86  Leland, W., and Ott, T. "Load-Balancing Heuristics and Process Behavior."
        Proceedings, ACM SigMetrics Performance 1986 Conference, 1986.

LEON07   Leonard, T. "Dragged Kicking and Screaming: Source Multicore." Proceedings,
         Game Developers Conference 2007, March 2007.
LERO76   Leroudier, J., and Potier, D. "Principles of Optimality for Multiprogramming."
         Proceedings, International Symposium on Computer Performance Modeling,
         Measurement, and Evaluation, March 1976.
LETW88   Letwin, G. Inside OS/2. Redmond, WA: Microsoft Press, 1988.
LEUT90   Leutenegger, S., and Vernon, M. "The Performance of Multiprogrammed
         Multiprocessor Scheduling Policies." Proceedings, Conference on Measurement
         and Modeling of Computer Systems, May 1990.
LEVE10   Leventhal,    A.  "Triple-Parity  RAID  and  Beyond."   Communications        of  the
         ACM, January 2010.
LEVI00   Levine, J. Linkers and Loaders. San Francisco: Morgan Kaufmann, 2000.
LEVI03a  Levine, G. "Defining Deadlock." Operating Systems Review, January 2003.
LEVI03b  Levine, G. "Defining Deadlock with Fungible Resources." Operating Systems
         Review, July 2003.
LEVI05   Levis, P., et al."T2:A Second Generation OS for Embedded Sensor Networks."
         Technical Report TKN-05-007, Telecommunication Networks Group, Tech-
         nische Universitat Berlin, 2005. http://csl.stanford.edu/~pal/pubs.html
LEVI06   Levine, J.; Grizzard, J.; and Owen, H. "Detecting and Categorizing Kernel-
         Level    Rootkits   to  Aid  Future  Detection."  IEEE    Security  and  Privacy,
         May­June 2006.
LEVY96   Levy, E., "Smashing the Stack for Fun and Profit." Phrack Magazine, File 14,
         Issue 49, November 1996.
LEWI96   Lewis, B., and Berg, D. Threads Primer. Upper Saddle River, NJ: Prentice Hall,
         1996.
LHEE03   Lhee, K., and Chapin, S. "Buffer Overflow and Format String Overflow Vulner-
         abilities." Software--Practice and Experience, Vol. 33, 2003.
LI10     Li, Y.; Li, W.; and Jiang, C. "A Survey of Virtual Machine Systems: Current
         Technology and Future Trends." Proceedings, Third International Symposium
         on Electronic Commerce and Security, 2010.
LIED95   Liedtke, J. "On -Kernel Construction." Proceedings of the Fifteenth ACM
         Symposium on Operating Systems Principles, December 1995.
LIED96   Liedtke,  J.  "Toward   Real      Microkernels."  Communications    of   the  ACM,
         September 1996.
LIGN05   Ligneris, B. "Virtualization of Linux Based Computers: The Linux-VServer
         Project." Proceedings of the 19th International Symposium on High Perfor-
         mance Computing Systems and Applications, 2005.
LIND04   Lindsley, R. "What's New in the 2.6 Scheduler." Linux Journal, March 2004.
LIU73    Liu, C., and Layland, J. "Scheduling Algorithms for Multiprogramming in a
         Hard Real-time Environment." Journal of the ACM, February 1973.
LIU00    Liu, J. Real-Time Systems. Upper Saddle River, NJ: Prentice Hall, 2000.
LIVA90   Livadas, P. File Structures: Theory and Practice. Englewood Cliffs, NJ: Prentice
         Hall, 1990.
LOVE04   Love, R. "I/O Schedulers." Linux Journal, February 2004.
LOVE10   Love, R. Linux Kernel Development. Upper Saddle River, NJ:Addison-Wesley,
         2010.

LURI94  Lurie, D., and Moore, R. Applying Statistics. U.S. Nuclear Regulatory Commis-
        sion Report NUREG-1475. (Available from the Government Printing Office,
        GPO Stock Number 052-020-00390-4. )
LYNC96  Lynch, N. Distributed Algorithms. San Francisco, CA: Morgan Kaufmann,
        1996.
MAEK87  Maekawa, M.; Oldehoeft, A.; and Oldehoeft, R. Operating Systems: Advanced
        Concepts. Menlo Park, CA: Benjamin Cummings, 1987.
MAJU88  Majumdar, S.; Eager, D.; and Bunt, R."Scheduling in Multiprogrammed Parallel
        Systems." Proceedings, Conference on Measurement and Modeling of Computer
        Systems, May 1988.
MARW06  Marwedel, P. Embedded System Design. Dordrecht,The Netherlands: Springer,
        2006.
MASS03  Massa, A. Embedded Software Development with eCos. Upper Saddle River,
        NJ: Prentice Hall, 2003.
MAUE08  Mauerer, W. Professional Linux Kernal Architecture. New York: Wiley, 2008.
MCDO06  McDougall, R., and Laudon, J. "Multi-Core Microprocessors are Here." login,
        October 2006.
MCDO07  McDougall, R., and Mauro, J. Solaris Internals: Solaris 10 and OpenSolaris
        Kernel Architecture. Palo Alto, CA: Sun Microsystems Press, 2007.
MCHU00  McHugh,      J.;  Christie,  A.;  and   Allen,  J.  "The  Role  of  Intrusion  Detection
        Systems." IEEE Software, September/October 2000.
MCKU05  McKusick, M., and Neville-Neil, J. The Design and Implementation of the Free-
        BSD Operating System. Reading, MA: Addison-Wesley, 2005.
MEE96a  Mee,   C.,   and  Daniel,    E.   eds.  Magnetic    Recording   Technology.    New  York:
        McGraw Hill, 1996.
MEE96b  Mee, C., and Daniel, E. eds. Magnetic Storage Handbook. New York: McGraw
        Hill, 1996.
MENA05  Menasce, D. "MOM vs. RPC: Communication Models for Distributed Applica-
        tions." IEEE Internet Computing, March/April 2005.
MILE92  Milenkovic, M. Operating Systems: Concepts and Design. New York: McGraw-
        Hill, 1992.
MILO00  Milojicic, D.; Douglis, F.; Paindaveine, Y.; Wheeler, R.; and Zhou, S. "Process
        Migration." ACM Computing Surveys, September 2000.
MIRK04  Mirkovic, J., and Relher, P."A Taxonomy of DDoS Attack and DDoS Defense
        Mechanisms." ACM SIGCOMM Computer Communications Review, April
        2004.
MORG92  Morgan, K. "The RTOS Difference." Byte, August 1992.
MORR79  Morris, R., and Thompson, K. "Password Security: A Case History." Communi-
        cations of the ACM, November 1979.
MOSB02  Mosberger, D., and Eranian, S. IA-64 Linux Kernel: Design and Implementation.
        Upper Saddle River, NJ: Prentice Hall, 2002.
MS96    Microsoft Corp. Microsoft Windows NT Workstation Resource Kit. Redmond,
        WA: Microsoft Press, 1996.
MUKH96  Mukherjee, B., and Karsten, S. "Operating Systems for Parallel Machines." In
        Parallel Computers: Theory and Practice. Edited by T. Casavant, P. Tvrkik, and
        F. Plasil. Los Alamitos, CA: IEEE Computer Society Press, 1996.

NACH97  Nachenberg, C. "Computer Virus-Antivirus Coevolution." Communications of
        the ACM, January 1997.
NACH02  Nachenberg, C. "Behavior Blocking: The Next Step in Anti-Virus Protection."
        White Paper, SecurityFocus.com, March 2002.
NAGA97  Nagar, R. Windows NT File System Internals. Sebastopol, CA: O'Reilly, 1997.
NEHM75  Nehmer, J. "Dispatcher Primitives for the Construction of Operating System
        Kernels." Acta Informatica, Vol. 5, 1975.
NELS88  Nelson, M.; Welch, B.; and Ousterhout, J. "Caching in the Sprite Network File
        System." ACM Transactions on Computer Systems, February 1988.
NELS91  Nelson, G. Systems Programming with Modula-3. Englewood Cliffs, NJ: Prentice
        Hall, 1991.
NEWS05  Newsome, J.; Karp, B.; and Song, D."Polygraph:Automatically Generating Signa-
        tures for Polymorphic Worms." IEEE Symposium on Security and Privacy, 2005.
NG98    Ng, S. "Advances in Disk Technology: Performance Issues." Computer, May
        1989.
NING04  Ning, P., et al. "Techniques and Tools for Analyzing Intrusion Alerts." ACM
        Transactions on Information and System Security, May 2004.
NIST95  National Institute of Standards and Technology. An Introduction to Computer
        Security: The NIST Handbook. Special Publication 800-12, October 1995.
NIST10  National Institute of Standards and Technology. NIST/SEMATECH e-Hand-
        book of Statistical Methods, 2010. http://www.itl.nist.gov/div898/handbook
NRC91   National Research Council. Computers at Risk: Safe Computing in the Informa-
        tion Age. Washington, DC: National Academy Press, 1991.
NUTT94  Nuttal, M. "A Brief Survey of Systems Providing Process or Object Migration
        Facilities." Operating Systems Review, October 1994.
OGOR03  O'Gorman,    L.  "Comparing   Passwords,   Tokens     and  Biometrics  for   User
        Authentication." Proceedings of the IEEE, December 2003.
OUST85  Ousterhout, J., et al."A Trace-Drive Analysis of the UNIX 4.2 BSD File System."
        Proceedings, Tenth ACM Symposium on Operating System Principles, 1985.
OUST88  Ousterhout, J., et al. "The Sprite Network Operating System." Computer,
        February 1988.
PAI00   Pai,V.; Druschel, P.; and Zwaenepoel,W."IO-Lite:A Unified I/O Buffering and
        Caching System." ACM Transactions on Computer Systems, February 2000.
PANW88  Panwar, S.; Towsley, D.; and Wolf, J. "Optimal Scheduling Policies for a Class of
        Queues with Customer Deadlines in the Beginning of Service." Journal of the
        ACM, October 1988.
PAPO02  Papoulis, A., and Unnikrishna, P. Probability, Random Variables, and Stochastic
        Processes. New York: McGraw-Hill, 2002.
PARZ06  Parziale, L., et al. TCP/IP Tutorial and Technical Overview. IBM Redbook
        GG24-3376-07, 2006. http://www.redbooks.ibm.com/abstracts/gg243376.html
PATT82  Patterson, D., and Sequin, C. "A VLSI RISC." Computer, September 1982.
PATT85  Patterson, D. "Reduced Instruction Set Computers." Communications of the
        ACM, January 1985.
PATT88  Patterson, D.; Gibson, G.; and Katz, R. "A Case for Redundant Arrays of
        Inexpensive  Disks  (RAID)."    Proceedings,  ACM     SIGMOD   Conference          of
        Management of Data, June 1988.

PATT09   Patterson,     D.,  and  Hennessy,    J.  Computer  Organization  and    Design:  The
         Hardware/Software Interface. San Mateo, CA: Morgan Kaufmann, 2009.
PAZZ92   Pazzini,   M.,  and      Navaux,  P.  "TRIX,  a   Multiprocessor  Transputer-Based
         Operating System." In Parallel Computing and Transputer Applications. Edited
         by M. Valero et al., Barcelona: IOS Press/CIMNE, 1992.
PERR03   Perrine, T. "The End of crypt() Passwords...Please?" login, December 2003.
PETE77   Peterson, J., and Norman, T. "Buddy Systems." Communications of the ACM,
         June 1977.
PETE81   Peterson,   G.  "Myths   About    the     Mutual  Exclusion  Problem."   Information
         Processing Letters, June 1981.
PHAM96   Pham, T., and Garg, P. Multithreaded Programming with Windows NT. Upper
         Saddle River, NJ: Prentice Hall, 1996.
PHIL99   Phillips, J. How to Think About Statistics. New York: Freeman, 1999.
PIZZ89   Pizzarello, A. "Memory Management for a Large Operating System." Proceed-
         ings, International Conference on Measurement and Modeling of Computer
         Systems, May 1989.
POPE85   Popek,    G.,  and   Walker,  B.  The     LOCUS     Distributed  System  Architecture,
         Cambridge, MA: MIT Press, 1985.
PROV99   Provos,   N.,   and  Mazieres,    D.  "A  Future-Adaptable       Password  Scheme."
         Proceedings of the 1999 USENIX Annual Technical Conference, 1999.
PRZY88   Przybylski, S.; Horowitz, M.; and Hennessy, J. "Performance Trade-offs in
         Cache Design." Proceedings, Fifteenth Annual International Symposium on
         Computer Architecture, June 1988.
RADC04   Radcliff, D. "What Are They Thinking?" Network World, March 1, 2004.
RAJA00   Rajagopal, R. Introduction to Microsoft Windows NT Cluster Server. Boca
         Raton, FL: CRC Press, 2000.
RAMA94   Ramamritham, K., and Stankovic, J. "Scheduling Algorithms and Operating
         Systems Support for Real-Time Systems." Proceedings of the IEEE, January
         1994.
RASH88   Rashid, R., et al. "Machine-Independent Virtual Memory Management for
         Paged Uniprocessor and Multiprocessor Architectures." IEEE Transactions
         on Computers, August 1988.
RAYN86   Raynal, M. Algorithms for Mutual Exclusion. Cambridge, MA: MIT Press,
         1986.
RAYN88   Raynal, M. Distributed Algorithms and Protocols. New York: Wiley, 1988.
RAYN90   Raynal, M., and Helary, J. Synchronization and Control of Distributed Systems
         and Programs. New York: Wiley, 1990.
REAG00a  Reagan, P. Client/Server Computing. Upper Saddle River, NJ: Prentice Hall,
         2000.
REAG00b  Reagan, P. Client/Server Network: Design, Operation, and Management. Upper
         Saddle River, NJ: Prentice Hall, 2000.
REIM06   Reimer, J. "Valve Goes Multicore." ars technica, November 5, 2006. arstech-
         nica.com/articles/paedia/cpu/valve-multicore.ars
RICA81   Ricart, G., and Agrawala, A. "An Optimal Algorithm for Mutual Exclusion in
         Computer Networks." Communications of the ACM, January 1981 (Corrigen-
         dum in Communications of the ACM, September 1981).

RICA83  Ricart, G., and Agrawala, A. "Author's Response to `On Mutual Exclusion in
        Computer Networks' by Carvalho and Roucairol." Communications of the
        ACM, February 1983.
RIDG97  Ridge, D., et al."Beowulf: Harnessing the Power of Parallelism in a Pile-of-PCs."
        Proceedings, IEEE Aerospace, 1997.
RITC74  Ritchie, D., and Thompson, K. "The UNIX Time-Sharing System." Communi-
        cations of the ACM, July 1974.
RITC78  Ritchie, D. "UNIX Time-Sharing System: A Retrospective." The Bell System
        Technical Journal, July­August 1978.
RITC84  Ritchie, D. "The Evolution of the UNIX Time-Sharing System." AT&T Bell
        Labs Technical Journal, October 1984.
ROBB04  Robbins, K., and Robbins, S. UNIX Systems Programming: Communication,
        Concurrency, and Threads. Upper Saddle River, NJ: Prentice Hall, 2004.
ROBE03  Roberson,   J.  "ULE:  A  Modern      Scheduler  for  FreeBSD."  Proceedings        of
        BSDCon '03, September 2003.
ROBI90  Robinson, J., and Devarakonda, M."Data Cache Management Using Frequency-
        Based Replacement." Proceedings, Conference on Measurement and Modeling
        of Computer Systems, May 1990.
ROME04  Romer, K., and Mattern, F. "The Design Space of Wireless Sensor Networks."
        IEEE Wireless Communications, December 2004.
ROSE78  Rosenkrantz, D.; Stearns, R.; and Lewis, P. "System Level Concurrency Control
        in Distributed Database Systems." ACM Transactions on Database Systems,
        June 1978.
ROSS10  Ross, S. First Course in Probability. Upper Saddle River, NJ: Prentice Hall,
        2010
RUBI97  Rubini, A. "The Virtual File System in Linux." Linux Journal, May 1997.
RUDO90  Rudolph, B. "Self-Assessment Procedure XXI: Concurrency." Communica-
        tions of the ACM, May 1990.
RUSS11  Russinovich, M.; Solomon, D.; and Ionescu, A. Windows Internals: Covering
        Windows 7 and Windows Server 2008 R2. Redmond, WA: Microsoft Press, 2011.
SALT75  Saltzer, J., and Schroeder, M. "The Protection of Information in Computer Sys-
        tems." Proceedings of the IEEE, September 1975.
SAND94  Sandhu, R., and Samarati, P. "Access Control: Principles and Practice." IEEE
        Communications Magazine, February 1996.
SAND96  Sandhu, R., et al. "Role-Based Access Control Models." Computer, September
        1994.
SATY81  Satyanarayanan, M. and Bhandarkar, D. "Design Trade-Offs in VAX-11 Trans-
        lation Buffer Organization." Computer, December 1981.
SAUE81  Sauer, C., and Chandy, K. Computer Systems Performance Modeling. Englewood
        Cliffs, NJ: Prentice Hall, 1981.
SAUN01  Saunders, G.; Hitchens, M.; and Varadharajan, V. "Role-Based Access Control
        and the Access Control Matrix." Operating Systems Review, October 2001.
SCAR07  Scarfone, K., and Mell, P. Guide to Intrusion Detection and Prevention Systems.
        NIST Special Publication SP 800-94, February 2007.
SELT90  Seltzer, M.; Chen, P.; and Ousterhout, J."Disk Scheduling Revisited." Proceedings,
        USENIX Winter Technical Conference, January 1990.

SHA90   Sha, L.; Rajkumar, R.; and Lehoczky, J. "Priority Inheritance Protocols: An
        Approach to Real-Time Synchronization." IEEE Transactions on Computers,
        September 1990.
SHA91   Sha, L.; Klein, M.; and Goodenough, J. "Rate Monotonic Analysis for Real-
        Time Systems." In [TILB91].
SHA94   Sha, L.; Rajkumar, R.; and Sathaye, S."Generalized Rate-Monotonic Scheduling
        Theory: A Framework for Developing Real-Time Systems." Proceedings of the
        IEEE, January 1994.
SHAN77  Shanker, K. "The Total Computer Security Problem: An Overview." Computer,
        June 1977.
SHEN02  Shene, C."Multithreaded Programming Can Strengthen an Operating Systems
        Course." Computer Science Education Journal, December 2002.
SHIV92  Shivaratri, N.; Krueger, P.; and Singhal, M. "Load Distributing for Locally
        Distributed Systems." Computer, December 1992.
SHOR75  Shore, J. "On the External Storage Fragmentation Produced by First-Fit
        and Best-Fit Allocation Strategies." Communications of the ACM, August,
        1975.
SHOR97  Short, R.; Gamache, R.; Vert, J.; and Massa, M. "Windows NT Clusters for
        Availability and Scalability." Proceedings, COMPCON Spring 97, February
        1997.
SHUB03  Shub, C. "A Unified Treatment of Deadlock." Journal of Computing in Small
        Colleges, October 2003. Available through the ACM digital library.
SILB04  Silberschatz, A.; Galvin, P.; and Gagne, G. Operating System Concepts with
        Java. Reading, MA: Addison-Wesley, 2004.
SING94  Singhal, M. "Deadlock Detection in Distributed Systems." In [CASA94].
SINH97  Sinha, P. Distributed Operating Systems. Piscataway, NJ: IEEE Press, 1997.
SIRA09  Siracusa,   J.  "Grand  Central  Dispatch."  Ars  Technica  Review,  2009.  http://
        arstechnica.com/apple/reviews/2009/08/mac-os-x-10-6.ars/12
SMIT82  Smith, A. "Cache Memories." ACM Computing Surveys, September 1982.
SMIT85  Smith, A. "Disk Cache--Miss Ratio Analysis and Design Considerations."
        ACM Transactions on Computer Systems, August 1985.
SMIT88  Smith, J. "A Survey of Process Migration Mechanisms." Operating Systems
        Review, July 1988.
SMIT89  Smith, J. "Implementing Remote fork() with Checkpoint/restart." Newsletter
        of the IEEE Computer Society Technical Committee on Operating Systems,
        Winter 1989.
SMIT05  Smith, J., and Nair, R. "The Architecture of Virtual Machines." Computer, May
        2005.
SOLT07  Soltesz, S., et al."Container-Based Operating System Virtualization:A Scalable
        High-Performance Alternative to Hypervisors." Proceedings of the EuroSys
        2007 2nd EuroSys Conference, Operating Systems Review, June 2007.
STAI10  Staimer, M. "Alternatives to RAID." Storage Magazine, May 2010.
STAL08  Stallings, W., and Brown L. Computer Security: Principles and Practice. Upper
        Saddle River, NJ: Prentice Hall, 2008.
STAL10  Stallings, W. Computer Organization and Architecture, 8th ed. Upper Saddle
        River, NJ: Prentice Hall, 2010.

STAL11  Stallings, W. Data and Computer Communications. Upper Saddle River: NJ:
        Prentice Hall, 2011.
STAN89  Stankovic, J., and Ramamrithan, K. "The Spring Kernel: A New Paradigm for
        Real-Time Operating Systems." Operating Systems Review, July 1989.
STAN93  Stankovic, J., and Ramamritham, K., eds. Advances in Real-Time Systems. Los
        Alamitos, CA: IEEE Computer Society Press, 1993.
STAN96  Stankovic, J., et al."Strategic Directions in Real-Time and Embedded Systems."
        ACM Computing Surveys, December 1996.
STEE95  Steensgarrd,    B.,  and  Jul,  E.  "Object  and   Native  Code  Mobility  Among
        Heterogeneous Computers." Proceedings, 15th ACM Symposium on Operating
        Systems Principles, December 1995.
STER99  Sterling, T., et al. How to Build a Beowulf. Cambridge, MA: MIT Press, 1999.
STON93  Stone, H. High-Performance Computer Architecture. Reading, MA: Addison-
        Wesley, 1993.
STRE83  Strecker, W. "Transient Behavior of Cache Memories." ACM Transactions on
        Computer Systems, November 1983.
SUMM84  Summers, R. "An Overview of Computer Security." IBM Systems Journal, Vol.
        23, No. 4, 1984.
SUZU82  Suzuki,  I.,  and    Kasami,  T.  "An  Optimality  Theory  for   Mutual  Exclusion
        Algorithms in Computer Networks." Proceedings of the Third International
        Conference on Distributed Computing Systems, October 1982.
SWAI07  Swaine, M. "Wither Operating Systems?" Dr. Dobb's Journal, March 2007.
SYMA01  Symantec Corp. The Digital Immune System. Symantec Technical Brief, 2001.
TAKA01  Takada, H. "Real-Time Operating System for Embedded Systems." In Asia
        South-Pacific     Design  Automation   Conference.  Edited  by   M.  Imai  and   N.
        Yoshida. 2001.
TALL92  Talluri, M.; Kong, S.; Hill, M.; and Patterson, D. "Tradeoffs in Supporting Two
        Page Sizes." Proceedings of the 19th Annual International Symposium on Com-
        puter Architecture, May 1992.
TAMI83  Tamir, Y., and Sequin, C. "Strategies for Managing the Register File in RISC."
        IEEE Transactions on Computers, November 1983.
TANE78  Tanenbaum, A. "Implications of Structured Programming for Machine Archi-
        tecture." Communications of the ACM, March 1978.
TANE85  Tanenbaum, A., and Renesse, R. "Distributed Operating Systems." Computing
        Surveys, December 1985.
TANE06  Tanenbaum,A., and Woodhull,A. Operating Systems: Design and Implementation.
        Upper Saddle River, NJ: Prentice Hall, 2006.
TAY90   Tay, B., and Ananda, A. "A Survey of Remote Procedure Calls." Operating
        Systems Review, July 1990.
TEL01   Tel, G. Introduction to Distributed Algorithms. Cambridge: Cambridge University
        Press, 2001.
TEVA87  Tevanian, A., et al. "Mach Threads and the UNIX Kernel: The Battle for
        Control." Proceedings, Summer 1987 USENIX Conference, June 1987.
THOM01  Thomas, G. "eCos: An Operating System for Embedded Systems." Dr. Dobb's
        Journal, January 2001.

THOM84  Thompson, K. "Reflections on Trusting Trust (Deliberate Software Bugs)."
        Communications of the ACM, August 1984.
TILB91  Tilborg, A., and Koob, G., eds. Foundations of Real-Time Computing: Sched-
        uling  and   Resource   Management.     Boston:  Kluwer    Academic    Publishers,
        1991.
TIME90  Time, Inc. Computer Security, Understanding Computers Series. Alexandria,
        VA: Time-Life Books, 1990.
TIME02  TimeSys Corp. "Priority Inversion: Why You Care and What to Do About
        It."   TimeSys  White   Paper,   2002.     http://www.techonline.com/community/
        ed_resource/tech_paper/21779
TUCK89  Tucker,  A.,  and    Gupta,  A.  "Process  Control  and    Scheduling  Issues   for
        Multiprogrammed      Shared-Memory      Multiprocessors."  Proceedings,  Twelfth
        ACM Symposium on Operating Systems Principles, December 1989.
TUCK04  Tucker, A. ed. The Computer Science Handbook. Boca Raton, FL: CRC Press,
        2004.
VAHA96  Vahalia, U. UNIX Internals:The New Frontiers. Upper Saddle River, NJ: Prentice
        Hall, 1996.
VENU09  Venugopal, K. Files Structures Using C++. New York: McGraw-Hill, 2009.
WAGN00  Wagner, D., and Goldberg, I. "Proofs of Security for the UNIX Password
        Hashing Algorithm." Proceedings, ASIACRYPT '00, 2000.
WALK89  Walker, B., and Mathews, R. "Process Migration in AIX's Transparent Com-
        puting Facility." Newsletter of the IEEE Computer Society Technical Committee
        on Operating Systems, Winter 1989.
WARD80  Ward,    S.  "TRIX:  A  Network-Oriented   Operating       System."    Proceedings,
        COMPCON '80, 1980.
WARR91  Warren, C. "Rate Monotonic Scheduling." IEEE Micro, June 1991.
WARE79  Ware, W., ed. Security Controls for Computer Systems. RAND Report 609-1,
        October 1979. http://www.rand.org/pubs/reports/R609-1/index2.html
WEIZ81  Weizer, N. "A History of Operating Systems." Datamation, January 1981.
WEND89  Wendorf, J.; Wendorf, R.; and Tokuda, H. "Scheduling Operating System Pro-
        cessing on Small-Scale Microprocessors." Proceedings, 22nd Annual Hawaii
        International Conference on System Science, January 1989.
WHIT99  White, S. Anatomy of a Commercial-Grade Immune System. IBM Research
        White Paper, 1999.
WIED87  Wiederhold, G. File Organization for Database Design. New York: McGraw-
        Hill, 1987.
WOOD86  Woodside, C. "Controllability of Computer Performance Tradeoffs Obtained
        Using Controlled-Share Queue Schedulers." IEEE Transactions on Software
        Engineering, October 1986.
WOOD89  Woodbury, P., et al. "Shared Memory Multiprocessors: The Right Approach to
        Parallel Processing." Proceedings, COMPCON Spring '89, March 1989.
WORT94  Worthington, B.; Ganger, G.; and Patt, Y. "Scheduling Algorithms for Modern
        Disk Drives." ACM SiGMETRICS, May 1994.
WRIG95  Wright, G., and Stevens, W. TCP/IP Illustrated, Volume 2: The Implementation.
        Reading, MA: Addison-Wesley, 1995.

ZAHO90  Zahorjan,  J.,  and  McCann,  C.  "Processor  Scheduling  in  Shared  Memory
        Multiprocessors." Proceedings, Conference on Measurement and Modeling of
        Computer Systems, May 1990.
ZAJC93  Zajcew, R., et al. "An OSF/1 UNIX for Massively Parallel Multicomputers."
        Proceedings, Winter USENIX Conference, January 1993.
ZEAD97  Zeadally, S. "An Evaluation of the Real-Time Performance of SVR4.0 and
        SVR4.2." Operating Systems Review, January 1977.
ZOU05   Zou, C., et al."The Monitoring and Early Detection of Internet Worms." IEEE/
        ACM Transactions on Networking, October 2005.

Note: letters "A" and "B" followed by locators refers to Appendix page numbers. Green colored locators refers to online
chapter page numbers.
A                                                           Address translation
Absolute loading, 334­336                                   for paging system, 347, 348
Absolute scalability, 699                                   in segmentation, 357, 358
Access                                                      Advanced local procedure call (ALPC) facility, 84
   efficiency, 44                                           Advertisement add-ons, 631
   matrix, 552                                              Alignment check, 132
   methods for file systems, 526                            All users class, 541
   rights for file sharing, 540­541, 553                    AMD64, 81
   time, 487                                                Amdahl's law, 171
   token, 668­669                                           Analyzers for intrusion detection, 145
Access control, 146, 646­653                                Anomaly detection, 655
   categories of, 646­647                                   Anticipatory input/output scheduler, 511­512
   commands, 650                                            Antivirus approaches, 657­661
   discretionary, 646, 647­651                              behavior-blocking software, 659­661
   function of, 649                                         digital immune system, 658­659
   lists, 553, 559­560                                      generic decryption, 657­658
   mandatory, 646­647                                       Anys state : exit process, 124
   matrix of, 648                                           Aperiodic tasks, 443, 451
   protection and, 66                                       Appending access rights, 540
   role-based, 647, 651­653                                 Application binary interface (ABI), 50, 75
   security scheme, 668                                     Application layer, 17-8
   security threats and, 646­653                            Application programming interface (API), 50, 75, 679, 17-16
   structures of, 552­553                                   Architecture, 582
   UNIX systems, 558­559                                    client/server application, three-tier, 680, 685­686
Access control lists                                        client/server model, 85­86
   discretionary, 670                                       cluster, 703­704
   file system security, 553                                file management systems, 525­526
   system, 670                                              Linux VServer, 101
   UNIX systems, 559­560                                    microkernel, 71
Accountability for computer security, 610                   Microsoft Windows, 82­85
Accounting information, 109                                 Microsoft Windows Vista, 82
Accumulator (AC), 12                                        middleware, 688­689
Action field, 656                                           UNIX systems, 91
Active attacks, 615                                         virtual machines (VM), 75­76
Active Directory, 80                                        ARPANET, 17-6
Active secondary, 700, 701                                  Assets of computer system, threats to, 613­616
Address binding, 336                                        Assignment of processes to processors, 433­434
Addresses. See also Address translation; Virtual addresses  Associative lookup for page table, 353
   executable, space protection, 666                        Associative mapping, 351
   logical, 320, 323                                        Asynchronous input/output, Windows, 513­514
   physical, 320                                            Asynchronous procedure call (APC), 514
   read, 67                                                 Asynchronous processing, 161­162
   real, 341                                                Asynchronous remote procedure calls (RPC), 698
   registers, 9, 10                                         Asynchronous service, 691
   relative, 320                                            Atomic bitmap operations, 286, 287
   space, 187, 341                                          Atomic integer operations, 286­287
   space randomization, 667                                 Atomic operations, 200, 285­287
Addressing, 68, 235­236                                     AT&T, 90, 93
   direct, 235                                              Attacks on computer system
   indirect, 235                                            threats, 610­612
   indirect process communication, 235­236                  types of, 610­611
   Linux virtual memory, 384­385                            Attribute definition table, 567
   many-to-one relationship, 235                            Audit records for intrusion detection, 655­657
   message passing, 235­236                                 Authentication, 145­146, 640­646
   one-to-many relationship, 235                            biometric, 645­646
   one-to-one relationship, 235                             computer security, 145­146, 640­646
   for process, requirements of, 308                        password-based, UNIX system, 640­643
   translation of, 324                                      steps of, 145
   virtual memory, 384­385                                  token-based, 643­645                                         743

Authentication (continued)                              permanent, 259
   of user's identification, 145, 146                   record, 541­543
   verification step of, 145                         Block operation, 162
Authenticity of information, 69, 610                 Block-oriented device, 484
Autocovariance, 19-16                                Blocks, 28, 189­190, 544
Automatic allocation, 66                                boot, 557
Automatic management, 66                                data, 557
Automatic teller machine (ATM), 644                     defined, 189
Auto-rooter, 620                                        dispatched, 190
Auxiliary carry flag, 132                               function of, 190
Auxiliary memory, 27                                    process control, 109­110
Availability, 18-3                                      scheduled, 190
Availability of information, 69, 72, 609, 610           size of, 30
Available state, 388                                 Boot block, 557
Avoidance approaches for operating systems, 265      Boot sector infector, 626
Awareness, degrees of, 205                           Bots, 631­633
Axiomatic definition of probability, 19-2­5             botnet, 631
                                                        botnet attack, construction of, 632­633
B                                                       remote control facility, 632
BACI (Ben-Ari Concurrent Interpreter), B-7              use of, 631­632
Backdoor, 619­621, 620                               Bottom half code, 288
Background work, 161                                 Bottom-half kernel threads, 463
Balancing resources, 401                             Bounded-buffer monitor code, 231
Banker's algorithm, 271                              Bounded-buffer producer/consumer
Barbershop problem, A-15­21                             problem, 229, 238
Basic buffer overflow, 327                           Brownian motion process, 19-19­22
Basic file systems, 522                              Browser helper objects (BHOs), 631
Basic input/output supervisor, 525                   B-trees, 532­535
Basic spinlocks, 287­288                                characteristics of, 533
Batch systems                                           definition of, 533
   multiprogrammed, 56­58                               nodes into, insertion of, 535
   simple, 53­56                                        properties of, 533
Bayes's Theorem, 19-6­8                                 rules for, 534
Behavior-blocking software, 659­661                  Buddy system, 317­319
Bell Labs, 90                                           algorithms of, 318
Beowulf clusters, 706­708                               example of, 318
   configuration of, 707                                tree representation of, 319
   features of, 706­707                              Buffer cache, UNIX system, 507­508
Beowulf distributed process space (BPROC), 708       Buffering, 369, 483­487
Beowulf Ethernet channel bonding, 708                Buffer overflow
Beowulf software, 707­708                               basic, example of, 327
Berkeley Sockets Interface, 17-16                       stack values, 328
Berkeley Software Distribution (BSD), 94             Buffer overflow attacks, 326­330
Best fit strategy, 315, 544                             compile-time defenses, 663­666
_bh, 288                                                dealing with, 663­667
Bias, 20-41                                             defending against, 330
Binary semaphores, 213, 215, 221, 223, 224, 289­290     run-time defenses, 666­667
Biometric authentication, 645­646                    Buffer overrun. See Buffer overflow
Bitmap operations, Linux atomic, 286, 287            Buffer registers
Bitmap scheduler, 587                                   input/output buffer register (I/OBR), 10
Bit tables, 548­549                                     memory buffer register (MBR), 9­10
Blended attack, 622                                  Buffer swapping. See Double buffer
Block device drivers, 100                            Busy waiting technique, 212, A-2
Block diagram, 36, 479
Blocked : blocked/suspend process, 123               C
Blocked : exit process, 119                          Cache consistency, 687
Blocked process, 122­123                             Cache levels, 30
Blocked : ready process, 119                         Cache manager, 83, 513, 568
Blocked state, 119, 147­148                          Cache memory, 27­31, 502­503. See also Disk cache
Blocked/suspend : blocked process, 124                  blocks, 28
Blocked/suspended process, 123                          block size, 30
Blocked/suspend : ready/suspend process, 123            cache size, 30
Blocked/waiting process state, 117                      categories of, 30
Blocking, 234                                           design of, 29­31
   fixed, 541                                           main memory and, 28­29
   nonblocking, 695                                     mapping function, 31

motivation, 27                                              middleware, 687­689
principles of, 28­29                                        network for, 679
read operation of, 29­30                                    servers in, 678­679
replacement algorithm, 31                                   terminology of, 679
slots, 28                                                   Client-server model, 85­86
write policy, 31                                            Clock algorithm, 367, 381, 386
Cache operation, 353                                        Clock interrupt, 137
Cache size, 30, 369­370                                     Clock page, 368
CalmRISC, 579                                               Clock replacement policy, 365, 366
Canary value, 665                                           Cloned () process, 188
Capability tickets, 553                                     Closing files, 522
Carry flag, 132                                             Clouds, 171
Centralized algorithm, 18-18­19                             Cluster bit map, 567
Centralized control, 18-34                                  Clusters, 431, 565, 699­704
Central processing unit (CPU), 8                            architecture of, 703­704
Certain event, 19-3                                         benefits of, 701
Chained allocation, 546­547                                 Beowulf, 706­708
Chained free portions, 549                                  configurations of, 699­701
Chain pointer, 349                                          limitations of, 701
Challenge-response, 644                                     Linux, 706­708
Changing protection access rights, 540                      methods of, 701
Channel, 18-12                                              multiprocessor system, 431
Character device drivers, Linux, 100                        objectives of, 699
Character queue, UNIX SVR4, 508                             operating system design issues with, 702­703
Chbind, 101                                                 parallelizing computation, 702­703
Chcontext, 100­101                                          requirements of, 699
Checkpointing, 704                                          sizes of, 566
Child process, 115                                          SMP, 704
Chip multiprocessor, 35­36                                  in symmetric multiprocessor, 704
Chroot, 100                                                 Cluster service, 704
CIA triad for security, 609                                 Coarse-grained services, 690
C implementation of UNIX systems, 90                        Coarse parallelism, 432­433
Circular buffer, 486                                        Coarse threading, 174
Circular SCAN (C-SCAN) policy, 493                          Codecs, 10
Circular wait condition, 18-31                              Coefficient of variation, 20-20
Circular wait process, deadlock prevention using, 267, 269  Commands, TinyOS, 598
Clandestine user, 143                                       Commercial operating systems, 578
Classes                                                     Committed state, 388
all users, 541                                              Common Object Request Broker Architecture
of client-server applications, 683­685                      (CORBA), 690, 698
of interrupts, 14                                           Communication
kernel (99-60), 462                                         architecture, 17-2­3
objects, 86                                                 cooperation among processes by, 208­209
priority, 463, 467                                          datagram, 17-16, 17-18
real time (159-100), 461­462                                deadlock, in distributed system, 18-44
real-time priority, 467                                     devices, 476
specific user, 541                                          indirect process, 235­236
time-shared (59-0), 462                                     interprocess, 233
user groups, 541                                            lines, security of, 509, 615­616
variable priority, 467                                      message, 18-38­44
Classification by target, 626                               performance, 18-3
Cleaning policy, 376­377                                    socket, 17-18
Client, 678, 679. See also Client/server computing          stream, 17-18
Client-based processing, 684                                Compaction of memory, 314
Client machines, 678                                        Compare&swap instruction, 210­212
Client/server applications, 680­687                         Compatible Time-Sharing System (CTSS), 60­61
classes of, 683­685                                         Competition, 205
database applications, 681­683                              Compile-time defenses, 663­666
file cache consistency, 686­687                             language extensions, safe libraries and, 664­665
three-tier architecture of, 685­686                         programming language choices, 663­664
Client/server binding, 697                                  safe coding techniques, 664
Client/server computing, 678­689. See also Client/server    stacking protection mechanisms, 665­666
applications                                                Complement, 19-3
architecture of, 680                                        Completion deadline, 448
concept of, 678                                             Compression viruses, 625
definition of, 678­680                                      Computer-aided design (CAD), 40

Computer communications, 17-4                              scheduling and, 482­483
Computer emergency response teams (CERTs), 618             status registers and, 130, 131
Computer network, 17-4                                     user, 444
Computer systems. See also Operating systems (OS)       Control bits, 132, 349
assets of, threats to, 613­616                          Control mode, 135
attacks, types of, 610­611                              Control objects, Windows, 88
basic elements of, 8­10                                 Cooperation, 205
cache memory, 27­31                                     Cooperative processing, 684
direct memory access, 31­32                             Copy-on-reference strategy, 18-6
instruction execution, 11­13                            Cores, 10, 35
interrupts, 14­23                                       Coroutines, 247, 283, A-4
memory hierarchy, 24­27                                 Correlation coefficient, 19-13, 19-16
microprocessor, 10, 33­36                               Corruption, 612
overview of, 7­36                                       Counting (general) semaphores, 215, 222, 289­290
threats, 610­612                                        Covariance variables, 19-13
top-level components of, 9                              CPU emulator, 657
Concurrency, 198­244, 258­298, A-1­20                   Create file operation, 537
barbershop problem, A-15­21                             Creation of files, 522
contexts of, 199­200                                    Criminal intruders, 618
deadlock, 259­278                                       Critchley, Adam, B-4
dining philosophers problem, 279­281                    Critical resource, 206
example of, 201­203                                     Critical sections, 200, 206, 296­297
Linux kernel, mechanisms of, 285­292                    C-SCAN (circular SCAN) policy, 493
message passing, 233­239                                Csignal (c), 227
monitors, 226­232                                       Currency mechanisms, 213
mutual exclusion, 209­213                               Cutler, Dave, 80
operating systems, concerns of, 204                     Cwait (c), 227
principles of, 201­209
process interaction, 205­209                            D
race conditions of, 204, A-8­15                         Data
readers/writers problems, 239­243                          block, 557
semaphores, 213­226, A-8­15                                confidentiality, 609
Solaris thread synchronization, primitives of, 292­294     Context, 109
terms related to, 200                                      integrity, 69, 609
UNIX, mechanisms of, 281­285                               memory, external fragmentation of, 314
Windows 7, mechanisms of, 294­297                          processing, 11
Concurrent process, simultaneous, 77                       rate, 476
Concurrent threads, simultaneous, 77                       security threats to, 614­615
Conditional probability, and independence, 19-6            semaphores and, 219
Condition codes, 132                                       set of, 109
Condition variables, 213, 227, 294, 297                    SIMD techniques, 10
eCos, 590­591                                              streams, multiple, 565
monitors, 227                                              table entry, page frame, 380­381
Confidentiality, of information, 69, 609, 610              transfer capacity, RAID level 0 for high, 498­499
Configurability, 577, 579­582                           Database, 523
Configuration database manager, 706                        client/server applications, 681­683
Configuration manager, Windows, 84                         configuration database manager, 706
Connection-oriented protocol, 17-19                        relational, 679
Consistency, 686                                           server, 20-24­25
Consistent distributed global states, 18-13             Datagram communication, 17-16, 17-18
Consumable resources, deadlock and, 264­266             DDR3 (double data rate) memory controller, 35
Containment, 661­662                                    Deadlines, 401
Context data, 109                                       Deadline scheduler, 510­511
Contiguous allocation, 545­546                          Deadline scheduling, 448­452
Continuous-time stochastic process, 19-14                  design issues, 449
Continuous-value stochastic process, 19-15                 real-time scheduling, 448­452
Continuous variable, 19-8                                  for tasks, 448­451
Control, 11                                             Deadlocks, 64, 200, 206, 213
bits, 132, 349                                             communication, in distributed system, 18-44
complexity of, 476                                         conditions for, 267­268
load, 377­379                                              consumable resources, 264­266
mode, 135                                                  distributed, 18-30­44
with multiple interrupts, transfer of, 22                  errors in process, 64
objects, Windows, 88                                       example of, 261
operating system, structures of, 126­128                   execution paths of, 262
process, 134­139                                           free, 18-26

illustration of, 260                        Dining philosophers problem, 279­281
integrated strategy for, 278                dining arrangement, for philosophers, 279
no, example of, 263                         monitors, solutions using, 280­281
phantom, 18-31                              semaphores, solutions using, 280
principles of, 259­268                      Direct addressing, 235
resource allocation graphs, 266­267         Direct (hashed) file, 532
reusable resources, 263­264                 Direction flag, 132
store-and-forward, 18-42                    Direct lookup for page table, 353
Deadlock avoidance, 268, 270­275, 18-33­34  Direct memory access (DMA), 31­32
logic of, 275                               block diagram, 479
process initiation denial, 270­271          configurations for, alternative, 480
resource allocation denial, 271­275         input/output operations, techniques for,
restrictions of, 274                        31­32, 477­480
Deadlock detection, 265, 268, 276­278       Directories
algorithm of, 276­277, 18-34­38             attributes, 567
recovery, 277­278                           file, 553­554
Deadlock prevention, 265, 268­275,          management, 483
18-32­33, 18-43                             UNIX, 557
circular wait condition, 269                Disabled interrupts, 22­23
hold and wait condition, 269                Discoverable services, 691
mutual exclusion, 269                       Discrete variable, 19-8
no preemption condition, 267, 269           Discrete-time stochastic process, 19-14
Deception, security threats of, 612         Discrete-value stochastic process, 19-15
Decision mode, 404                          Discretionary access control (DAC),
Dedicated processor assignment, 440­441     646, 647­651
Dedicated resources, 601­602                Discretionary access control list (DACL), 670
Default ACL, 669                            Disk allocation tables, 547
Default owner, 669                          Disk block descriptors, 380­381
Defense Advanced Research Projects Agency   Disk cache, 40, 502­506
(DARPA), 17-6­7                             design issues of, 503­505
Deferred service routines (DSRs), 584­585   performance issues of, 505­506
Degrees of awareness, 205                   Disk drives, 509
Dekker's algorithm, A-2­7                   Disk duplexing, 515
Delay variable, 383­384                     Disk performance parameters, 487­489
Delete access, 671                          rotational delay, 488­489
Delete file operation, 537                  seek time, 488
Deletion access rights, 540                 timing comparison, 489
Deletion of files, 522                      Disk scheduling
Demand cleaning policy, 376                 algorithms for, 491­492
Demand paging, 361                          anticipatory input/output scheduler,
Denial of service attacks, 615­616          511­512
Denning, Dorothy, 655                       deadline scheduler, 510­511
Density function, 19-8­9                    disk performance parameters, 487­489
Dentry object, Linux, 562, 564              elevator scheduler, 510
*deps, 97                                   input/output management and, 474­516
Design issues                               policies for, 490­494
with deadline scheduling, 449               Disk storage, 565­566
of disk cache, 503­505                      Dispatched blocks, 190
for embedded operating systems, 577         Dispatcher objects, 88, 295­296
of input/output, 480­483                    Dispatcher program, 111
with multiprocessor scheduling, 433­435     Dispatching discipline, 20-13
Destination network address, 17-14          Dispatch queues, 462
Detection of virus, 657                     Disruption, security threats of, 612
Detection-specific audit records, 655       Distributed algorithm, 18-19
Determinism, 443­444                        Distributed control, 18-34
Deterministic behavior, 583                 Distributed data processing (DDP), 17-2
Device driver interface to eCos kernel,     Distributed deadlock, 18-30­44
585­586                                     in message communication, 18-38­44
Device drivers, 83, 525                     in resource allocation, 18-30­38
Device input/output, 482                    Distributed denial-of-service (DDoS) attacks, 631
Device list, 507                            Distributed global states, 18-10­16
Die, 35                                     consistent, 18-13
Differential responsiveness, 69             distributed snapshot algorithm, 18-14­16
Digital Equipment Corporation, 80           example of, 18-12
Digital immune system, 658­659              inconsistent, 18-13
Digital Signal Processors (DSPs), 10        process and channel graph, 18-15

Distributed message passing, 691­695                        Electronic mail facility, 629
   blocking, differentiating between nonblocking and, 695   Elevator scheduler, 510
   middleware, 693                                          E-mail, security threats to, 622
   primitives of, basic, 694                                E-mail viruses, 628
   reliability, differentiating between unreliability and,  Embedded Configurable Operating System (eCos),
   694­695                                                  579­594. See also specific types of
Distributed multiprocessor system, 431                      components of, 582­586
Distributed mutual exclusion, 18-16­30                      configurability, 579­582
   concepts of, 18-17­20                                    hardware abstraction layer, 582­583
   distributed queue, 18-24­27                              input/output system, 584­586
   distributed system, ordering of events in, 18-20­23      scheduler, 587­588
   token-passing approach, 18-28­30                         standard C libraries, 586
Distributed operating systems, 73, 17-3                     thread synchronization, 589­594
Distributed processing, 199                                 Embedded Configurable Operating System (eCos) kernel,
   Beowulf clusters, 706­708                                583­584
   client/server computing, 678­689                         device driver interface to, 585­586
   clusters, 699­704                                        objectives of, 583
   distributed message passing, 691­695                     Embedded operating systems, 573­603
   Linux clusters, 706­708                                  characteristics of, 576­579
   Microsoft Windows cluster server, 704­706                commercial operating systems, adapting to existing, 578
   remote procedure call (RPC), 695­698                     definition of, 574
   service-oriented architecture (SOA), 689­691             design issues for, 577
Distributed process management, 18-1­45                     eCos (Embedded Configurable Operating System),
   distributed deadlock, 18-30­44                           579­594
   distributed global states, 18-10­16                      elements of, 576
   distributed mutual exclusion, 18-16­30                   examples of, 575
   process migration, 18-2­10                               organization of, 576
Distributed queue, 18-24­27                                 purpose-built, 578­579
   first version, 18-24­26                                  requirements/constraints of, 574­575
   second version, 18-26­27                                 TinyOS, 594­603
Distributed snapshot, 18-13                                 Emerald system, 171
Distributed snapshot algorithm, 18-14­16                    Emulation control module, 657
Distributed system, ordering of events in, 18-20­23         Encapsulation, 86
Distribution function, 19-8­9                               Encrypted viruses, 626
Distributions, 19-9­12                                      Encryption, volume, 515
   exponential, 19-9­11                                     Energy efficiency, Microsoft Windows 7, 89
   normal, 19-12                                            Enforcing priorities, 401
   poisson, 19-11­12                                        EnFuzion, 708
DMA. See Direct memory access (DMA)                         Engineering improvements, Microsoft Windows 7, 89
Domain Name System (DNS) database, 17-15                    Ensemble averages, 19-25
Dormant phase, 624                                          Enterprise Edition (J2EE platform), 173
Double buffer, 486                                          Environmental subsystems, Windows, 84
Downloaders, 620                                            Ergodicity, 19-24­26
Driver input/output queue, 507                              Errors in process, causes of, 63­64
Dynamic allocation, 543­544                                 deadlocks, 64
Dynamically linked libraries (DLLs), 705                    mutual exclusion, failed, 63­64
Dynamic best effort scheduling, 447, 448                    program operation, nondeterminate, 64
Dynamic biometrics, 146                                     synchronization, improper, 63
Dynamic linker, 338­339                                     Event, 19-2
Dynamic linking, Linux, 95, 338­339                         Event flags, 213, 591­592
Dynamic link libraries (DLLs), 84, 339                      Event object, Windows, 296, 514
Dynamic partitioning for memory, 314­317                    Event processor, 706
   effect of, 315                                           Events, TinyOS, 598
   placement algorithm, 315­317                             Eviction, 18-9­10
   replacement algorithm, 317                               Exception-condition field, 656
Dynamic password generator, 644                             Exchange instruction, 212
Dynamic planning-based scheduling, 447, 448                 Executable address space protection, 666
Dynamic run-time loading, 337                               Executable program, 64
Dynamic scheduling, 442                                     Executables (EXEs), 84
                                                            Execution
E                                                           access rights, 540
Eager strategy, 18-5                                        context (process state), 64
ECos. See Embedded Configurable Operating System            modules of, 83­84
   (eCos)                                                   of object-oriented design, 87
Efficiency, 69, 480                                         paths of deadlock, 262
EFLAGS register, Pentium, 131­132                           phase, 624

   of process, 158                           security (See File system security)
   process control, modes of, 134­136        UNIX, 553­560
   of Solaris threads, 184­185               File object, Linux, 514, 562, 564
   speed of, 162                             File organization/access, 527­532
   stack, 160                                criteria for, 527­528
   state, 186                                direct file, 532
Executive stage, 12­13                       hash file, 532
Exit process state, 117                      indexed file, 531­532
Exploits, 620                                indexed sequential file, 530­531
Exponential averaging, 410, 412              performance, grades of, 529
Exponential distributions, 19-9­11           pile, 529­530
Exponential population, means for, 20-40     sequential file, 530
Exponential smoothing coefficients, 411      types of, common, 528­529
Exposure, 610­611                            Files, 522
External fragmentation of memory data, 314   allocation (See File allocation)
                                             cache consistency, 686­687
F                                            closing, 522
Facial characteristics, 645                  creation of, 522
Facilities request, 17-14                    deletion of, 522
Failback, 702                                direct, 532
Failover, 702                                directories (See File directories)
Failover manger, 706                         field, input/output, 522­523
Fail-soft operation, 444­445                 hashed, 532
Failure management, clusters, 702            indexed, 531­532
Fairness, 69, 401, 18-26                     indexed sequential, 530­531
Fair-share scheduling, 420­422               large, support for, 565
False negatives/positives, 653               links, 554
Falsification, 612                           log, 567
Fatal region, 262                            long-term existence of, 522
Fat client, 684                              management (See File management systems)
Faulting processing, 378                     MFT2, 567
Faults, 100                                  naming, 538­539
Fault tolerance, 78                          object, Linux, 514, 562, 564
Feedback, 413­415                            opening, 522
Feedback scheduling, 414                     operations performed on, 522
Fetches, 11                                  ordinary, 553
Fetch policy, 361­362                        organization/access (See File organization/access)
Fetch stage, 12­13                           performance, grades of, 529
Field, input/output files, 522­523           pile, 529­530
File allocation, 543­547                     properties of, 522
   dynamic allocation vs. preallocation,     reading, 522
   543­544                                   regular, 553
   methods of, 545­547                       sequential (See Sequential files)
   portion size, 544­545                     sharing, 207­208, 309, 522, 540­541
   UNIX, 556­557                             special, 554
File allocation table (FAT), 543             structure, 522­524, 565­567
File directories, 535­539                    symbolic links, 554, 565
   contents of, 535­536                      systems (See File systems)
   elements of, 536                          tables, 127, 543, 567
   naming, 538­539                           tree-structured, 538, 539
   structure of, 537­538                     UNIX, 553­555
   tree-structured, 538, 539                 UNIX FreeBSD, structure of, 555
   working, 539                              writing, 522
File infector, 626                           File systems, 100, 187, 483, 522, 567
File management systems, 520­569             drivers, 513
   architecture of, 525­526                  isolation, 100
   B-trees, 532­535                          Windows, 564­569
   elements of, 526                          File system security, 551­553
   file sharing, 540­541                     access control lists, 553
   functions of, 526­527                     access control structures, 552­553
   Linux virtual file system (VFS), 560­564  capability tickets, 553
   objectives of, 524                        File tables, 127
   overview of, 522­527                      allocation table (FAT), 543
   record blocking, 541­543                  volume master, 567
   requirements of, minimal, 524­524         File transfer, architecture for, 17-6
   secondary storage management, 543­551     File Transfer Protocol (FTP), 17-15

Filter-based worm containment, 661                          G
Fine-grained parallelism, 433                               Gang scheduling, 439
Fine-grained threading, 174                                 GCC (GNU Compiler Collection), 665
Fingerprinting, 632, 645                                    Generality, 481, 661
Finish operation, 162                                       General message format, 236­237
Finite circular buffer, for producer/consumer problem, 225  General semaphores, 215, 222
Firewalls, 146­147                                          Generic_all access bits, 671
First-come-first-served (FCFS), 407, 438, 20-13             Generic decryption (GD), 657­658
First fit strategy, 315­316, 544                            Generic_execute access bits, 671
First-in-first-out (FIFO) policy, 216, 364, 490             Generic_read access bits, 671
First-order statistics, 19-15­17                            Generic_write access bits, 671
Five-state process model, 116­120                           Global coverage, 661
states of, 117                                              Global replacement policy, 371
transitions of, 118­119                                     Global scope, 372
Fixed allocation                                            Global state, 18-13
local page, 367                                             Grand Central Dispatch (GCD), 78­79
local scope, 371                                            Granularity, 432­433. See also Parallelism
replacement policy, 370                                     Graphical Processing Units (GPUs), 10
Fixed blocking, 541                                         Graphic user interface (GUI), 681
Fixed function units, 10                                    Group
Fixed partitioning for memory, 310­314                         concept of, 705
partition size, 310­312                                        resources, 705
placement algorithm, 312­314                                   SIDs, 669
Flags, 97, 669                                              Guard pages, 667
Flexibility of input/output devices, 577                    Gupta Corp, 684
Flooders, 620
Flushing strategy, 18-6                                     H
Foreground work, 161                                        Hackers, 616­618
FORTRAN programs, 40                                        Hamming code, 500
Four page replacement algorithm,                            Hand geometry, 645
behavior of, 364                                            Handspread, 381
Frame, 307, 321, 322                                        Hard affinity process, 181
Frame locking, 363                                          Hard links, 565
Free block list, 549­550                                    Hard real-time task, 443
Free frame, 322                                             Hardware
Free list, 507                                                 device drivers, 513
Free Software Foundation (FSF), 94                             interrupt processing, 19­20
Free space management, 547­550                                 mutual exclusion, 209­213
bit tables, 548­549                                            RAID, 514
chained free portions, 549                                     relocation, 320
free block list, 549­550                                       security threats to, 613
indexing, 549                                                  simple batch systems, 55­56
FREE state, 184                                                virtual memory (paging), 348­360
Frequency-based replacement, 504                            Hardware abstraction layer (HAL), 83, 582­583
FSCAN policy, 493­494                                       Hashed file, 532
Functionally specialized multiprocessor                     Hashed passwords, 641­642
system, 431                                                 Hash table, 507­508
Functions                                                   Hexadecimal digit, 12
access control, 649                                         Hierarchical control, 18-34
blocks, 190                                                 High availability, 699
file management systems, 526­527                            Highest response ratio next (HRRN), 413
kernel (nucleus), 135                                       High-level language (HLL), 50
linking, 338                                                High Performance Computing and Communications
loading, 334                                                   (HPCC), 706
MAC OS Grand Central Dispatch (GCD), 192                    Hit list scanning, 633
mapping, 30, 31                                             Hit ratio (H), 25
Microsoft Windows input/output, 513                         Hold and wait condition, 18-31
operating systems (OS), 48­52                               Hold and wait process, deadlock prevention
processor, 9                                                   using, 267, 269
resource management in OS, scheduling and, 70               Host-based intrusion detection, 654­655
selection, 403                                              Host-based processing, 683
support, 135                                                Hosting platform, 101
threads, 162­164                                            Hot-based IDS, 144
wait, 295                                                   Human readable devices, 475
worms, 629                                                  Hybrid threading, 174­175
Fuzzing, 329                                                Hypervisor, 74

I                                                logical structure of, 481­483
IBM personal computer (PC), 60, 80, 94           management, 135
Identification flag, 132                         manager, 83, 513, 568
Identification of virus, 657                     model of, 482
Identification step of authentication, 145       modules, 9, 10
Identifiers, 109, 186                            organization of, 477­480
Idle user, 463                                   performing, techniques for, 31­32, 477
IDS. See Intrusion detection systems (IDS)       physical, 522, 525
If statements, 231                               processor, 11, 478
Incapacitation, 612                              program/programmed, 14, 31­32, 477
In-circuit emulator (ICE), B-3                   RAID, 494­502, 499
Inconsistent distributed global states, 18-13    scheduling, 396
Incremental growth, 72                           space, single, 704
Incremental scalability, 699                     status information, 109
Independence, and conditional probability, 19-6  supervisor, basic, 525
Independent events, 19-6                         tables, 127
Independent increments, 19-19­24                 three-level interrupt mode for, 584­585
   Brownian motion process, 19-19­22             UNIX SVR4 input/output, 506­509
   poisson counting process, 19-22­24            Windows, 512­515
Independent parallelism, 432                     Input/output (I/O) buffering, 483­487
Independent variables, 19-13                     circular buffer, 486
Indexed allocation, 547                          double buffer, 486
Indexed files, 531­532                           single buffer, 484­486
Indexed sequential files, 530­531                utility of, 486­487
Indexing, 549                                    Input/output buffer register (I/OBR), 10
Index register, 64­65                            Input/output (I/O) devices
Indirect addressing, 235                         data rates of, 476
Indirect process communication, 235­236          flexibility of, 577
Individual processors, 434­435                   types of, 475­477
Infection from viruses, 626                      Insider attacks, 618­619
Infection mechanism (vector), 623                Instantiation of objects, 86
Infection vector, 623                            Instruction cycle, 11, 15­18
Inference, 611                                   Instruction execution, 11­13. See also Direct
Infinite buffer for producer/consumer problem,   memory access (DMA)
   220, 221, 223, 224                            categories of, 11
Information, 68­69, 186                          characteristics of, 12
Information protection. See Security threats     executive stage of, 11
Inheritance, 86­87                               fetch stage of, 11
Initial infection from viruses, 626              partial program execution, 12­13
Inode object, 562, 563                           steps of, 11
Inodes, UNIX, 554­556                            Instruction register (IR), 11
   elements of, 554­555                          Instruction set architecture (ISA), 50
   FreeBSD, structure of, 555                    Instructor's Resource Center (IRC), A-23­24
Inode table, 557                                 Integer operations, atomic, 286­287
Input/output (I/O)                               Integrated mail systems, 658
   address register (I/OAR), 10                  Integrated strategy for deadlock, 278
   address registers, 10                         Integrity of information, 609­610
   anticipatory scheduler, 511­512               Intel Core i7, 35, 36
   asynchronous, Windows, 513­514                Intel IA32, 579
   basic, 513                                    Intel IA64, 81
   buffering (See Input/output (I/O) buffering)  Interactive scoring, 464­466
   channel, 478                                  Interactive threads, 464
   completion ports, 514                         Interception, 611
   design issues with, 480­483                   Interface-based design, 690
   devices (See Input/output (I/O) devices)      Interface calls, 17-16­20
   direct memory access, 478­480                 Interfaces
   disk cache, 502­506                           application binary, 50, 75
   disk scheduling, 474­516                      application programming, 50, 75, 679
   driver queues, 507                            device driver interface to eCos kernel,
   eCos, 584­586                                 585­586
   evolution of, 477­478                         graphic user interface, 681
   field files, 522­523                          native system, 84
   file system, logical, 481­483, 526            resource, 603
   function, organization of, 477­480            single user, 704
   interrupt, 32, 137, 477                       TinyOS resource, 601­603
   Linux, 509­512                                of typical operating systems, 50

Interfaces (continued)                                       Itanium, 81
user, in intrusion detection systems, 145                    Item population, 20-13
user/computer, 48­50
Internal fragmentation, 343, 354                             J
Internal registers of processor, 9­10                        Jacketing, 168
Internal resources, 278                                      Jackson's Theorem, 20-34­35
Internet Activities Board (IAB), 17-7                        Java Application Server, 173
Internet Engineering Task Force (IETF), 17-10                Java 2 Platform, 173
Internet Protocol (IP), 17-8                                 Java VM, 75
addresses, 17-16                                             Job, serial processing, 52
datagram, 17-14                                              Job control language (JCL), 54
IPv6 and, 17-10­11                                           Joint progress diagram, 260­261
Interprocess communication (IPC), 71, 186, 233               Journaling, 565
Interrupt-driven input/output, 32, 477
Interruptible state, 187                                     K
Interrupt processing, 19­21                                  Kendall's notation, 20-18­21
hardware events of, sequence of, 19­20                       Kernel-level threads (KLT), 168­169
memory for, changes in, 20­21                                Kernel memory allocation
operations of, 20                                               Linux, 386
registers for, changes in, 20­21                                Solaris, 379, 382­384
simple, 19                                                      UNIX, 379, 382­384
Interrupts, 14­23, 56, 100, 137. See also specific types of  Kernels, 51, 83
classes of, 14                                                  class (99-60), 462
direct use of, 577­578                                          control objects, 88
disabled/disabling, 22­23, 210                                  eCos, 585­586
enable flag, 132                                                functions of, 135
handler, 17                                                     input/output manager, 513
and instruction cycle, 15­18                                    Linux (See Linux kernels)
multiple, 21­23                                                 memory allocation (See Kernel memory allocation)
processing (See Interrupt processing)                           microkernels, 71
program flow of control with/without, 14­15                     Microsoft Windows, 83­84
request, 15                                                     mode, 56, 135
Solaris threads, 185­186                                        mode rootkit, 633
stage, 16                                                       modules, 96
WRITE call, 14­15, 18                                           monolithic, 71
WRITE instruction, 15                                           nonprocess, 140­141
Interrupt service routine (ISR), 23, 584                        UNIX systems, 92­93
Intersection, 19-3                                           Key field for sequential files, 530
Intruders, 143­144, 616­619                                  Keylogging, 620, 631
behavior patterns of, 616­619                                Kit (virus generator), 620
criminals, 618                                               Knowledge access rights, 540
hackers, 616­618
insider attacks, 618­619                                     L
Intrusion, 612, 616, 619                                     Language extensions, 664­665
Intrusion detection, 144­145, 653­657                        Large disks, 565
audit records, 655­657                                       Large files, 565
host-based, techniques for, 654­655                          Largest process, 378
principles of, 653­654                                       Last-in-first-out (LIFO) implementation, 128, 130, 20-13
sensors for, 145                                             Last process activated, 378
Intrusion detection systems (IDS), 144­145                   Lazy buddy system algorithm, 383­384
analyzers, 145                                               Least frequently used policy (LFU), 386, 503
hot-based, 144                                               Least recently used (LRU) policy, 31, 363­364, 503­504
network-based, 144­145                                       Lightweight processes (LPW), 182, 183. See also Threads
user interface, 145                                          Lines of memory, 28
Inverted page tables, 349, 350                               Linkage editor, 337­338
I/O. See Input/output (I/O)                                  Linking, 337­339
IOPL (I/O privilege level), 132                                 dynamic linker, 338­339
IP. See Internet Protocol (IP)                                  function of, 338
IPng. See Internet Protocol (IP)                                linkage editor, 337­338
IPv4 header, 17-11                                           Links, 186
IPv6, Internet Protocol and, 17-10­11                        Links file, 554
IRC (Internet Relay Chat) chat networks, 631                 Linux, 94­100, 384­386. See also Linux virtual file system
Iris, 645                                                       (VFS); Linux VServer
_irq, 287                                                       character device drivers, 100
_irqsave, 287                                                   clone () flags, 189

clusters, 706­708                              Load control, 377­379
dentry object, 562, 564                        Loading, 334­337
dynamic linking, 95, 338­339                      absolute, 334­335
file object, 514, 562, 564                        addressing binding, 336
history of, 94­95                                 approaches to, 334
input/output, 509­512                             dynamic run-time, 337
loadable modules, 95­97, 336                      function of, 334
memory barrier operations, 291                    modules, 336
modular structure of, 95­97                       relocatable, 335­336
page cache, 512                                Load sharing, 437­439, 18-3
real-time tasks, 461                           Load-time dynamic linking, 338
scheduling (See Linux scheduling)              Local coverage, 661
semaphores, 290                                Locality of references, 26, 40­42, 344­345
spinlocks, 288                                    principle of, 344
tasks, 186­188                                    spatial, 42
threads, 188­189                                  temporal, 42
2.4, 459                                       Local organization, 309
2.6, 95, 459                                   Local procedure call (LPC) facility, 696
virtual machine process scheduling, 468­469    Local replacement policy, 371
virtual memory (See Linux virtual memory)      Local scope, 372­376
Linux kernels                                  Local subnet scanning, 633
components of, 97­100                          Lock-free synchronization, 297
components of TCP/IP protocol, 17-20           Log file, NTFS, 567
concurrency mechanisms, 285­292                Log file service, 568
memory allocation, 386                         Logical address, 320, 323
Linux networking, 17-21­22                     Logical input/output file system, 481­483, 526
Linux scheduling, 457­461                      Logic bomb, 620, 621
non-real-time scheduling, 459­461              Long memory process, 19-17
real-time scheduling, 457­458                  Long-term existence of files, 522
Linux virtual file system (VFS), 560­564       Long-term scheduling, 396, 397­399
concept of, 562                                Long-term storage, 66
context of, 561                                Loosely coupled multiprocessor system, 431
dentry object, 564                             Loosely coupled service, 691
file object, 564                               Lost calls cleared, 20-37
inode object, 563                              Lost calls delayed, 20-37
object types in, 562                           Lost calls held, 20-37
superblock object, 562­563                     Lotus Domino, 173
Linux virtual memory, 384­386                  Lowest-priority process, 378
page allocation, 385­386                       Low interrupt latency, 583
page replacement algorithm, 386                Low task switching latency, 583
virtual memory addressing, 384­385
Linux VServer                                  M
applications running on, 101                   Mach 3.0, 94
architecture of, 101                           Machine problems (MPs), B-5
chbind, 101                                    Machine readable devices, 476
chcontext, 100­101                             MAC OS Grand Central Dispatch (GCD), 189­192
chroot, 100                                       blocks, 189­190
file system isolation, 100                        codes for, 191
hosting platform, 101                             functions of, 192
network isolation, 101                            purpose of, 189
process isolation, 101                         Mac OS X, 94
root isolation, 101                            Macro viruses, 626, 627­628
token bucket filter (TBF), 468­469             Mailboxes, 213, 235, 592­593
virtual machine architecture, differentiating  Main memory, 9, 10, 28­29, 278
between, 100­101                               Main memory cache, 40
virtual platform, 101                          Maintenance hook, 619
virtual servers, 100­101                       Malicious programs, 620
List directory operation, 537                  Malicious software, 144, 619­623. See also
Livelocks, 200, A-5                               Malware defense
Loadable modules, Linux, 95­97, 336               backdoor, 619­621
absolute, 336                                     logic bomb, 621
characteristics of, 95                            mobile code, 622
kernel modules, 96                                multiple-threat malware, 622­623
module table, elements of, 96­97                  spreading new, 631
Load balancing, clusters, 702                     Trojan horse, 621­622

Malware defense, 657­663                             UNIX SVR4, parameters of, 380­381
antivirus approaches, 657­661                        virtual address, 67
rootkit, countermeasures for, 662­663                virtual memory, 67­68
worms, countermeasures for, 661­662                  Windows, 386­389
Mandatory access control (MAC), 646­647              Memory management unit (MMU), 666
Many-to-many relationships, 169­170                  Memory partitioning, 310­321
Many-to-one relationships, 235                       buddy system, 317­319
Mapping function, cache memory, 30, 31               dynamic partitioning, 314­317
Marker, 18-14                                        fixed partitioning, 310­314
Masquerade attacks, 612, 615                         relocation, 319­321
Masquerader, 143                                     Mesa monitors, 231
Master file table (MFT), 567                         Message buffers, unavailability of, 18-41­44
Matrix of access control, 648                        Message communication
Mean residence time, 20-11                           deadlock in, 18-40
Mean residence time for single-server queues, 20-22  distributed deadlock in, 18-38­44
Mean value, 19-9                                     Message passing, 233­239
Medium-grained parallelism, 433                      addressing, 235­236
Medium-term scheduling, 396, 399­400                 blocking, 234
Memory                                               distributed (See Distributed message passing)
auxiliary, 27                                        implementation of, 234
cache, 27­31, 502­503                                for interprocess communication, design
cards, 643­644                                       characteristics of, 233
compaction of, 314                                   message format, 236­237
dynamic partitioning for, 314­317                    mutual exclusion, 237­239
fault, 137­138                                       nonblocking, 234
for interrupt processing, changes in, 20­21          producer/consumer problem using, solution
layout for resident monitor, 53, 54                  to bounded-buffer, 238
Linux virtual, 384­386                               queuing discipline, 237
main, 9, 10, 28­29, 278                              synchronization, 233­235
physical, 100                                        Messages, 237, 283, 18-6­7. See also Mailboxes
pointers, 109                                        contents attack, release of, 615
processor, 11                                        format, 236­237
protection, 55                                       modification of, 615
real, 343                                            mutual exclusion, 237
rootkit, 633                                         Metamorphic technique, 630
secondary, 27                                        Metamorphic viruses, 627
shared, 283                                          MFT2 files, 567
tables, 126­127                                      Micro-electromechanical sensors (MEMS), 594
two-level, 39­45                                     Microkernels, 71
virtual, 40, 67, 98, 340­389                         Microprocessor
Memory address register (MAR), 9                     cores, 10
Memory buffer register (MBR), 9­10                   Digital Signal Processors (DSPs), 10
Memory hierarchy, 24­27                              evolution of, 10
auxiliary memory, 27                                 Graphical Processing Units (GPUs), 10
hit ratio, 25                                        multicore computer (chip multiprocessor), 35­36
levels of, 24­26                                     and multicore organization, 33­36
locality of reference, 26                            Single-Instruction Multiple Data (SIMD)
secondary memory, 27                                 techniques, 10
in software, 27                                      sockets, 10
two-level memory, 25­26, 39­45                       symmetric (SMP), 33­35
Memory management, 58, 77, 135, 305­330              System on a Chip (SoC), 10
buffer overflow, 326­330                             Microsoft
definition of, 306                                   Common Language Infrastructure, 75
formats for, typical, 346                            DOS, 80
Linux, 384­386                                       Xenix System V, 93
memory partitioning, 310­321                         Microsoft Windows. See also Microsoft Windows 7
in OS, 66­68                                         architecture of, 82­85
paging, 321­325                                      asynchronous input/output, 513­514
read address, 67                                     Azure, 81
requirements of, 307­310                             CE, 81
security issues, 326­330                             client-server model, 85­86
segmentation, 325­326                                cluster server, 704­706
Solaris, 379­384                                     file system, 564­569
storage management responsibilities of, 66           history of, 80­81
terms associated with, 307                           input/output, 512­515
UNIX, 379­384                                        kernel-mode components of, 83­84

Me, 80                                  system, 135
memory management, 386­389              user, 56, 135
98, 80                                  Modification of messages, 615
95, 80                                  Modular programming, 66
NT (3.1), 80                            Modular program structure, 162
object-oriented design, 86­88           Modular structure of Linux, 95­97
operating system for, modern, 81        Modules. See also specific types of
overview of, 80­89                      emulation control, 657
scheduling, 466­468                     of execution, 83­84
Server 2008, 80­81                      input/output, 9, 10
symmetric multiprocessing (SMP),        kernel, 96
threads for, 86                         loadable, Linux, 95, 336
3.0, 80                                 loading, 336
3.1, 80                                 rendering, 174­175
2000, 80                                stackable, 95
Vista, 80, 82                           table, elements of, 96­97
XP, 80                                  Monitor point of view, 53­54
Microsoft Windows 7, 81, 88­89          Monitors, 53, 213, 226­232
characteristics of, 176                 alternate model of, with notify and
concurrency mechanisms of, 294­297      broadcast, 230­232
energy efficiency, 89                   bounded-buffer producer/consumer
engineering improvements, 89            problem, 229
features of, 89                         characteristics of, 227
object-oriented design of, 177­179      concurrency, 226­232
performance improvements, 89            condition variables, 227
processes of, 176­179                   dining philosophers problem, solutions using, 280­281
reliability improvements, 89            Mesa, 231
resources of, 176                       resident, 53, 54
security, 89, 667­672                   security reference, 84
subsystems of, support for, 181         with signal, 227­230
thread objects, 177­179                 simple batch systems, 53
threads, 89, 176­181                    structure of, 228
Middleware, 679, 687­689                virtual machine, 74
architecture of, 688­689                Monolithic kernel, 71
distributed message passing, 693        Motivation, 27, 183, 18-2­3
Migrated process, 18-5­6                MS-DOS, 80
Migration scenario, 18-7                Multicore computer, 35­36
Migration, initiation of, 18-3­5        DDR3 (double data rate) memory controller, 35
Minimal denial-of-service costs, 661    Intel Core i7, example of, 35­36
MIPS, 81, 579                           multithreading of, 171­175
Misappropriation, 612                   operating systems, 77­79
Misfeasor, 143                          QuickPath Interconnect (QPI), 35­36
Misuse, 612                             software on, 171­174
Mobile code, 620, 622                   support, 464­466
Mobile-program systems, 658             valve game software, application example, 174­175
Model parameters, estimating, 20-38­41  Multicore organization, 33­36
sampling, 20-38­41                      Multics, 90
sampling errors, 20-41                  Multiexploit, 630
Modern operating systems (OS)           Multiinstance applications, 174
development leading to, 71­73           Multilevel feedback, 414
distributed operating system, 73        Multilevel queue scheduler, 587
microkernel architecture, 71            Multipartite virus, 622
monolithic kernel, 71                   Multiplatform, 630
multiprocessing, 72­73                  Multiple applications, 199
multiprogramming, 72­73                 Multiple data streams, 565
multithreading, 71­72                   Multiple interrupts, 21­23
object-oriented design, 73              approaches to, 22­23
process, 72                             control with, transfer of, 22
symmetric multiprocessing (SMP), 72­73  disable interrupt, 22­23
Modes                                   interrupt service routine (ISR), 23
control, 135                            time sequence of, 23
decision, 404                           Multiple random variables, 19-12­14
kernel, 56, 135                         Multiple-threat malware, 622­623
nonpreemptive, 404                      Multiprocess applications, 173
preemptive, 404                         Multiprocessing, 72­73, 199
switching, 138­139                      Multiprocessor operating system, 77­79

Multiprocessor scheduling, 431­442, 468                 Ndeps, 97
   design issues, 433­435                               Nearest fit strategy, 544
   granularity, 432­433                                 NEC V8xx, 579
   process scheduling, 435­436                          Negatively correlated, 19-13
   thread scheduling, 437­442                           Negotiation of process migration, 18-7­9
Multiprocessor system, 431                              Nested task flag, 132
Multiprogrammed batch systems, 56­58                    .NET, framework of, 75
   example of, 57                                       Network access layer, 17-7­8
   memory management, 58                                Network-based IDS, 144­145
   multiprogramming (multitasking), 56                  Network operating system, 17-3
   program execution attributes of, sample, 57          Network protocols, 17-1­23
   on resource utilization, effects of, 58              architecture of, 17-3­6
   system utilization of, 56                            definition of, 17-4
   time-sharing systems, differentiating between, 60    elements of, 17-4­5
   uniprogramming, 58                                   Linux networking, 17-21­22
   utilization histograms, 58, 59                       sockets, 17-15­20
Multiprogramming, 56, 72­73, 199                        tasks performed for, 17-3­4
   processors, 434­435                                  TCP/IP protocol architecture, 17-6­15
Multiprogramming levels, 377­378                        Networks, 615­616, 679. See also
Multiserver approach, 20-27                             specific networks
Multiserver model, 20-28­30                             device drivers, 100
Multiserver queues, 20-22­24                            drivers, 513
   assumptions of, 20-18­19                             isolation, 101
   calculations for, 20-30                              protocols, 100
   formulas for, 20-23                                  vehicles for worms, 629
   multiserver model, 20-28­30                          Networks of queues, 20-32­37
   problems with, 20-28­30                              Jackson's Theorem, 20-34­35
   queuing models, 20-16                                packet-switching network, application
   queuing relationships, basic, 20-16­18               to, 20-35­37
   single-server model, 20-28                           partitioning, 20-33
Multitasking. See Multiprogramming                      queues in tandem, 20-33
Multithreading, 71­72, 159­162                          traffic streams, merging of, 20-33
   Microsoft Windows 7, 179                             New process state, 117
   of multicore computer, 171­175                       New : ready process, 118
   native applications, 173                             New : ready/suspend and new : ready process, 124
   process models, 160                                  New Technology File System (NTFS)
   on uniprocessor, 164                                 cluster sizes, 566
Mutex, 213, 215­216, 589. See also Mutual exclusion     components of, 568
Mutex object, 296                                       directory attributes, types of, 567
Mutual exclusion, 200, 206, 237­239, 267, 269, 18-26,   disk storage, concepts of, 565­566
   18-31, A-2­8                                         examples of, 564
   attempts for, A-3                                    features of, 564­565
   Dekker's algorithm, A-2­7                            file structure, 565­567
   failed, 63­64                                        hard links, 565
   hardware support for, 209­213                        journaling, 565
   illustration of, 207                                 large disks, support for, 565
   interrupt disabling, 210                             large files, support for, 565
   lock, 292­293                                        multiple data streams, 565
   Peterson's algorithm, A-7­8                          partition sizes, 566
   requirements for, 209                                recoverability, 564­565, 568­569
   semaphores, 218­219                                  security, 565
   software approaches, A-2­8                           symbolic links, 565
   special machine instructions, 210­213                volume, 565­567
   using messages, 237                                  *next, 96
Mutually exclusive, 19-3                                Next-fit, 316
Mutual waiting, 18-38­41                                Nimda attack, 622­623
                                                        No access rights, 540
N                                                       Node, 699
*name, 96                                               No deadlock, 263
Named pipes, 554                                        Node manager, 705
Naming files, 538­539                                   Nodes into B-trees, insertion of, 535
NASA, 706                                               No-execute bit, 666
National Institute of Standards and Technology (NIST),  Nonblocking, 234, 695
   326, 651                                             Nonpersistent binding, 697
Native audit records, 655                               Nonpreemptive mode, 404
Native system interfaces (NT API), 84                   Nonprocess kernel, 140­141

Non-real-time scheduling, 459­461                     avoidance approaches for, 265
   disadvantages of, 459                              central themes of, 199
   priorities, calculating, 460­461                   commercial, 578
   real-time tasks, relationship to, 461              concurrency, concerns of, 204
   timeslices, calculating, 460­461                   development of, 62­63
Nonuniform memory access (NUMA), 362                  distributed, 73
No preemption condition, 18-31                        eCos (See Embedded Configurable Operating
No preemption deadlock prevention, 267, 269           System (eCos))
Nonpreemptive transfers, 18-10                        embedded (See Embedded operating systems)
Normal distributions, 19-12                           evolution of, 52­62
Normalized response time, 417­418                     functions, 48­52
Notation for queuing systems, 20-14                   information in, protection and security of, 68­69
Notify and broadcast, 230­232                         interfaces of, typical, 50
N-step-SCAN policy, 493­494                           Linux (See Linux)
Nsyms, 97                                             Mac OS X, 94
NTFS. See New Technology File System (NTFS)           memory management in, 66­68
Nucleus. See Kernels                                  Microsoft (See Microsoft Windows)
Null Fork, 168                                        modern, development leading to, 71­73
Null : new process, 118                               multiprocessor/multicore, 77­79
                                                      objectives/functions of, 48­52
O                                                     organization of, 82­84
Object-oriented design, 73                            overview of, 46­101
   categories of, 88                                  process-based, 142­143
   concepts of, 86­88                                 processes, 62­66, 140­143
   Executive of, 87                                   real-time, 443­447, 577
   kernel control objects, 88                         resource management in, 50­51, 69­70
   of Microsoft Windows 7, 177­179                    services provided by, 49
   Security Descriptor (SD) of, 87                    structure, 200
Object-oriented mechanisms, 698                       symmetric multiprocessor, considerations of, 77­78
Objects                                               TinyOS (See TinyOS)
   access rights, 553                                 UNIX (See UNIX systems)
   browser helper, 631                                as user/computer interface, 48­50
   classes, 86                                        virtual machines (VM), 74­76
   control, Windows, 88                            Operating systems (OS) control
   dentry, Linux, 562, 564                            file tables, 127
   dispatcher, 88, 295­296                            input/output tables, 127
   event, Windows, 296, 514                           memory tables, 126­127
   field, 656                                         process tables, 127­128
   file, Linux, 514, 562, 564                         structures of, 126­128
   inode, 562, 563                                 Operating systems (OS) software
   instance, 86                                       cleaning policy, 376­377
   instantiation of, 86                               fetch policy, 361­362
   kernel control, 88                                 load control, 377­379
   manager, 83                                        placement policy, 362
   mutex, 296                                         policies for, 361
   owner of, 670                                      replacement policy, 362­370
   request broker, 693, 698                           resident set management, 370­376
   semaphore, 296                                     virtual memory, 360­379
   superblock, 562­563                             Optimal (OPT) replacement policy, 363
   thread, 177­179                                 Oracle, 173
   types, 562                                      Ordinary file, 553
   waitable timer, 296                             OS. See Operating systems (OS)
Obstruction, 612                                   OS/161, B-2­3
One-to-many relationships, 170­171, 235            Outcome, 19-2
One-to-one relationship, 235                       Overall normalized response time, 417
Online polls/games, manipulating, 632              Overflow flag, 132
Online resources, 705                              Owner of object, 670
ONPROC state, 184
Opcode, 12                                         P
Opening files, 522                                 Packet-switching network, application to, 20-35­37
Open-source Tomcat, 173                            Page/paging, 307, 321­325
Operating mode bits, 132                              address translation in system for, 347, 348
Operating systems (OS). See also Modern operating     allocation, 385­386
   systems (OS)                                       behavior, 345, 354
   achievements of, major, 62­70                      buffering, 369
   aspects of, 48­51                                  cache, Linux, 512

Page/paging (continued)                       Performance comparison, 415­420
characteristics of, 343                       queuing analysis, 415­418
demand, 361                                   simulation modeling, 418­420
directory, 384                                Periodic tasks, 443, 450
fault, 350                                    Permanent blocking, 259
fault frequency (PFF), 375                    Persistent binding, 697
frame data table entry, 380­381               Persistent rootkit, 633
logical addresses, 323                        Personal identification number (PIN), 146, 644
middle directory, 385                         Peterson's algorithm, A-7­8
numbers, 349                                  Phantom deadlock, 18-31
prepaging, 361                                Physical address, 320
replacement, 381­382                          Physical input/output, 522, 525
replacement algorithm, 386                    Physical layer, 17-7
segmentation and, combining, 357­359          Physical memory, Linux, 100
simple, 343                                   Physical organization, 309­310, 483
size, 354­356                                 Pile files, 529­530
system, 379­381                               Pipes, UNIX, 283
table entry, 380­381                          Placement algorithm for memory, 312­317
translation lookaside buffer (TLB), 349­354   Placement policy, 361, 362
virtual memory, 343, 345­356                  Plain spinlocks, 287
Windows, 388­389                              Platform, 582
Page tables, 321, 385                         Plug-and-play manager, Windows, 83
direct vs. associative lookup for, 353        Poisson arrival rate, 416
inverted, 349, 350                            Poisson counting process, 19-22­24
structure of, 347­349                         Poisson distributions, 19-11­12
two-level hierarchical, 348                   Poisson increment process, 19-24
Parallelism, 78­79, 432­433                   Polymorphic technique, 630
coarse, 432­433                               Polymorphic viruses, 627
fine-grained, 433                             Polymorphism, 87
independent, 432                              Portion, 543, 544
medium-grained, 433                           Portion size, 544­545
synchronization, 432                          Ports, 17-13
very coarse-grained, 432­433                  Ports, microkernels and, 71
Parallelized application, 702                 Positively correlated, 19-13
Parallelizing compiler, 702                   POSIX, 80, 84, 188
Parallelizing computation, clusters, 702­703  Posix Programming Interface, B-5
Parameter passing, 697                        PowerBuilder, 684
Parameter representation, 697                 Power manager, Windows, 84
Parametric computing, 702­703                 PowerPC, 81, 579
Parasitic, 144                                Power spectrum. See Spectral density
Parbegin, A-7                                 Preallocation, 543­544
Parent process, 115                           Precleaning, 376
Parity flag, 132                              Precopy strategy, 18-5
Partial program execution, 12­13              Predictability, 401
Partition/partitioning, 20-33                 Preempted process, 119
boot sector, 566­567                          Preemptive mode, 404
dynamic, 314­317                              Preemptive smallest number of threads first, 438
fixed, 310­314                                Preemptive transfers, 18-10
memory, 310­321                               Prepaging, 361
size, 310­312, 566                            Pre-thread static storage, 160
Passive attacks, 615                          Printer interrupt service routine (ISR), 23
Passive standby, 700, 701                     Printers, 509
Password, 146                                 Priorities, 449
Password-based authentication, 640­643        ceiling, 457
Pathname, 538                                 classes, 463, 467
Payload, 623                                  enforcing, 401
Payload-classification-based worm             inheritance, 456­457
containment, 662                              level, 109
Pentium EFLAGS Register bits, 132             Linux, calculating, 460­461
PeopleSoft, 173                               policy, 490
Percentiles, calculating, 20-25­26            priority queuing, 402
Performance                                   process, 466­468
disk cache, issues of, 505­506                queues, 20-30­32
files, grades of, 529                         queuing, 402
improvements in Microsoft Windows 7, 89       thread, 466­468
of software on multicore computer, 171­174    use of, 402­403

Priority inversion, 455­457                     resources, 278
priority ceiling, 457                           scheduling, 404, 435­436
priority inheritance, 456­457                   security issues, 143­147
unbounded, 455                                  with smallest resident set, 378
Privacy, 609                                    spawning, 115
Privileged instructions, batch systems, 55      state of (See Process state)
Privileges, 669                                 state transitions, 396
Probability, 19-2­8                             structure, 183
axiomatic definition of, 19-2­5                 suspension, 378­379
Bayes's Theorem, 19-6­8                         switching, 137­139
classical definition of, 19-5­6                 synchronization, 432
conditional, and independence, 19-6             table entry, 150
definition of, 19-2­6                           tables, 127­128
relative frequency definition of, 19-5          termination of, 115­116
Problem statement, A-8                          threads and, 66, 158­164, 169, 182
Procedure call, asynchronous, 514               traces of, 111­113
Process and channel graph, 18-15                UNIX SVR4 process management, 147­152
Process-based operating systems, 142­143        virtual machines (VM), 75
Process control, 134­139                        Process interaction, 205­209
execution, modes of, 134­136                    awareness, 205
information, 129­130, 131, 133                  communication, 208­209
operating system, structures of, 126­128        resources, 206­207
process attributes, 129­133                     sharing, 207­208
process creation, 136                           Process migration, 18-2­10
process location, 128­129                       eviction, 18-9­10
process switching, 137­139                      mechanisms, 18-3­7
structures of, 128­134                          motivation, 18-2­3
UNIX System V Release 4 (SVR4), 151­152         negotiation of, 18-7­9
Process control blocks, 109­110                 nonpreemptive transfers, 18-10
elements of, 129­130                            preemptive transfers, 18-10
role of, 133­134                                Process migration mechanisms, 18-3­7
simplified, 110                                 messages, 18-6­7
Process(es), 72, 98, 106­152                    migrated process, 18-5­6
for addressing, requirements of, 308            migration scenario, 18-7
affinity, 464, 466                              migration, initiation of, 18-3­5
attributes of, 129­133                          signals, 18-6­7
characteristics of, 158                         Process operation latencies (s), 168
components of, 64                               Processors, 8. See also Central processing
concept of, 62­66, 108­109, 158                 unit (CPU); specific types of
control (See Process control)                   functions of, 9
creation of, 114­115, 136                       internal registers of, 9­10
definition of, 62, 108­110                      point of view, 53­54
description of, 126­134                         scheduling, types of, 397­400
dispatching, 435                                specific context, 187
elements of, 109, 128                           state information, 129­130, 131
errors in, causes of, 63­64                     utilization, 401
execution of, mechanisms for interrupting, 137  Process state, 65, 110­125
identification, 129­130, 131                    changing of, 139
identifier, 349                                 five-state model, 116­120
image, 128, 149­150                             suspended processes, 121­125
implementation of, 65                           two-state process model, 112­114
initiation denial, deadlock avoidance           ULT, relationship with, 166
strategy, 270­271                               UNIX System V Release 4 (SVR4),
input/output, 11                                147­149
isolation, 66, 101                              Process-thread manager, Windows, 84
with largest remaining execution window, 378    Producer/consumer problem
location of, 128­129                            bounded-buffer, 229, 238
management of, 64­65                            semaphores, 219­224
memory, 11                                      Profile based detection, 655
migration, 704                                  Program code, 109
of operating systems (OS), 62­66, 140­143       Program counter (PC), 11, 20, 109
priorities, 466­468                             Program execution attributes, 57
process control blocks and, 109­110, 133­134    Program flow of control with/without
processing time, 449                            interrupts, 14­15
processor affinity, 177                         Programmed input/output, 31­32, 477
queues, 242                                     Programming language, 663­664

Programming projects, B-4­B-6                         level 1, 499­500
   additional, B-5                                    level 2, 500
   small, B-5­B-6                                     level 3, 500­501
   textbook-defined projects, B-4­B-5                 level 4, 501­502
Program operation, 64                                 level 5, 502
Program status word (PSW), 19                         level 6, 502
Project MAC, 60, 90                                   proposal for, 495
Propagation phase, 624                                software, 514­515
Protection, 308­309                                   Random process. See Stochastic processes
   access control and, 66                             Random scanning, 632
   sharing and, 359­360                               Random scheduling, 490
Protocol, 17-4                                        Random variables, 19-8­14
Protocol data units (PDUs), 17-13                     density function, 19-8­9
Pseudocodes, 5                                        distribution function, 19-8­9
Pthread libraries, 188                                distributions, 19-9­12
Pull mechanism, 466                                   multiple, 19-12­14
Purpose-built embedded operating systems, 578­579     Rate halting, 662
Push mechanism, 466                                   Rate limiting, 662
Pvmsync, 708                                          Rate monotonic scheduling, 452­454
                                                      Ratio close to 1, 20-20
Q                                                     Ratio greater then 1, 20-21
Quality of service (QoS), 20-13                       Ratio less than 1, 20-20
Queues                                                Raw sockets, 17-16
   behaviors, 20-3­7                                  Reactive operation, embedded systems, 577
   character, UNIX SVR4, 508                          Read address, 67
   dispatch, 462                                      Read_control access, 671
   driver input/output, 507                           Readers/writers
   in tandem, 20-33                                   lock, 294
   networks of, 20-32­37                              mechanisms, 239­243
   parameters, 20-11­12                               priorities of, 240­243
   process, 242                                       process queues, state of, 242
   single-server, formulas for, 416                   semaphores, 290
   size, 20-13                                        spinlocks, 288­289
   structure, 464                                     using semaphores, solution to, 240, 241
   with priorities, 20-30­32                          Reading access rights, 540
Queuing                                               Reading assignments, B-6
   diagram for scheduling, 399                        Reading files, 522
   discipline, 237                                    Read operation, 29­30
   priority, 402                                      Ready : exit process, 119
Queuing analysis, 415­418, 20-1­41                    Ready process state, 122
   examples of, 20-24­30                              Ready : ready/suspend process, 123
   importance of, 20-8­10                             Ready : running process, 118
   model parameters, estimating, 20-38­41             Ready state, 117, 179
   multiserver queues, 20-22­24                       Ready/suspend process, 123
   queue behaviors, example of, 20-3­7                Ready/suspend : ready process, 123
   queues, 20-30­37                                   Ready time, 448
   queuing models, 20-10­19, 20-37                    Real address, 341
   single-server queues, 20-20­22                     Real memory, 343
Queuing models, 20-10­19, 20-37                       Real time
   assumptions, 20-18­19                              class (159-100), 461­462
   multiserver queue, 20-16                           operating systems, 443­447, 577
   queuing relationships, basic, 20-16­18             priority classes, 467
   single-server queue, 20-10­15                      tasks, Linux, 461
Queuing networks, elements of, 20-34                  user, 463
Queuing relationships, basic, 20-16­18                Real-time scheduling, 430­470
Queuing systems, notation for, 20-14                  algorithms for, 447
QuickPath Interconnect (QPI), 35­36                   deadline scheduling, 448­452
                                                      history of, 442­443
R                                                     Linux, 457­458
Race conditions, 200, 204, A-8­15                     and multiprocessor, 430­470
   problem statement, A-8                             priority inversion, 455­457
RAID (redundant array of independent disks), 494­502  rate monotonic scheduling, 452­454
   characteristics of, 494                            real-time operating systems,
   for high data transfer capacity, 498­499           characteristics of, 443­447
   for high input/output request rate, 499            types of, 448
   level 0, 495­499                                   Receive primitive, 233­235

Record blocking, 541­543                            Replay attacks, 615
fixed blocking, 541                                 Report assignments, B-6
methods of, 542                                     Repudiation, 612
variable-length spanned, 541                        Research projects, B-6
variable-length unspanned, 542                      Reserved state, 388
Records, 523                                        Resident monitor, 53, 54
audit, for intrusion detection, 655­657             Resident set, 342
detection-specific audit, 655                       size, 370
native audit, 655                                   Resident set management, 362, 370­376
Recoverability, 564­565, 568­569                    fixed allocation, local scope, 371
Recovery, 277­278                                   replacement scope, 371
Redundant array of independent disks. See RAID      resident set size, 370
(redundant array of independent disks)              variable allocation, 372­376
*refs, 97                                           Resiliency, 661
Registers                                           Resource allocation, distributed deadlock in, 18-30­38
address, 9, 10                                      deadlock avoidance, 18-33­34
context, 150                                        deadlock detection, 18-34­38
control and status, 130, 131                        deadlock prevention, 18-32­33
index, 64­65                                        Resources, 704­705
input/output address, 10                            balancing, 401
instruction, 11                                     competition among processes for, 206­207
internal, of processor, 9­10                        configure interface, 603
for interrupt processing, changes in, 20­21         interface, 603
memory address, 9                                   manager, 50­51, 706
memory buffer, 9­10                                 of Microsoft Windows 7, 176
Pentium EFLAGS, 131­132                             ownership, 158 (See also Process/processes)
Regular file, 553                                   requested interface, 603
Relational database, 679                            requirements, 449
Relative address, 320                               utilization, 58
Relative frequency definition of probability, 19-5  Resources, allocation of
Release of message contents attack, 615             denial, 271­275
Reliability, 78, 89, 444, 551, 694­695              graphs, 266­267
Relocatable loading, 335­336                        Resources, management of, 69­70
Relocation, 307­308, 319­321                        elements of, major, 69­70
Remote control facility, 632                        factors of, 69
Remote execution capability, 629                    functional description of, 70
Remote login (rlogin), 17-15                        round-robin, 70
Remote login capability, 629                        Resource-specific interface, 603
Remote procedure call (RPC), 163, 695­698           Resource-usage field, 656
advantages of, 695                                  Response time, 401
asynchronous, 698                                   normalized, 417­418
client/server binding, 697                          overall normalized, 417
mechanism for, 696                                  projected vs. actual, 20-9
object-oriented mechanisms, 698                     Responsiveness, 444
parameter passing, 697                              Resume flag, 132
parameter representation, 697                       Retinal pattern, 645
synchronous, 698                                    Reusable resources, deadlock and, 263­264
Removal of virus, 657                               Robot. See Bots
Rendering module, 174­175                           Role-based access control (RBAC),
Replacement, frequency-based, 504                   647, 651­653
Replacement algorithms, 30, 31, 317, 363­369        Root isolation, 101
clock page, 368                                     Rootkits, 620, 633­635
clock policy, 365­366                               classification of, 633
first-in-first-out (FIFO) policy, 364               countermeasures for, 662­663
fixed-allocation, local page, 367                   installation of, 633­634
four page, behavior of, 364                         system-level call attacks, 634­635
least recently used (LRU) policy, 363­364           Rotational delay, 487, 488­489
optimal policy, 363                                 Rotational positional sensing (RPS), 488
Replacement policies, 361, 362­370. See also        Round-robin techniques, 70, 116, 407­410
specific types of                                   Router, 17-8
algorithms for, basic, 363­369                      RSX-11M, 80
and cache size, 369­370                             Running : blocked process, 119
concepts of, 362                                    Running : exit process, 118
frame locking, 363                                  Running process state, 109, 117, 180, 184, 187
page buffering, 369                                 Running : ready process, 118­119
Replacement scope, 371                              Running : ready/suspend process, 124

Run-time defenses, 666­667                    highest ratio next, 413
   address space randomization, 667           round robin, 407­410
   executable address space protection, 666   shortest process next, 410­411
   guard pages, 667                           shortest remaining time, 411­413
Run-time dynamic linking, 339                 S.count value, 219
                                              Search operation, 537
S                                             Secondary memory, 27
Safe coding techniques, 664                   Secondary storage management, 543­551
Safe libraries, 664­665                       file allocation, 543­547
Safe states, resource allocation, 271­272     free space management, 547­550
Salt value of passwords, 641                  reliability, 551
Sample space, 19-3                            volumes, 550
Sampling, 20-38­41                            Second moment, 19-9
   distribution of the mean, 20-38            Second-order statistics, 19-15­17
   errors, 20-41                              Sector, 565
Saved thread context, 160                     Security Descriptor (SD), 87
Scaling, 72                                   Security ID (SID), 668
Scanning, 632                                 Security reference monitor, 84
SCAN policy, 493                              Security Requirements for Cryptographic
Scanrate, 381                                 Modules, 651
Scheduled blocks, 190                         Security requirements triad, 609
Scheduler, 98                                 Security systems
Scheduling, 52, 77, 158                       concepts of, 608­610
   control and, 482­483                       in Microsoft Windows 7, 89
   criteria for, 401                          scope of, 613
   deadline, 448­452                          threats to, 607­635
   disk, 474­516                              Security threats, 607­635, 639­672
   dynamic, 442                               access control, 646­653
   dynamic best effort, 448                   assets and, 613­616
   dynamic planning-based, 448                attacks and, 610­612
   feedback, 414                              authentication, 640­646
   gang, 439                                  bots, 631­633
   input/output, 396                          buffer overflow attacks, 663­667
   levels of, 398                             countermeasures for, 144­147
   Linux, 457­461                             intruders, 616­619
   Linux virtual machine process, 468­469     intrusion detection, 616, 619, 653­657
   long-term, 396, 397­399                    malicious software, 619­623
   medium-term, 396, 399­400                  malware defense, 657­663
   multiprocessor, 431­442                    memory management, 326­330
   non-real-time, 459­461                     New Technology File System (NTFS), 565
   process, 404, 435­436                      of process, 143­147
   processor, types of, 397­400               rootkits, 633­635
   and process state transitions, 396         system access threats, 143­144
   queuing diagram for, 399                   viruses, 623­628
   random, 490                                Windows 7 security, 667­672
   rate monotonic, 452­454                    worms, 628­630
   real-time, 430­470                         Seek time, 487, 488
   short-term, 396, 400                       Segmentation, 325­326
   static priority-driven preemptive, 448     address translation in, 357, 358
   static table-driven, 447                   advantages of, 356
   thread, 437­442                            characteristics of, 343
   types of, 396                              implications of, 356
   uniprocessor, 395­425                      organization of, 356­357
   UNIX, traditional, 422­424                 paging and, combining, 357­359
   UNIX FreeBSD, 463­466                      segments, protection relationship between, 359
   UNIX SVR4, 461­463                         simple, 343
   Windows, 466­468                           virtual memory, 343, 356­357
Scheduling algorithms, 400­422                Segment pointers, 307, 325, 359
   fair-share scheduling, 420­422             Selection function, 403
   performance comparison, 415­420            Semaphores, 213­226, 283­284, 289­290, 293
   priorities, use of, 402­403                binary, 213, 215, 289­290
   scheduling policies, alternative, 403­415  counting, 215, 222, 289­290
   short-term scheduling criteria, 400­402    currency mechanisms, common, 213
Scheduling policies, 403­415                  definition of, consequences of, 214­215
   feedback, 413­415                          dining philosophers problem, solutions using, 280
   first-come-first-served (FCFS), 407        eCos thread synchronization, 589

first-in-first-out (FIFO) process, 216              kernel mode, 56
general, 215, 222                                   monitor, 53
implementation of, 224­226                          points of view of, 53­54
Linux, 290                                          user mode, 56
mechanism of, example of, 217                       Simple interrupt processing, 19
mutex, 215­216                                      Simple Mail Transfer Protocol (SMTP),
mutual exclusion, 218­219                           17-14­15
object, Windows, 296                                Simple paging, 343
producer/consumer problem, 219­224                  Simple segmentation, 343
readers/writers, 240, 241                           Simulation modeling for scheduling, 418­420
reader-writer, 290                                  Simulation result, 419
s.count, value of, 219                              Simulations, B-3­B-4
shared data protected by, process accessing, 219    Simultaneous access for file sharing, 541
strong, 216                                         Simultaneous concurrent process, 77
as variable, operations of, 214                     Simultaneous concurrent threads, 77
weak, 216                                           Single buffer, 484­486
Semantics, 17-4                                     Single control point, 703
Semaphores, A-8­15                                  Single entry point, 703
Sensors for intrusion detection, 145                Single file hierarchy, 703
Separate servers, 701                               Single input/output space, 704
Sequential files, 530                               Single instance service, 691
indexed, 530­531                                    Single-Instruction Multiple Data (SIMD)
key field for, 530                                  techniques, 10
processing of, 523­524                              Single job-management system, 704
Sequential search, 530                              Single memory space, 703
Serial processing, 52­53                            Single process space, 704
Server-based processing, 683                        Single-server approach, 20-27
Servers                                             Single-server model, 20-28
client/server computing, 678­679                    Single-server queues, 416, 20-20­22
connected to disks, 701                             characteristics of, 20-13­15
share disks, 701                                    features of, 20-12­13
Service-oriented architecture (SOA), 689­691        formulas for, 20-19
Service(s)                                          mean residence time for, 20-22
broker, 690                                         parameters for, 20-10
processes, Windows, 84                              queue parameters of, 20-11­12
provider, 690                                       queuing models, 20-10­15
requestor, 690                                      queuing system structure for, 20-10
Set of data, 109                                    Single-system image, 703
Setup time, 52­53                                   Single-threaded process models, 160
Shadow copies, volume, 515                          Single user interface, 704
Shared data protected, 219                          Single-user multiprocessing system, 161­162
Shared disk approach, 701                           Single virtual networking, 703
Shared memory multiprocessor, 283                   Size, 96
Shared nothing, 701                                 Slab allocation, 386
Shared resources, 602                               SLEEP state, 184
Sharing files, 207­208, 309, 522                    Slim read-writer locks, 297
Shortest process next (SPN) scheduling,             Slots of memory, 28
410­411                                             Smallest number of threads first, 438
Shortest remaining time (SRT) scheduling,           Small memory footprint, 583
411­413                                             Small programming projects, B-5­B-6
Shortest-service-time-first (SSTF) policy, 490­493  Smart cards, 644­645
Short memory process, 19-17                         SMP. See Symmetric multiprocessor (SMP)
Short-term scheduling, 396, 400­402                 Snapshot, 18-13
Siebel CRM (Customer Relationship Manager), 173     example of, 18-16
Signaling/signals, 98, 284, 18-6­7                  Sniffing traffic, 631
event object, 514                                   Sockets, 10, 17-15­20
file object, 514                                    application programming interface (API), 17-16
monitors with, 227­230                              communication, 17-18
Signal-Wait, 168                                    concept of, 17-15
Signature, 646                                      connection, 17-17­18
Signature-based worm scan filtering, 661            datagram, 17-16
Signature detection, 655                            interface calls, 17-16­20
Sign flag, 132                                      programming, 17-15
Simple batch systems, 53­56                         raw, 17-16
hardware features of, 55­56                         setup, 17-17
job control language (JCL), 54                      stream, 17-16

Sockets interface calls, 17-16­20             committed, 388
for connection-oriented protocol, 17-19       execution, 186
socket communication, 17-18                   exit process, 117
socket connection, 17-17­18                   FREE, 184
socket setup, 17-17                           interruptible, 187
Soft affinity policy, 181                     new process, 117
Soft real-time task, 443                      ONPROC, 184
Software                                      process, 65, 110­125
behavior-blocking, 659­661                    of processes, 65, 110­125
Beowulf, 707­708                              ready, 117, 179
malicious, 144, 619­623                       ready process, 122
memory hierarchy in, 27                       reserved, 388
RAID, 514­515                                 running process, 109, 117, 180, 184, 187
security threats to, 613­614                  safe, resource allocation, 271­272
valve game, 174­175                           SLEEP, 184
Solaris                                       spawn, 162
memory management, 379­384                    standby, 179­180
process structure of, 183                     stopped, 184, 188
10, 94                                        terminated, 180
three-level thread structure of, 183          thread, 162­164
Solaris threads                               thread execution, 160
SMP management of, 182­186                    transition, 180
states of, 184­185                            uninterruptible, 187
synchronization primitives, 292­294           unsafe, 271
Spammer programs, 620                         waiting, 180
Spamming, 631                                 zombie, 184, 188
Spanned blocking, variable-length, 541­542    Static biometrics, 146
SPARC, 579                                    Static priority-driven preemptive
Sparks, Matt, B-5                             scheduling, 447, 448
Spatial locality, 42                          Static protocol, 644
Spawn state, 162                              Static table-driven scheduling, 447
Special capabilities, utilization of, 18-3    Stationary stochastic processes, 19-17
Special file, 554                             Stealth viruses, 627
Special machine instructions, 210­213         Stochastic processes
compare&swap instruction, 210­212             elementary concepts of, 19-14­26
disadvantages of, 212­213                     ergodicity, 19-24­26
exchange instruction, 212                     first-order statistics, 19-15­17
properties of, 212­213                        independent increments, 19-19­24
Special reader, 644                           second-order statistics, 19-15­17
Special system processes, Windows, 84         spectral density, 19-17­19
Specific user class, 541                      stationary, 19-17
Spectral density, 19-17­19                    Stopped state, 184, 188
Spinlocks, 213, 287­289                       Storage management, 66
basic, 287­288                                access control, protection and, 66
eCos thread synchronization, 593­594          automatic allocation/management, 66
Linux, 288                                    long-term storage, 66
plain, 287                                    modular programming, support of, 66
reader-writer, 288­289                        process isolation, 66
Spin waiting, 212, A-2                        Store-and-forward deadlock, 18-42
Sprite, 686­687                               Stream communication, 17-18
SQL Windows, 684                              Streamlined protection mechanisms, 577
SSH (Secure Shell), 17-15                     Stream-oriented device, 484
Stackable modules, Linux, 95­96               Stream sockets, 17-16
Stacking protection mechanisms, 665­666       Stripe, 498
Stack overflow, 327                           Strong semaphores, 216
Stack values, 328                             Structured applications, 199
Standard C Libraries, 586                     Structured programming (SAL), 40
Standard deviation, 19-9                      Structured query language (SQL),
Standby state, 179­180                        679, 682, 688
Starting deadline, 448                        Subject access rights, 553
Starvation, 200, 206, 213                     Subject field, 655
Starvation free, 18-26                        Subtask structure, 449
States, 271, 18-13. See also specific states  Sun Microsystems, 93, 94
available, 388                                SunOS, 93
blocked, 119, 147­148                         Superblock object, 562­563
blocked/waiting process, 117                  Superblocks, 557

Superior price performance, 699                     T
Supervisor call, 138                                Tape drives, 509
Support functions, 135                              Tasks, 598. See also Process/processes
Suspended processes states, 121­125                    aperiodic, 451
characteristics of, 124­125                            deadline scheduling for, 448­451
purposes of, 125                                       hard real-time, 443
states of, 122­123                                     Linux, 186­188
swapping, 121­124                                      periodic, 450
transitions of, 122, 123­124                           real-time, Linux, 461
SVR4. See UNIX System V Release 4 (SVR4)               soft real-time, 443
Swap, 211                                           TCP header, 17-9
Swappable space, 278                                TCP segment, 17-14
Swapping process states, 121­124                    TCP/IP protocol architecture, 17-6­15
Swap-use table entry, 380­381                          applications of, 17-14­15
Switching process, 137­139                             concepts of, 17-12
Sybase Inc., 684                                       Internet Protocol (IP), and IPv6, 17-10­11
Symbolic links file, 554, 565                          layers, 17-7­8
Symmetric multiprocessor (SMP),                        Linux kernel components of, 17-20
33­35, 72­73                                           operation of, 17-12­14
advantages of, 33­34                                   protocol data units (PDUs) in, 17-13
availability, 72                                       User Datagram Protocol (UDP) and, 17-8­10
characteristics of, 33                              TELNET, 17-15
cluster, differentiating between, 704               Temporal locality, 42
definition of, 33                                   Terminals, 509
incremental growth, 72                              Termination of process states, 180
multicore support and, 464­466                      Textbook-defined projects, B-4­B-5
organization of, 34­35                              Thin client, 685
OS considerations of, 77­78                         Thrashing, load control, 344
scaling, 72                                         Threading granularity options, 174
threads for, 86                                     Threads, 66, 157­192, 585. See also specific types of
*syms, 97                                              benefits of, 161
Synchronization, 77, 234­235                           bottom-half kernel, 463
design characteristics of, 233                         execution state, 160
eCos thread, 589                                       functionality of, 162­164
granularity, 432                                       interactive, 464
improper, 63                                           kernel-level (KLT), 168­169, 182
lock-free, 297                                         Linux process and, management of, 186­189
message passing, 233­235                               MAC OS Grand Central Dispatch (GCD), 189­192
processes, 432                                         management of, 186­189
Solaris, thread primitives, 292­294                    many-to-many relationships of, 169­170
of threads, 164                                        Microsoft Windows 7, improvements in, 89
Synchronized access, 670                               migration, 466
Synchronous input/output, Windows, 513­514             multithreaded process models, 160
Synchronous RPC, 698                                   multithreading, 159­162, 171­175
Syntax, 17-4                                           objects, 177­179
System call table                                      one-to-many relationships of, 170­171
modification of, 634                                   operations associated with change in, 162
redirecting, 635                                       priorities, 466­468
targets, 634                                           processes and, 158­164, 169, 182
System-level call attacks, 634­635                     process operation latencies (s), 168
System-level context, 150                              processor affinity, 177
System on a Chip (SoC), 10                             remote procedure call (RPC) using, 163
System oriented, other criteria, 401                   single-threaded process models, 160
System oriented, performance related criteria, 401     in single-user multiprocessing system, 161­162
System(s)                                              for SMP, 86
access control list (SACL), 670                        Solaris, and SMP management, 182­186
access threats, 143­144                                states of, 162­164
bus, 9                                                 synchronization, 164, 589­594
calls, Linux, 98                                       top-half kernel, 463
files, 567                                             types of, 164­171
integrity, 609                                         user-level (ULT), 164­168, 182
ISA, 50                                                Windows 7, and SMP management, 176­181
mode, 135                                           Thread scheduling, 437­442
response time, 63                                      approaches to, 437
utilization of, 56                                     dedicated processor assignment, 440­441
virtual machines (VM), 76                              dynamic scheduling, 442

Thread scheduling (continued)                        Tree representation of buddy system, 319
gang scheduling, 439                                 Tree-structured file directory, 538, 539
load sharing, 437­439                                Trial, 19-5
Thread states, 162­164                               Trigger, 623
of Microsoft Windows 7, 179­180                      Triggering phase, 624
of Solaris, 184­185                                  Trivial File Transfer Protocol (TFTP), 17-5
Three-level interrupt mode, 584­585                  TRIX, 170
Three-level thread structure, Solaris, 183           Trojan horse, 620, 621­622
Three-tier client-server architecture, 685­686       Turnaround time (TAT), 401, 404, 419
Threshold detection, 655                             Two-handed clock algorithm, 381
Threshold random walk (TRW) scan detection, 662      Two-level hierarchical page table, 348
Throughput, 401                                      Two-level memory
Tightly-coupled multiprocessor, 20-26­27                characteristics of, 39­45
Tightly coupled multiprocessor system, 431              locality, 40­42
Time average, 19-25                                     operation of, 42
Time, creation of, 187                                  performance of, 25­26, 42­45
Timeliness, 661                                      Two-priority categories, 416
Timer interrupts, 89, 587                            Two-state process model, 112­114
Timers, batch systems, 55, 187
Time sequence of multiple interrupts, 23             U
Time-shared (59-0) class, 462                        U area, 150­151
Time sharing, 60                                     ULT. See User-level threads (ULT)
Time-sharing systems, 58­62                          Ultrafast spreading, 630
batch multiprogramming, differentiating between, 60  Unauthorized disclosure, 610
Compatible Time-Sharing System (CTSS), 60­61         Unblock state, 162
memory requirements of, 60­61                        Unbounded priority inversion, 455
time sharing, 60                                     Unbuffered input/output, 508­509
time slicing, 60                                     Uncorrelated, 19-13
Time-sharing user, 463                               Underlying distribution, 20-38
Timeslices/timeslicing, 60, 137, 407, 460­461        Uninterruptible state, 187
Time-stamp field, 656                                Union, 19-3
Timestamping algorithm, 18-22­23                     Uniprocessor
Timing, 17-4                                            multithreading on, 164
Timing comparison, 489                                  scheduling, 395­425
TinyOS, 594­603                                      Uniprogramming systems, 58
components of, 596­599                               University of California at Berkeley, 495
configurations for, examples of, 600­601             University of Illinois at Urbana-Champaign, B-5
goals of, 595­596                                    UNIX BSD (Berkeley Software Distribution), 90
resource interface, 601­603                          UNIX FreeBSD, 94
scheduler, 599­600                                      files, structure of, 555
wireless sensor networks, 594­595                       inodes, structure of, 555
TLB. See Translation lookaside buffer (TLB)             scheduling, 463­466
Token, 146                                           UNIX systems, 90­92, 553­560. See also specific systems
Token-based authentication, 643­645                     access control lists, 559­560
Token bucket filter (TBF), 468­469                      architecture of, 91
Token loss, 644                                         Berkeley Software Distribution (BSD), 94
Token-passing algorithm, 18-29                          buffer cache, organization of, 508
Token-passing approach, 18-28­30                        C implementation of, 90
Top-half kernel threads, 463                            concurrency mechanisms of, 281­285
Topological scanning, 633                               description of, general, 91­92
Torvalds, Linus, 94                                     devices, types of, 509
Trace of process, 111                                   directories, 557
Traffic analysis attacks, 615                           file access control, 558­559
Traffic streams, merging of, 20-33                      file allocation, 556­557
Transfer time, 487                                      files, 553­555
Transition of process state, 180                        history of, 90
Translation lookaside buffer (TLB), 349­354             inodes, 554­556
cache operation and, 353                                input/output, structure of, 507
operation of, 352                                       kernel, 92, 93
Transparency, 661                                       license for, 90
Transport layer, 17-8                                   memory management, 379­384
Transport vehicles, 630                                 modern, 92­94
Trapdoor. See Backdoor                                  password-based authentication in, implementation of,
Trap flag, 132                                          642­643
Traps, 100, 138                                         process structure of, 183

   scheduling, traditional, 422­424               Variable-allocation replacement
   signals of, 285                                policy, 370
   Solaris 10, 94                                 global scope, 372
   System III, 90                                 local scope, 372­376
   System V, 90                                   Variable-interval sampled working set
   traditional, 90­92                             (VSWS) policy, 375­376
   traditional, file access control, 558­559      Variable-length spanned, 541
   Version 6, 90                                  Variable-length unspanned, 542
   Version 7, 90                                  Variable priority classes, 467
   volume structure, 557                          Variant, 582
UNIX System V Release 4 (SVR4), 93­94             Variance, 19-9
   buffer cache, 507­508                          VAX/VMS, 80
   character queue, 508                           Venn diagrams, 19-4
   devices, types of, 509                         Verification step of authentication, 145
   dispatch queues, 462                           Very coarse-grained parallelism, 432­433
   input/output, 506­509                          VFS. See Linux virtual file system (VFS)
   parameters of, 380­381                         Virtual addresses
   process control of, 151­152                    map, 387­388
   process description of, 149­151                memory management, 67
   process image of, 149­150                      space, 160, 341
   process management, 147­152                    Virtual interrupt flag, 132
   process states of, 147­149                     Virtual interrupt pending, 132
   process table entry of, 150                    Virtualization, 74­75
   scheduling, 461­463                            Virtualized resources, 602
   U area, 150­151                                Virtual machine monitor (VMM), 74
   unbuffered input/output, 508­509               Virtual machines (VM), 74­76
Unreliability, 694­695                            application of, 75
Unsafe state, resource allocation, 271, 274       architecture of, 75­76
Unspanned blocking, variable-length, 542­543      concept of, 74
Update directory operation, 537                   definition of, 341
Updating access rights, 540                       hosted, 76
Usecount, 96                                      Java, 75
User applications, Windows, 84                    Linux VServer architecture, differentiating
User control, 444                                 between, 100­101
User Datagram Protocol (UDP), 17-8­10             multicore computer, OS considerations of, 79
User dissatisfaction, 644                         operating system, 75
User groups class, 541                            process, 75
User identification (ID), 558                     system, 76
User interfaces, 48­50, 145                       terminology of, 341
User ISA, 50                                      and virtualization, 74­75
User-level context, 149­150                       virtual machine monitor (VMM), 74
User-level threads (ULT), 164­168                 Virtual memory, 40, 67, 98, 340­389
   advantages of, 167­168                         addressing, 68, 384­385
   and KLT, combined with, 169                    concepts of, 67
   occurrences of, 165, 167                       hardware/control structures of, 348­360
   process states, relationship with, 166         locality and, 344­345
User mode, 56, 135                                management, 384­389
User-mode processes, 84­85                        manager, 84, 568
   environmental subsystems, 84                   operating system software, 360­379
   execution within, 141­142                      paging, 343, 345­356
   service processes, 84                          protection, sharing and, 359­360
   special system processes, 84                   segmentation, 356­357
   user applications, 84                          user-mode processes in, 133
   in virtual memory, 133                         Virtual 8086 mode, 132
User mode rootkit, 633                            Virtual platform, 101
User-oriented, other criteria, 401                Virtual servers, 100­101
User-oriented, performance related criteria, 401  Viruses, 620, 623­628
User's identity authentication, 146               classification of, 626­627
User-visible registers, 130                       compression, 625
Usurpation, security threats of, 612              e-mail, 628
Utilization histograms, 58, 59                    encrypted, 626
                                                  initial infection, 626
V                                                 macro, 626, 627­628
Valve game software, 174­175                      metamorphic, 627
Variable, operations of, 214                      nature of, 623­624

Viruses (continued)                 Win32, 84
   phases of, 624                   Windowing/graphics system, 83
   polymorphic, 627                 Windows. See Microsoft Windows
   simple, 625                      Windows shares, 623
   stealth, 627                     Wireless sensor networks (WSN), 594­595
   structure of, 623, 624­626       Working directories, 539
   virus kits, 627                  Working set strategy, 372
Virus kits, 627                     Worms, 620, 628­630
Virus signature scanner, 657           countermeasures for, 661­662
VM. See Virtual machines (VM)          functions of, 629
Voice, 646                             network vehicles for, examples of, 629
Volume, 550, 565­567                   propagation model, 629
   encryption, 515                     technology for, state of, 630
   layout, 566­567                     worm propagation model, 629
   master file table, 567           Wound-wait method, 18-33
   shadow copies, 515               WRITE call, 14­15, 18
   structure, UNIX, 557             Write_DAC access, 671
   volume layout, 566­567           WRITE instruction, 15
                                    Write_owner access, 670
W                                   Write policy, cache memory, 30, 31
Waitable timer object, Window, 296  Writing Across the Curriculum (WAC), B-6
Wait-die method, 18-33              Writing assignments, B-6­B-7
Wait functions, Windows, 295        Writing files, 522
Waiting state, 180
Waiting time, 419                   X
Weak semaphores, 216                XML (Extensible Markup Language), 689­690
Web clients, 623
Weblogic, 173                       Z
Web resources, 4­6                  Zero, 20-20
Web servers, 623                    Zero-day exploit, 630
Websphere, 173                      ZF (zero flag), 132
While loops, 231                    Zombies, 620. See also Bots
Wide sense stationary, 19-17        Zombie state, 184, 188

