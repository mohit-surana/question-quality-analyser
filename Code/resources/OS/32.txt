Evolution of the Microprocessor
10  CHAPTER 1 / COMPUTER SYSTEM OVERVIEW
     the data read from memory. Similarly, an I/O address register (I/OAR) specifies a
     particular I/O device. An I/O buffer register (I/OBR) is used for the exchange of
     data between an I/O module and the processor.
     A memory module consists of a set of locations, defined by sequentially num-
     bered addresses. Each location contains a bit pattern that can be interpreted as
     either an instruction or data. An I/O module transfers data from external devices to
     processor and memory, and vice versa. It contains internal buffers for temporarily
     holding data until they can be sent on.
1.2  EVOLUTION OF THE MICROPROCESSOR
     The hardware revolution that brought about desktop and handheld computing was
     the invention of the microprocessor, which contained a processor on a single chip.
     Though originally much slower than multichip processors, microprocessors have
     continually evolved to the point that they are now much faster for most computa-
     tions due to the physics involved in moving information around in sub-nanosecond
     timeframes.
     Not only have microprocessors become the fastest general purpose processors
     available, they are now multiprocessors; each chip (called a socket) contains multi-
     ple processors (called cores), each with multiple levels of large memory caches, and
     multiple logical processors sharing the execution units of each core. As of 2010, it is
     not unusual for even a laptop to have 2 or 4 cores, each with 2 hardware threads, for
     a total of 4 or 8 logical processors.
     Although processors provide very good performance for most forms of
     computing, there is increasing demand for numerical computation. Graphical
     Processing Units (GPUs) provide efficient computation on arrays of data using
     Single-Instruction Multiple Data (SIMD) techniques pioneered in supercomput-
     ers. GPUs are no longer used just for rendering advanced graphics, but they are
     also used for general numerical processing, such as physics simulations for games
     or computations on large spreadsheets. Simultaneously, the CPUs themselves are
     gaining the capability of operating on arrays of data--with increasingly power-
     ful vector units integrated into the processor architecture of the x86 and AMD64
     families.
     Processors and GPUs are not the end of the computational story for the
     modern PC. Digital Signal Processors (DSPs) are also present, for dealing with
     streaming signals--such as audio or video. DSPs used to be embedded in I/O
     devices, like modems, but they are now becoming first-class computational devices,
     especially in handhelds. Other specialized computational devices (fixed function
     units) co-exist with the CPU to support other standard computations, such as
     encoding/decoding speech and video (codecs), or providing support for encryption
     and security.
     To satisfy the requirements of handheld devices, the classic microprocessor
     is giving way to the System on a Chip (SoC), where not just the CPUs and caches
     are on the same chip, but also many of the other components of the system, such as
     DSPs, GPUs, I/O devices (such as radios and codecs), and main memory.

                                                1.3 / INSTRUCTION EXECUTION                     11
1.3  INSTRUCTION EXECUTION
     A program to be executed by a processor consists of a set of instructions stored
     in memory. In its simplest form, instruction processing consists of two steps: The
     processor reads (fetches) instructions from memory one at a time and executes each
     instruction. Program execution consists of repeating the process of instruction fetch
     and instruction execution. Instruction execution may involve several operations and
     depends on the nature of the instruction.
        The processing required for a single instruction is called an instruction cycle.
     Using a simplified two-step description, the instruction cycle is depicted in Figure 1.2.
     The two steps are referred to as the fetch stage and the execute stage. Program execu-
     tion halts only if the processor is turned off, some sort of unrecoverable error occurs,
     or a program instruction that halts the processor is encountered.
        At the beginning of each instruction cycle, the processor fetches an instruc-
     tion from memory. Typically, the program counter (PC) holds the address of the
     next instruction to be fetched. Unless instructed otherwise, the processor always
     increments the PC after each instruction fetch so that it will fetch the next instruc-
     tion in sequence (i.e., the instruction located at the next higher memory address).
     For example, consider a simplified computer in which each instruction occupies one
     16-bit word of memory. Assume that the program counter is set to location 300.
     The processor will next fetch the instruction at location 300. On succeeding instruc-
     tion cycles, it will fetch instructions from locations 301, 302, 303, and so on. This
     sequence may be altered, as explained subsequently.
        The fetched instruction is loaded into the instruction register (IR). The
     instruction contains bits that specify the action the processor is to take. The proces-
     sor interprets the instruction and performs the required action. In general, these
     actions fall into four categories:
       Processor-memory: Data may be transferred from processor to memory or
        from memory to processor.
       Processor-I/O: Data may be transferred to or from a peripheral device by
        transferring between the processor and an I/O module.
       Data processing: The processor may perform some arithmetic or logic opera-
        tion on data.
       Control: An instruction may specify that the sequence of execution be altered.
        For example, the processor may fetch an instruction from location 149, which
                       Fetch stage              Execute stage
        START          Fetch next                         Execute       HALT
                       instruction              instruction
     Figure 1.2  Basic Instruction Cycle
