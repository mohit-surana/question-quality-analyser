Deadlock Prevention
     The fourth condition is, actually, a potential consequence of the first three.
     That is, given that the first three conditions exist, a sequence of events may occur
     that lead to an unresolvable circular wait. The unresolvable circular wait is in fact
     the definition of deadlock. The circular wait listed as condition 4 is unresolvable
     because the first three conditions hold. Thus, the four conditions, taken together,
     constitute necessary and sufficient conditions for deadlock.1
     To clarify this discussion, it is useful to return to the concept of the joint
     progress diagram, such as the one shown in Figure 6.2. Recall that we defined a
     fatal region as one such that once the processes have progressed into that region,
     those processes will deadlock. A fatal region exists only if all of the first three con-
     ditions listed above are met. If one or more of these conditions are not met, there
     is no fatal region and deadlock cannot occur. Thus, these are necessary conditions
     for deadlock. For deadlock to occur, there must not only be a fatal region, but
     also a sequence of resource requests that has led into the fatal region. If a circular
     wait condition occurs, then in fact the fatal region has been entered. Thus, all four
     conditions listed above are sufficient for deadlock. To summarize,
     Possibility of Deadlock  Existence of Deadlock
     1.  Mutual exclusion     1.  Mutual exclusion
     2.  No preemption        2.  No preemption
     3.  Hold and wait        3.  Hold and wait
                              4.  Circular wait
     Three general approaches exist for dealing with deadlock. First, one can
     prevent deadlock by adopting a policy that eliminates one of the conditions
     (conditions 1 through 4). Second, one can avoid deadlock by making the appropri-
     ate dynamic choices based on the current state of resource allocation. Third, one
     can attempt to detect the presence of deadlock (conditions 1 through 4 hold) and
     take action to recover. We discuss each of these approaches in turn.
6.2  DEADLOCK PREVENTION
     The strategy of deadlock prevention is, simply put, to design a system in such a
     way that the possibility of deadlock is excluded. We can view deadlock prevention
     methods as falling into two classes. An indirect method of deadlock prevention
     is to prevent the occurrence of one of the three necessary conditions listed previ-
     ously (items 1 through 3). A direct method of deadlock prevention is to prevent the
     occurrence of a circular wait (item 4). We now examine techniques related to each
     of the four conditions.
     1Virtually all textbooks simply list these four conditions as the conditions needed for deadlock, but such
     a presentation obscures some of the subtler issues. Item 4, the circular wait condition, is fundamentally
     different from the other three conditions. Items 1 through 3 are policy decisions, while item 4 is a circum-
     stance that might occur depending on the sequencing of requests and releases by the involved processes.
     Linking circular wait with the three necessary conditions leads to inadequate distinction between preven-
     tion and avoidance. See [SHUB90] and [SHUB03] for a discussion.

Mutual Exclusion
In general, the first of the four listed conditions cannot be disallowed. If access to
a resource requires mutual exclusion, then mutual exclusion must be supported by
the OS. Some resources, such as files, may allow multiple accesses for reads but
only exclusive access for writes. Even in this case, deadlock can occur if more than
one process requires write permission.
Hold and Wait
The hold-and-wait condition can be prevented by requiring that a process request
all of its required resources at one time and blocking the process until all requests
can be granted simultaneously. This approach is inefficient in two ways. First, a
process may be held up for a long time waiting for all of its resource requests to be
filled, when in fact it could have proceeded with only some of the resources. Second,
resources allocated to a process may remain unused for a considerable period,
during which time they are denied to other processes. Another problem is that a
process may not know in advance all of the resources that it will require.
There is also the practical problem created by the use of modular program-
ming or a multithreaded structure for an application. An application would need
to be aware of all resources that will be requested at all levels or in all modules to
make the simultaneous request.
No Preemption
This condition can be prevented in several ways. First, if a process holding certain
resources is denied a further request, that process must release its original resources
and, if necessary, request them again together with the additional resource.
Alternatively, if a process requests a resource that is currently held by another pro-
cess, the OS may preempt the second process and require it to release its resources.
This latter scheme would prevent deadlock only if no two processes possessed the
same priority.
This approach is practical only when applied to resources whose state can be
easily saved and restored later, as is the case with a processor.
Circular Wait
The circular-wait condition can be prevented by defining a linear ordering of
resource types. If a process has been allocated resources of type R, then it may
subsequently request only those resources of types following R in the ordering.
To see that this strategy works, let us associate an index with each resource
type. Then resource Ri precedes Rj in the ordering if i < j. Now suppose that two
processes, A and B, are deadlocked because A has acquired Ri and requested Rj,
and B has acquired Rj and requested Ri. This condition is impossible because it
implies i < j and j < i.
As with hold-and-wait prevention, circular-wait prevention may be inefficient,
slowing down processes and denying resource access unnecessarily.

6.3       DEADLOCK AVOIDANCE
          An approach to solving the deadlock problem that differs subtly from deadlock
          prevention is deadlock avoidance.2 In deadlock prevention, we constrain resource
          requests to prevent at least one of the four conditions of deadlock. This is either
          done indirectly, by preventing one of the three necessary policy conditions (mutual
          exclusion, hold and wait, no preemption), or directly, by preventing circular wait.
          This leads to inefficient use of resources and inefficient execution of processes.
          Deadlock avoidance, on the other hand, allows the three necessary conditions but
          makes judicious choices to assure that the deadlock point is never reached. As such,
          avoidance allows more concurrency than prevention. With deadlock avoidance, a
          decision is made dynamically whether the current resource allocation request will,
          if granted, potentially lead to a deadlock. Deadlock avoidance thus requires knowl-
          edge of future process resource requests.
                In this section, we describe two approaches to deadlock avoidance:
               Do not start a process if its demands might lead to deadlock.
               Do not grant an incremental resource request to a process if                     this     allocation
                might lead to deadlock.
          Process Initiation Denial
          Consider a system of n processes and m different types of resources. Let us define
          the following vectors and matrices:
Resource = R = (R1,R2, c ,Rm)                     Total amount of each resource in the system
Available = V = (V1,V2, c ,Vm)                    Total amount of each resource not allocated to       any  process
                   C 11  C 12  c     C 1m
Claim  =  C  =    C 21  C 22  c     C 2m         Cij = requirement of process i for resource j
                   f        f     f     f
                   C n1  C n2  c     C nm
                         A11   A12   c     A1m
Allocation   =  A  =    A21   A22   c     A2m  
                         f     f     f       f    Aij = current allocation to process i of resource    j
                         An1   An2   c     Anm
                The matrix Claim gives the maximum requirement of each process for
          each resource, with one row dedicated to each process. This information must be
          2The term avoidance is a bit confusing. In fact, one could consider the strategies discussed in this
          section to be examples of deadlock prevention because they indeed prevent the occurrence of a
          deadlock.
