Modern UNIX Systems
92  CHAPTER  2  /  OPERATING SYSTEM OVERVIEW
                                       User programs
                                 Trap
                                                                     Libraries
                   User level
                   Kernel level
                                              System call interface
                                                                                Interprocess
                                                                                communication
                   File subsystem                          Process
                                                           control              Scheduler
                                                           subsystem
                                   Buffer cache                                 Memory
                                                                                management
                   Character           Block
                   Device drivers
                                                 Hardware control
                   Kernel level
                   Hardware level
                                                 Hardware
                   Figure 2.17     Traditional UNIX Kernel
     made about a traditional UNIX system. It is designed to run on a single processor
     and lacks the ability to protect its data structures from concurrent access by multiple
     processors. Its kernel is not very versatile, supporting a single type of file system,
     process scheduling policy, and executable file format. The traditional UNIX kernel
     is not designed to be extensible and has few facilities for code reuse. The result is
     that, as new features were added to the various UNIX versions, much new code had
     to be added, yielding a bloated and unmodular kernel.
2.9  MODERN UNIX SYSTEMS
     As UNIX evolved, the number of different implementations proliferated, each pro-
     viding some useful features. There was a need to produce a new implementation that
     unified many of the important innovations, added other modern OS design features,
     and produced a more modular architecture. Typical of the modern UNIX kernel is
     the architecture depicted in Figure 2.18. There is a small core of facilities, written in

                                                    2.9  /  MODERN UNIX SYSTEMS          93
                                          coff
                                 a.out              elf
                                          exec
                                          switch
File mappings                                                      NFS
                                                                              FFS
Device               Virtual                                vnode/vfs
mappings             memory                                 interface
                     framework                                                     s5fs
Anonymous
mappings                                                                   RFS
                                        Common
                                        facilities
Disk driver                                                                   Time-sharing
                     Block                                  Scheduler         processes
                     device                                 framework
                     switch
        Tape driver                                                System
                                          Streams                  processes
                                 Network            tty
                                 driver             driver
Figure 2.18  Modern UNIX Kernel
a modular fashion, that provide functions and services needed by a number of OS
processes. Each of the outer circles represents functions and an interface that may
be implemented in a variety of ways.
             We now turn to some examples of modern UNIX systems.
System V Release 4 (SVR4)
SVR4, developed jointly by AT&T and Sun Microsystems, combines features from
SVR3, 4.3BSD, Microsoft Xenix System V, and SunOS. It was almost a total rewrite
of the System V kernel and produced a clean, if complex, implementation. New fea-
tures in the release include real-time processing support, process scheduling classes,
dynamically allocated data structures, virtual memory management, virtual file sys-
tem, and a preemptive kernel.
             SVR4 draws on the efforts of both commercial and academic designers and
was developed to provide a uniform platform for commercial UNIX deployment. It
has succeeded in this objective and is perhaps the most important UNIX variant. It
incorporates most of the important features ever developed on any UNIX system

94  CHAPTER 2 / OPERATING SYSTEM OVERVIEW
    and does so in an integrated, commercially viable fashion. SVR4 runs on processors
    ranging from 32-bit microprocessors up to supercomputers.
    BSD
    The Berkeley Software Distribution (BSD) series of UNIX releases have played
    a key role in the development of OS design theory. 4.xBSD is widely used in aca-
    demic installations and has served as the basis of a number of commercial UNIX
    products. It is probably safe to say that BSD is responsible for much of the popular-
    ity of UNIX and that most enhancements to UNIX first appeared in BSD versions.
         4.4BSD was the final version of BSD to be released by Berkeley, with the
    design and implementation organization subsequently dissolved. It is a major
    upgrade to 4.3BSD and includes a new virtual memory system, changes in the ker-
    nel structure, and a long list of other feature enhancements.
         One of the most widely used and best documented versions of BSD is
    FreeBSD. FreeBSD is popular for Internet-based servers and firewalls and is used
    in a number of embedded systems.
         The latest version of the Macintosh OS, Mac OS X, is based on FreeBSD 5.0
    and the Mach 3.0 microkernel.
    Solaris 10
    Solaris is Sun's SVR4-based UNIX release, with the latest version being 10. Solaris
    provides all of the features of SVR4 plus a number of more advanced features, such
    as a fully preemptable, multithreaded kernel, full support for SMP, and an object-
    oriented interface to file systems. Solaris is the most widely used and most successful
    commercial UNIX implementation.
2.10 LINUX
    History
    Linux started out as a UNIX variant for the IBM PC (Intel 80386) architecture.
    Linus Torvalds, a Finnish student of computer science, wrote the initial version.
    Torvalds posted an early version of Linux on the Internet in 1991. Since then, a
    number of people, collaborating over the Internet, have contributed to the devel-
    opment of Linux, all under the control of Torvalds. Because Linux is free and the
    source code is available, it became an early alternative to other UNIX workstations,
    such as those offered by Sun Microsystems and IBM. Today, Linux is a full-featured
    UNIX system that runs on all of these platforms and more, including Intel Pentium
    and Itanium, and the Motorola/IBM PowerPC.
         Key to the success of Linux has been the availability of free software packages
    under the auspices of the Free Software Foundation (FSF). FSF's goal is stable,
    platform-independent software that is free, high quality, and embraced by the user
    community. FSF's GNU project3 provides tools for software developers, and the
    3GNU is a recursive acronym for GNU's Not Unix. The GNU project is a free software set of packages
    and tools for developing a UNIX-like operating system; it is often used with the Linux kernel.

                                                               2.10 / LINUX             95
GNU Public License (GPL) is the FSF seal of approval. Torvalds used GNU tools
in developing his kernel, which he then released under the GPL. Thus, the Linux
distributions that you see today are the product of FSF's GNU project, Torvald's
individual effort, and the efforts of many collaborators all over the world.
   In addition to its use by many individual programmers, Linux has now made
significant penetration into the corporate world. This is not only because of the
free software, but also because of the quality of the Linux kernel. Many talented
programmers have contributed to the current version, resulting in a technically
impressive product. Moreover, Linux is highly modular and easily configured. This
makes it easy to squeeze optimal performance from a variety of hardware platforms.
Plus, with the source code available, vendors can tweak applications and utilities to
meet specific requirements. Throughout this book, we will provide details of Linux
kernel internals based on the most recent version, Linux 2.6.
Modular Structure
Most UNIX kernels are monolithic. Recall from earlier in this chapter that a mono-
lithic kernel is one that includes virtually all of the OS functionality in one large
block of code that runs as a single process with a single address space. All the func-
tional components of the kernel have access to all of its internal data structures
and routines. If changes are made to any portion of a typical monolithic OS, all the
modules and routines must be relinked and reinstalled and the system rebooted
before the changes can take effect. As a result, any modification, such as adding
a new device driver or file system function, is difficult. This problem is especially
acute for Linux, for which development is global and done by a loosely associated
group of independent programmers.
   Although Linux does not use a microkernel approach, it achieves many of
the potential advantages of this approach by means of its particular modular archi-
tecture. Linux is structured as a collection of modules, a number of which can be
automatically loaded and unloaded on demand. These relatively independent blocks
are referred to as loadable modules [GOYE99]. In essence, a module is an object
file whose code can be linked to and unlinked from the kernel at runtime. Typically,
a module implements some specific function, such as a file system, a device driver,
or some other feature of the kernel's upper layer. A module does not execute as its
own process or thread, although it can create kernel threads for various purposes
as necessary. Rather, a module is executed in kernel mode on behalf of the current
process.
   Thus, although Linux may be considered monolithic, its modular structure
overcomes some of the difficulties in developing and evolving the kernel.
   The Linux loadable modules have two important characteristics:
·  Dynamic linking: A kernel module can be loaded and linked into the kernel
   while the kernel is already in memory and executing. A module can also be
   unlinked and removed from memory at any time.
·  Stackable modules: The modules are arranged in a hierarchy. Individual
   modules serve as libraries when they are referenced by client modules higher
   up in the hierarchy, and as clients when they reference modules further down.

96  CHAPTER 2 / OPERATING SYSTEM OVERVIEW
                 Dynamic linking [FRAN97] facilitates configuration and saves kernel memory.
    In Linux, a user program or user can explicitly load and unload kernel modules
    using the insmod and rmmod commands. The kernel itself monitors the need for
    particular functions and can load and unload modules as needed. With stackable
    modules, dependencies between modules can be defined. This has two benefits:
           1.    Code common to a set of similar modules (e.g., drivers for similar hardware)
                 can be moved into a single module, reducing replication.
           2.    The kernel can make sure that needed modules are present, refraining from
                 unloading a module on which other running modules depend, and loading any
                 additional required modules when a new module is loaded.
                 Figure 2.19 is an example that illustrates the structures used by Linux to
    manage modules. The figure shows the list of kernel modules after only two modules
    have been loaded: FAT and VFAT. Each module is defined by two tables, the mod-
    ule table and the symbol table. The module table includes the following elements:
              ·  *next: Pointer to the following module. All modules are organized into a
                 linked list. The list begins with a pseudomodule (not shown in Figure 2.19).
              ·  *name: Pointer to module name
              ·  size: Module size in memory pages
              ·  usecount: Module usage counter. The counter is incremented when an opera-
                 tion involving the module's functions is started and decremented when the
                 operation terminates.
    Module                                             Module
    *next                                              *next
    *name                                              *name
    size                                               size
    usecount                                           usecount
    flags                                              flags
    nysms                                              nysms
    ndeps                                              ndeps
    *syms        FAT                                   *syms               VFAT
    *deps                                              *deps
    *refs                                              *refs
                      Symbol_table                                               Symbol_table
                      value                                                      value
                      *name                                                      *name
                      value                                                      value
                      *name                                                      *name
                      value                                                      value
                      *name                                                      *name
Figure 2.19      Example List of Linux Kernel Modules

                                                                         2.10 / LINUX                    97
         ·   flags: Module flags
         ·   nsyms: Number of exported symbols
         ·   ndeps: Number of referenced modules
         ·   *syms: Pointer to this module's symbol table.
         ·   *deps: Pointer to list of modules that are referenced by this module.
         ·   *refs: Pointer to list of modules that use this module.
             The symbol table defines those symbols controlled by this module that are
used elsewhere.
             Figure 2.19 shows that the VFAT module was loaded after the FAT module
and that the VFAT module is dependent on the FAT module.
Kernel Components
Figure 2.20, taken from [MOSB02], shows the main components of the Linux kernel
as implemented on an IA-64 architecture (e.g., Intel Itanium). The figure shows
several processes running on top of the kernel. Each box indicates a separate pro-
cess, while each squiggly line with an arrowhead represents a thread of execution.4
The kernel itself consists of an interacting collection of components, with arrows
             Processes                                                                                   User level
             Signals                           System calls
                                  Processes
                        & scheduler                          File        Network
             Virtual                                         systems     protocols                       Kernel
             memory
                                  Char device              Block device  Network
                                  drivers                    drivers     device drivers
Traps &      Physical                          Interrupts
faults       memory
CPU          System               Terminal                   Disk        Network interface               Hardware
             memory                                                      controller
Figure 2.20  Linux Kernel Components
4In Linux, there is no distinction between the concepts of processes and threads. However, multiple
threads in Linux can be grouped together in such a way that, effectively, you can have a single process
comprising multiple threads. These matters are discussed in Chapter 4.

98    CHAPTER 2 / OPERATING SYSTEM        OVERVIEW
Table 2.5  Some Linux Signals
SIGHUP        Terminal hangup                   SIGCONT    Continue
SIGQUIT       Keyboard quit                     SIGTSTP    Keyboard stop
SIGTRAP       Trace trap                        SIGTTOU    Terminal write
SIGBUS        Bus error                         SIGXCPU    CPU limit exceeded
SIGKILL       Kill signal                       SIGVTALRM  Virtual alarm clock
SIGSEGV       Segmentation violation            SIGWINCH   Window size unchanged
SIGPIPT       Broken pipe                       SIGPWR     Power failure
SIGTERM       Termination                       SIGRTMIN   First real-time signal
SIGCHLD       Child status unchanged            SIGRTMAX   Last real-time signal
           indicating the main interactions. The underlying hardware is also depicted as a
           set of components with arrows indicating which kernel components use or control
           which hardware components. All of the kernel components, of course, execute on
           the processor but, for simplicity, these relationships are not shown.
              Briefly, the principal kernel components are the following:
           ·  Signals: The kernel uses signals to call into a process. For example, signals are
              used to notify a process of certain faults, such as division by zero. Table 2.5
              gives a few examples of signals.
           ·  System calls: The system call is the means by which a process requests a specific
              kernel service. There are several hundred system calls, which can be roughly
              grouped into six categories: file system, process, scheduling, interprocess com-
              munication, socket (networking), and miscellaneous. Table 2.6 defines a few
              examples in each category.
           ·  Processes and scheduler: Creates, manages, and schedules processes.
           ·  Virtual memory: Allocates and manages virtual memory for processes.
Table 2.6  Some Linux System Calls
                                      File system Related
close         Close a file descriptor.
link          Make a new name for a file.
open          Open and possibly create a file or device.
read          Read from file descriptor.
write         Write to file descriptor.
                                      Process Related
execve        Execute program.
exit          Terminate the calling process.
getpid        Get process identification.
setuid        Set user identity of the current process.
prtrace       Provides a means by which a parent process may observe and control the execu-
              tion of another process, and examine and change its core image and registers.

                                                                             2.10 / LINUX                        99
Table 2.6    (continued)
                                      Scheduling Related
sched_getparam            Set the scheduling parameters associated with the scheduling policy for the
                          process identified by pid.
sched_get_priority_max    Return the maximum priority value that can be used with the scheduling
                          algorithm identified by policy.
sched_setscheduler        Set both the scheduling policy (e.g., FIFO) and the associated parameters for
                          the process pid.
sched_rr_get_interval     Write into the timespec structure pointed to by the parameter tp the round-
                          robin time quantum for the process pid.
sched_yield               A process can relinquish the processor voluntarily without blocking via this
                          system call. The process will then be moved to the end of the queue for its static
                          priority and a new process gets to run.
                          Interprocess Communication (IPC) Related
msgrcv                    A message buffer structure is allocated to receive a message. The system
                          call then reads a message from the message queue specified by msqid into
                          the newly created message buffer.
semctl                    Perform the control operation specified by cmd on the semaphore set
                          semid.
semop                     Perform operations on selected members of the semaphore set semid.
shmat                     Attach the shared memory segment identified by semid to the data segment
                          of the calling process.
shmctl                    Allow the user to receive information on a shared memory segment; set the
                          owner, group, and permissions of a shared memory segment; or destroy a
                          segment.
                                      Socket (networking) Related
bind                      Assigns the local IP address and port for a socket. Returns 0 for success and 1
                          for error.
connect                   Establish a connection between the given socket and the remote socket
                          associated with sockaddr.
gethostname               Return local host name.
send                      Send the bytes contained in buffer pointed to by *msg over the given
                          socket.
setsockopt                Set the options on a socket
                                            Miscellaneous
create_module             Attempt to create a loadable module entry and reserve the kernel memory that
                          will be needed to hold the module.
fsync                     Copy all in-core parts of a file to disk, and waits until the device reports that all
                          parts are on stable storage.
query_module              Request information related to loadable modules from the kernel.
time                      Return the time in seconds since January 1, 1970.
vhangup                   Simulate a hangup on the current terminal. This call arranges for other users to
                          have a "clean" tty at login time.

100  CHAPTER 2 / OPERATING SYSTEM OVERVIEW
     ·  File systems: Provides a global, hierarchical namespace for files, directories,
        and other file related objects and provides file system functions.
     ·  Network protocols: Supports the Sockets interface to users for the TCP/IP
        protocol suite.
     ·  Character device drivers: Manages devices that require the kernel to send or
        receive data one byte at a time, such as terminals, modems, and printers.
     ·  Block device drivers: Manages devices that read and write data in blocks, such
        as various forms of secondary memory (magnetic disks, CD-ROMs, etc.).
     ·  Network device drivers: Manages network interface cards and communica-
        tions ports that connect to network devices, such as bridges and routers.
     ·  Traps and faults: Handles traps and faults generated by the processor, such as
        a memory fault.
     ·  Physical memory: Manages the pool of page frames in real memory and allo-
        cates pages for virtual memory.
     ·  Interrupts: Handles interrupts from peripheral devices.
2.11 LINUX VSERVER VIRTUAL MACHINE ARCHITECTURE
     Linux VServer is an open-source, fast, lightweight approach to implement-
     ing virtual machines on a Linux server [SOLT07, LIGN05]. Only a single copy
     of the Linux kernel is involved. VServer consists of a relatively modest modifi-
     cation to the kernel plus a small set of OS userland5 tools. The VServer Linux
     kernel supports a number of separate virtual servers. The kernel manages all sys-
     tem resources and tasks, including process scheduling, memory, disk space, and
     processor time. This is closer in concept to the process VM rather than the system
     VM of Figure 2.14.
        Each virtual server is isolated from the others using Linux kernel capabilities.
     This provides security and makes it easy to set up multiple virtual machines on a
     single platform. The isolation involves four elements: chroot, chcontext, chbind, and
     capabilities.
        The chroot command is a UNIX or Linux command to make the root directory
     (/) become something other than its default for the lifetime of the current process.
     It can only be run by privileged users and is used to give a process (commonly a net-
     work server such as FTP or HTTP) access to a restricted portion of the file system.
     This command provides file system isolation. All commands executed by the virtual
     server can only affect files that start with the defined root for that server.
        The chcontext Linux utility allocates a new security context and executes
     commands in that context. The usual or hosted security context is the context 0.
     This context has the same privileges as the root user (UID 0): This context can
     see and kill other tasks in the other contexts. Context number 1 is used to view
     5The term userland refers to all application software that runs in user space rather than kernel space. OS
     userland usually refers to the various programs and libraries that the operating system uses to interact
     with the kernel: software that performs input/output, manipulates file system objects, etc.

                                   2.12 / RECOMMENDED                            READING AND               WEB               SITES  101
                                                             Server                    Server
                                                       applications              applications
                                   VMhost                    VM1                       VMn                 Virtual platform
      Hosting platform       VM admin.
                             Remote admin.
                             Core services
                             /dev  /usr  /home  /proc  /dev  /usr  /home  /proc  /dev  /usr  /home  /proc
                                                       Standard OS image
      Figure 2.21                  Linux VServer Architecture
      other contexts but cannot affect them. All other contexts provide complete isola-
      tion: Processes from one context can neither see nor interact with processes from
      another context. This provides the ability to run similar contexts on the same com-
      puter without any interaction possible at the application level. Thus, each virtual
      server has its own execution context that provides process isolation.
      The chbind utility executes a command, and locks the resulting process and
      its children into using a specific IP address. Once called, all packets sent out by this
      virtual server through the system's network interface are assigned the sending IP
      address derived from the argument given to chbind. This system call provides net-
      work isolation: Each virtual server uses a separate and distinct IP address. Incoming
      traffic intended for one virtual server cannot be accessed by other virtual servers.
      Finally, each virtual server is assigned a set of capabilities. The concept of
      capabilities, as used in Linux, refers to a partitioning of the privileges available to
      a root user, such as the ability to read files or to trace processes owned by another
      user. Thus, each virtual server can be assigned a limited subset of the root user's
      privileges. This provides root isolation. VServer can also set resource limits, such as
      limits to the amount of virtual memory a process may use.
      Figure 2.21, based on [SOLT07], shows the general architecture of Linux
      VServer. VServer provides a shared, virtualized OS image, consisting of a root file
      system, and a shared set of system libraries and kernel services. Each VM can be
      booted, shut down, and rebooted independently. Figure 2.21 shows three group-
      ings of software running on the computer system. The hosting platform includes the
      shared OS image and a privileged host VM, whose function is to monitor and man-
      age the other VMs. The virtual platform creates virtual machines and is the view of
      the system seen by the applications running on the individual VMs.
2.12  RECOMMENDED READING AND WEB SITES
      [BRIN01] is an excellent collection of papers covering major advances in OS design
      over the years. [SWAI07] is a provocative and interesting short article on the future
      of operating systems.

102  CHAPTER 2 / OPERATING SYSTEM OVERVIEW
     [MUKH96] provides a good discussion of OS design issues for SMPs.
     [CHAP97] contains five articles on recent design directions for multiprocessor
     operating systems. Worthwhile discussions of the principles of microkernel design
     are contained in [LIED95] and [LIED96]; the latter focuses on performance
     issues.
     [LI10] and [SMIT05] provide good treatments of virtual machines.
     An excellent treatment of UNIX internals, which provides a comparative
     analysis of a number of variants, is [VAHA96]. For UNIX SVR4, [GOOD94]
     provides a definitive treatment, with ample technical detail. For the popular open-
     source FreeBSD, [MCKU05] is highly recommended. [MCDO07] provides a good
     treatment of Solaris internals. Good treatments of Linux internals are [LOVE10]
     and [MAUE08].
     Although there are countless books on various versions of Windows, there
     is remarkably little material available on Windows internals. The book to read is
     [RUSS11].
     BRIN01     Brinch Hansen, P. Classic Operating Systems: From Batch Processing to
              Distributed Systems. New York: Springer-Verlag, 2001.
     CHAP97     Chapin, S., and Maccabe, A., eds. "Multiprocessor Operating Systems:
              Harnessing the Power." special issue of IEEE Concurrency, April­June 1997.
     GOOD94     Goodheart, B., and Cox, J. The Magic Garden Explained: The Internals of
              UNIX System V Release 4. Englewood Cliffs, NJ: Prentice Hall, 1994.
     LOVE10     Love, R. Linux Kernel Development. Upper Saddle River, NJ: Addison-
              Wesley, 2010.
     LI10     Li, Y.; Li, W.; and Jiang, C. "A Survey of Virtual Machine Systems: Current
              Technology and Future Trends." Proceedings, Third International Symposium on
              Electronic Commerce and Security, 2010.
     LIED95     Liedtke, J. "On -Kernel Construction." Proceedings of the Fifteenth ACM
              Symposium on Operating Systems Principles, December 1995.
     LIED96     Liedtke, J. "Toward Real Microkernels." Communications of the ACM,
              September 1996.
     MAUE08     Mauerer, W. Professional Linux Kernel Architecture. New York: Wiley, 2008.
     MCDO07     McDougall, R., and Mauro, J. Solaris Internals: Solaris 10 and OpenSolaris
              Kernel Architecture. Palo Alto, CA: Sun Microsystems Press, 2007.
     MCKU05     McKusick, M., and Neville-Neil, J. The Design and Implementation of the
              FreeBSD Operating System. Reading, MA: Addison-Wesley, 2005.
     MUKH96     Mukherjee, B., and Karsten, S. "Operating Systems for Parallel Machines."
              In Parallel Computers: Theory and Practice. Edited by T. Casavant, P. Tvrkik, and
              F. Plasil. Los Alamitos, CA: IEEE Computer Society Press, 1996.
     RUSS11     Russinovich, M.; Solomon, D.; and Ionescu, A. Windows Internals: Covering
              Windows 7 and Windows Server 2008 R2. Redmond, WA: Microsoft Press, 2011.
     SMIT05     Smith, J., and Nair, R. "The Architecture of Virtual Machines." Computer,
              May 2005.
     SWAI07     Swaine, M. "Wither Operating Systems?" Dr. Dobb's Journal, March 2007.
     VAHA96     Vahalia, U. UNIX Internals: The New Frontiers. Upper Saddle River, NJ:
              Prentice Hall, 1996.

                       2.13 / KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS                               103
        Recommended Web sites:
             ·    The Operating System Resource Center: A useful collection of documents and papers
                  on a wide range of OS topics.
             ·    Operating System Technical Comparison: Includes a substantial amount of information
                  on a variety of operating systems.
             ·    ACM Special Interest Group on Operating Systems: Information on SIGOPS publica-
                  tions and conferences.
             ·    IEEE Technical Committee on Operating Systems and Application Environments:
                  Includes an online newsletter and links to other sites.
             ·    The comp.os.research FAQ: Lengthy and worthwhile FAQ covering OS design issues.
             ·    UNIX Guru Universe: Excellent source of UNIX information.
             ·    Linux Documentation Project: The name describes the site.
             ·    IBM's Linux Website: Provides a wide range of technical and user information on
                  Linux. Much of it is devoted to IBM products but there is a lot of useful general techni-
                  cal information.
             ·    Windows Development: Good source of information on Windows internals.
2.13 KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS
Key Terms
batch processing                      multiprogramming                     round robin
batch system                          multitasking                         scheduling
execution context                     multithreading                       serial processing
interrupt                             nucleus                              symmetric multiprocessing
job                                   operating system                     task
job control language                  physical address                     thread
kernel                                privileged instruction               time sharing
memory management                     process                              time-sharing system
microkernel                           process state                        uniprogramming
monitor                               real address                         virtual address
monolithic kernel                     resident monitor                     virtual machine
multiprogrammed batch
     system
        Review Questions
             2.1  What are three objectives of an OS design?
             2.2  What is the kernel of an OS?
             2.3  What is multiprogramming?
             2.4  What is a process?
             2.5  How is the execution context of a process used by the OS?

104  CHAPTER 2 / OPERATING SYSTEM OVERVIEW
     2.6   List and briefly explain five storage management responsibilities of a typical OS.
     2.7   Explain the distinction between a real address and a virtual address.
     2.8   Describe the round-robin scheduling technique.
     2.9   Explain the difference between a monolithic kernel and a microkernel.
     2.10  What is multithreading?
     2.11  List the key design issues for an SMP operating system.
     Problems
     2.1   Suppose that we have a multiprogrammed computer in which each job has identical
           characteristics. In one computation period, T, for a job, half the time is spent in I/O
           and the other half in processor activity. Each job runs for a total of N periods. Assume
           that a simple round-robin scheduling is used, and that I/O operations can overlap with
           processor operation. Define the following quantities:
           ·   Turnaround time = actual time to complete a job
           ·   Throughput = average number of jobs completed per time period T
           ·   Processor utilization = percentage of time that the processor is active (not waiting)
           Compute these quantities for one, two, and four simultaneous jobs, assuming that the
           period T is distributed in each of the following ways:
           a.  I/O first half, processor second half
           b.  I/O first and fourth quarters, processor second and third quarter
     2.2   An I/O-bound program is one that, if run alone, would spend more time waiting for
           I/O than using the processor. A processor-bound program is the opposite. Suppose a
           short-term scheduling algorithm favors those programs that have used little processor
           time in the recent past. Explain why this algorithm favors I/O-bound programs and
           yet does not permanently deny processor time to processor-bound programs.
     2.3   Contrast the scheduling policies you might use when trying to optimize a time-sharing
           system with those you would use to optimize a multiprogrammed batch system.
     2.4   What is the purpose of system calls, and how do system calls relate to the OS and to
           the concept of dual-mode (kernel-mode and user-mode) operation?
     2.5   In IBM's mainframe OS, OS/390, one of the major modules in the kernel is the System
           Resource Manager. This module is responsible for the allocation of resources among
           address spaces (processes). The SRM gives OS/390 a degree of sophistication unique
           among operating systems. No other mainframe OS, and certainly no other type of OS,
           can match the functions performed by SRM. The concept of resource includes proces-
           sor, real memory, and I/O channels. SRM accumulates statistics pertaining to utilization
           of processor, channel, and various key data structures. Its purpose is to provide optimum
           performance based on performance monitoring and analysis. The installation sets
           forth various performance objectives, and these serve as guidance to the SRM, which
           dynamically modifies installation and job performance characteristics based on system
           utilization. In turn, the SRM provides reports that enable the trained operator to refine
           the configuration and parameter settings to improve user service.
               This problem concerns one example of SRM activity. Real memory is divided
           into equal-sized blocks called frames, of which there may be many thousands. Each
           frame can hold a block of virtual memory referred to as a page. SRM receives control
           approximately 20 times per second and inspects each and every page frame. If the
           page has not been referenced or changed, a counter is incremented by 1. Over time,
           SRM averages these numbers to determine the average number of seconds that a
           page frame in the system goes untouched. What might be the purpose of this and what
           action might SRM take?
     2.6   A multiprocessor with eight processors has 20 attached tape drives. There is a large
           number of jobs submitted to the system that each require a maximum of four tape

    2.13 / KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS                            105
drives to complete execution. Assume that each job starts running with only three
tape drives for a long period before requiring the fourth tape drive for a short period
toward the end of its operation. Also assume an endless supply of such jobs.
a.  Assume the scheduler in the OS will not start a job unless there are four tape
    drives available. When a job is started, four drives are assigned immediately and
    are not released until the job finishes. What is the maximum number of jobs that
    can be in progress at once? What are the maximum and minimum number of tape
    drives that may be left idle as a result of this policy?
b.  Suggest an alternative policy to improve tape drive utilization and at the same
    time avoid system deadlock. What is the maximum number of jobs that can be in
    progress at once? What are the bounds on the number of idling tape drives?

PART 2 Processes
                                       CHAPTER
PROCESS DESCRIPTION
AND CONTROL
     3.1   What Is a Process?
           Background
           Processes and Process Control Blocks
     3.2   Process States
           A Two-State Process Model
           The Creation and Termination of Processes
           A Five-State Model
           Suspended Processes
     3.3   Process Description
           Operating System Control Structures
           Process Control Structures
     3.4   Process Control
           Modes of Execution
           Process Creation
           Process Switching
     3.5   Execution of the Operating System
           Nonprocess Kernel
           Execution within User Processes
           Process-Based Operating System
     3.6   Security Issues
           System Access Threats
           Countermeasures
     3.7   UNIX SVR4 Process Management
           Process States
           Process Description
           Process Control
     3.8   Summary
     3.9   Recommended Reading
     3.10  Key Terms, Review Questions, and Problems
106
