Protection


                                                                 14C H A P T E R
Protection
      The processes in an operating system must be protected from one another's
      activities. To provide such protection, we can use various mechanisms to ensure
      that only processes that have gained proper authorization from the operating
      system can operate on the files, memory segments, CPU, and other resources
      of a system.
      Protection refers to a mechanism for controlling the access of programs,
      processes,  or  users  to  the  resources  defined  by  a  computer  system.  This
      mechanism must provide a means for specifying the controls to be imposed,
      together with a means of enforcement. We distinguish between protection and
      security, which is a measure of confidence that the integrity of a system and
      its data will be preserved. In this chapter, we focus on protection. Security
      assurance is a much broader topic, and we address it in Chapter 15.
      CHAPTER OBJECTIVES
      · To discuss the goals and principles of protection in a modern computer
      system.
      · To explain how protection domains, combined with an access matrix, are
      used to specify the resources a process may access.
      · To examine capability- and language-based protection systems.
14.1  Goals of Protection
      As computer systems have become more sophisticated and pervasive in their
      applications, the need to protect their integrity has also grown. Protection was
      originally conceived as an adjunct to multiprogramming operating systems,
      so that untrustworthy users might safely share a common logical name space,
      such as a directory of files, or share a common physical name space, such as
      memory. Modern protection concepts have evolved to increase the reliability
      of any complex system that makes use of shared resources.
      We need to provide protection for several reasons. The most obvious is the
      need to prevent the mischievous, intentional violation of an access restriction
                                                                                        625



626   Chapter 14  Protection
      by a user. Of more general importance, however, is the need to ensure that
      each program component active in a system uses system resources only in
      ways consistent with stated policies. This requirement is an absolute one for a
      reliable system.
      Protection can improve reliability by detecting latent errors at the interfaces
      between component subsystems. Early detection of interface errors can often
      prevent contamination of a healthy subsystem by a malfunctioning subsystem.
      Also, an unprotected resource cannot defend against use (or misuse) by an
      unauthorized or incompetent user. A protection-oriented system provides
      means to distinguish between authorized and unauthorized usage.
      The role of protection in a computer system is to provide a mechanism for
      the enforcement of the policies governing resource use. These policies can be
      established in a variety of ways. Some are fixed in the design of the system,
      while others are formulated by the management of a system. Still others are
      defined by the individual users to protect their own files and programs. A
      protection system must have the flexibility to enforce a variety of policies.
      Policies for resource use may vary by application, and they may change
      over time. For these reasons, protection is no longer the concern solely of
      the designer of an operating system. The application programmer needs to
      use protection mechanisms as well, to guard resources created and supported
      by an application subsystem against misuse. In this chapter, we describe the
      protection mechanisms the operating system should provide, but application
      designers can use them as well in designing their own protection software.
      Note that mechanisms are distinct from policies. Mechanisms determine
      how something will be done; policies decide what will be done. The separation
      of policy and mechanism is important for flexibility. Policies are likely to
      change from place to place or time to time. In the worst case, every change
      in policy would require a change in the underlying mechanism. Using general
      mechanisms enables us to avoid such a situation.
14.2  Principles of Protection
      Frequently, a guiding principle can be used throughout a project, such as
      the design of an operating system. Following this principle simplifies design
      decisions and keeps the system consistent and easy to understand. A key,
      time-tested guiding principle for protection is the principle of least privilege. It
      dictates that programs, users, and even systems be given just enough privileges
      to perform their tasks.
      Consider the analogy of a security guard with a passkey. If this key allows
      the guard into just the public areas that she guards, then misuse of the key
      will result in minimal damage. If, however, the passkey allows access to all
      areas, then damage from its being lost, stolen, misused, copied, or otherwise
      compromised will be much greater.
      An operating system following the principle of least privilege implements
      its features, programs, system calls, and data structures so that failure or
      compromise  of    a  component  does  the  minimum  damage  and  allows               the
      minimum damage to be done. The overflow of a buffer in a system daemon
      might cause the daemon process to fail, for example, but should not allow the
      execution of code from the daemon process's stack that would enable a remote



                                 14.3  Domain of Protection                               627
      user to gain maximum privileges and access to the entire system (as happens
      too often today).
      Such an operating system also provides system calls and services that
      allow applications to be written with fine-grained access controls. It provides
      mechanisms to enable privileges when they are needed and to disable them
      when they are not needed. Also beneficial is the creation of audit trails for
      all privileged function access. The audit trail allows the programmer, system
      administrator, or law-enforcement officer to trace all protection and security
      activities on the system.
      Managing users with the principle of least privilege entails creating a
      separate account for each user, with just the privileges that the user needs. An
      operator who needs to mount tapes and back up files on the system has access
      to just those commands and files needed to accomplish the job. Some systems
      implement role-based access control (RBAC) to provide this functionality.
      Computers implemented in a computing facility under the principle of least
      privilege can be limited to running specific services, accessing specific remote
      hosts via specific services, and doing so during specific times. Typically, these
      restrictions are implemented through enabling or disabling each service and
      through using access control lists, as described in Sections Section 11.6.2 and
      Section 14.6.
      The principle of least privilege can help produce a more secure computing
      environment. Unfortunately, it frequently does not. For example, Windows
      2000 has a complex protection scheme at its core and yet has many security
      holes. By comparison, Solaris is considered relatively secure, even though it
      is a variant of UNIX, which historically was designed with little protection
      in mind. One reason for the difference may be that Windows 2000 has more
      lines of code and more services than Solaris and thus has more to secure and
      protect. Another reason could be that the protection scheme in Windows 2000
      is incomplete or protects the wrong aspects of the operating system, leaving
      other areas vulnerable.
14.3  Domain of Protection
      A computer system is a collection of processes and objects. By objects, we mean
      both hardware objects (such as the CPU, memory segments, printers, disks, and
      tape drives) and software objects (such as files, programs, and semaphores).
      Each object has a unique name that differentiates it from all other objects in the
      system, and each can be accessed only through well-defined and meaningful
      operations. Objects are essentially abstract data types.
      The operations that are possible may depend on the object. For example,
      on a CPU, we can only execute. Memory segments can be read and written,
      whereas a CD-ROM or DVD-ROM can only be read. Tape drives can be read,
      written, and rewound. Data files can be created, opened, read, written, closed,
      and deleted; program files can be read, written, executed, and deleted.
      A process should be allowed to access only those resources for which it
      has authorization. Furthermore, at any time, a process should be able to access
      only those resources that it currently requires to complete its task. This second
      requirement, commonly referred to as the need-to-know principle, is useful
      in limiting the amount of damage a faulty process can cause in the system.



628  Chapter 14  Protection
     For example, when process p invokes procedure A(), the procedure should be
     allowed to access only its own variables and the formal parameters passed to it;
     it should not be able to access all the variables of process p. Similarly, consider
     the case in which process p invokes a compiler to compile a particular file. The
     compiler should not be able to access files arbitrarily but should have access
     only to a well-defined subset of files (such as the source file, listing file, and
     so on) related to the file to be compiled. Conversely, the compiler may have
     private files used for accounting or optimization purposes that process p should
     not be able to access. The need-to-know principle is similar to the principle of
     least privilege discussed in Section 14.2 in that the goals of protection are to
     minimize the risks of possible security violations.
     14.3.1   Domain Structure
     To facilitate the scheme just described, a process operates within a protection
     domain,  which  specifies    the  resources  that    the  process    may      access.    Each
     domain defines a set of objects and the types of operations that may be invoked
     on each object. The ability to execute an operation on an object is an access
     right. A domain is a collection of access rights, each of which is an ordered
     pair <object-name,      rights-set>. For example, if domain D has the access
     right <file F, {read,write}>, then a process executing in domain D can both
     read and write file F. It cannot, however, perform any other operation on that
     object.
     Domains may share access rights. For example, in Figure 14.1, we have
     three domains: D1, D2, and D3. The access right <O4, {print}> is shared by D2
     and D3, implying that a process executing in either of these two domains can
     print object O4. Note that a process must be executing in domain D1 to read
     and write object O1, while only processes in domain D3 may execute object O1.
     The association between a process and a domain may be either static, if
     the set of resources available to the process is fixed throughout the process's
     lifetime, or dynamic. As might be expected, establishing dynamic protection
     domains is more complicated than establishing static protection domains.
     If the association between processes and domains is fixed, and we want to
     adhere to the need-to-know principle, then a mechanism must be available to
     change the content of a domain. The reason stems from the fact that a process
     may execute in two different phases and may, for example, need read access
     in one phase and write access in another. If a domain is static, we must define
     the domain to include both read and write access. However, this arrangement
     provides more rights than are needed in each of the two phases, since we have
     read access in the phase where we need only write access, and vice versa.
                 D1                                   D2                  D3
      O3, {read, write}                                                       O1,  {execute}  
      O1, {read, write}                 O2, {write}       O4,  {print}        O3,  {read} 
      O2, {execute} 
                     Figure 14.1  System with three protection domains.



                                             14.3    Domain of Protection           629
Thus, the need-to-know principle is violated. We must allow the contents of
a domain to be modified so that the domain always reflects the minimum
necessary access rights.
     If the association is dynamic, a mechanism is available to allow domain
switching, enabling the process to switch from one domain to another. We may
also want to allow the content of a domain to be changed. If we cannot change
the content of a domain, we can provide the same effect by creating a new
domain with the changed content and switching to that new domain when we
want to change the domain content.
     A domain can be realized in a variety of ways:
·    Each user may be a domain. In this case, the set of objects that can be
     accessed depends on the identity of the user. Domain switching occurs
     when the user is changed --generally when one user logs out and another
     user logs in.
·    Each process may be a domain. In this case, the set of objects that can be
     accessed depends on the identity of the process. Domain switching occurs
     when one process sends a message to another process and then waits for
     a response.
·    Each procedure may be a domain. In this case, the set of objects that can be
     accessed corresponds to the local variables defined within the procedure.
     Domain switching occurs when a procedure call is made.
We discuss domain switching in greater detail in Section 14.4.
     Consider  the  standard      dual-mode  (monitor ­ user    mode)      model    of
operating-system execution. When a process executes in monitor mode, it
can execute privileged instructions and thus gain complete control of the
computer system. In contrast, when a process executes in user mode, it can
invoke only nonprivileged instructions. Consequently, it can execute only
within its predefined memory space. These two modes protect the operating
system (executing in monitor domain) from the user processes (executing
in user domain). In a multiprogrammed operating system, two protection
domains  are   insufficient,  since  users  also  want  to  be  protected  from     one
another. Therefore, a more elaborate scheme is needed. We illustrate such a
scheme by examining two influential operating systems -- UNIX and MULTICS
--to see how they implement these concepts.
14.3.2   An Example: UNIX
In the UNIX operating system, a domain is associated with the user. Switching
the  domain    corresponds    to  changing   the  user  identification  temporarily.
This change is accomplished through the file system as follows. An owner
identification and a domain bit (known as the setuid bit) are associated with
each file. When the setuid bit is on, and a user executes that file, the userID is
set to that of the owner of the file. When the bit is off, however, the userID
does not change. For example, when a user A (that is, a user with userID =
A) starts executing a file owned by B, whose associated domain bit is off, the
userID of the process is set to A. When the setuid bit is on, the userID is set to



630  Chapter 14    Protection
     that of the owner of the file: B. When the process exits, this temporary userID
     change ends.
     Other methods are used to change domains in operating systems in which
     userIDs are used for domain definition, because almost all systems need
     to provide such a mechanism. This mechanism is used when an otherwise
     privileged facility needs to be made available to the general user population.
     For instance, it might be desirable to allow users to access a network without
     letting them write their own networking programs. In such a case, on a UNIX
     system, the setuid bit on a networking program would be set, causing the
     userID to change when the program was run. The userID would change to
     that of a user with network access privilege (such as root, the most powerful
     userID). One problem with this method is that if a user manages to create a file
     with userID root and with its setuid bit on, that user can become root and
     do anything and everything on the system. The setuid mechanism is discussed
     further in Appendix A.
     An alternative to this method used in some other operating systems is
     to place privileged programs in a special directory. The operating system is
     designed to change the userID of any program run from this directory, either
     to the equivalent of root or to the userID of the owner of the directory. This
     eliminates one security problem, which occurs when intruders create programs
     to manipulate the setuid feature and hide the programs in the system for later
     use (using obscure file or directory names). This method is less flexible than
     that used in UNIX, however.
     Even more restrictive, and thus more protective, are systems that simply
     do not allow a change of userID. In these instances, special techniques must
     be used to allow users access to privileged facilities. For instance, a daemon
     process may be started at boot time and run as a special userID. Users then
     run a separate program, which sends requests to this process whenever they
     need to use the facility. This method is used by the TOPS-20 operating system.
     In any of these systems, great care must be taken in writing privileged
     programs. Any oversight can result in a total lack of protection on the system.
     Generally, these programs are the first to be attacked by people trying to
     break into a system. Unfortunately, the attackers are frequently successful.
     For example, security has been breached on many UNIX systems because of the
     setuid feature. We discuss security in Chapter 15.
     14.3.3  An Example: MULTICS
     In the MULTICS system, the protection domains are organized hierarchically
     into a ring structure. Each ring corresponds to a single domain (Figure 14.2).
     The rings are numbered from 0 to 7. Let Di and Dj be any two domain rings.
     If j < i, then Di is a subset of Dj . That is, a process executing in domain Dj
     has more privileges than does a process executing in domain Di . A process
     executing in domain D0 has the most privileges. If only two rings exist, this
     scheme is equivalent to the monitor­user mode of execution, where monitor
     mode corresponds to D0 and user mode corresponds to D1.
     MULTICS has a segmented address space; each segment is a file, and each
     segment is associated with one of the rings. A segment description includes an
     entry that identifies the ring number. In addition, it includes three access bits



                                            14.3  Domain of Protection               631
                                                  ring 0
                                                          ring 1
            ···                                                ring N ­ 1
                   Figure 14.2        MULTICS ring structure.
to control reading, writing, and execution. The association between segments
and rings is a policy decision with which we are not concerned here.
   A current-ring-number  counter is associated with each process, iden-
tifying the ring in which the process is executing currently. When a process is
executing in ring i, it cannot access a segment associated with ring j (j < i). It
can access a segment associated with ring k (k  i). The type of access, however,
is restricted according to the access bits associated with that segment.
   Domain switching in MULTICS occurs when a process crosses from one ring
to another by calling a procedure in a different ring. Obviously, this switch must
be done in a controlled manner; otherwise, a process could start executing in
ring 0, and no protection would be provided. To allow controlled domain
switching, we modify the ring field of the segment descriptor to include the
following:
·  Access bracket. A pair of integers, b1 and b2, such that b1  b2.
·  Limit. An integer b3 such that b3 > b2.
·  List of gates. Identifies the entry points (or gates) at which the segments
   may be called.
If a process executing in ring i calls a procedure (or segment) with access bracket
(b1,b2), then the call is allowed if b1  i  b2, and the current ring number of
the process remains i. Otherwise, a trap to the operating system occurs, and
the situation is handled as follows:
·  If i < b1, then the call is allowed to occur, because we have a transfer to a
   ring (or domain) with fewer privileges. However, if parameters are passed
   that refer to segments in a lower ring (that is, segments not accessible to
   the called procedure), then these segments must be copied into an area
   that can be accessed by the called procedure.
·  If i > b2, then the call is allowed to occur only if b3 is greater than or equal
   to i and the call has been directed to one of the designated entry points in



632   Chapter 14  Protection
      the list of gates. This scheme allows processes with limited access rights to
      call procedures in lower rings that have more access rights, but only in a
      carefully controlled manner.
      The main disadvantage of the ring (or hierarchical) structure is that it does
      not allow us to enforce the need-to-know principle. In particular, if an object
      must be accessible in domain Dj but not accessible in domain Di , then we must
      have j < i. But this requirement means that every segment accessible in Di is
      also accessible in Dj .
      The MULTICS protection system is generally more complex and less efficient
      than are those used in current operating systems. If protection interferes with
      the ease of use of the system or significantly decreases system performance,
      then its use must be weighed carefully against the purpose of the system. For
      instance, we would want to have a complex protection system on a computer
      used by a university to process students' grades and also used by students for
      classwork. A similar protection system would not be suited to a computer being
      used for number crunching, in which performance is of utmost importance. We
      would prefer to separate the mechanism from the protection policy, allowing
      the same system to have complex or simple protection depending on the needs
      of its users. To separate mechanism from policy, we require a more general
      model of protection.
14.4  Access Matrix
      Our general model of protection can be viewed abstractly as a matrix, called
      an access matrix. The rows of the access matrix represent domains, and the
      columns represent objects. Each entry in the matrix consists of a set of access
      rights. Because the column defines objects explicitly, we can omit the object
      name from the access right. The entry access(i,j) defines the set of operations
      that a process executing in domain Di can invoke on object Oj .
      To illustrate these concepts, we consider the access matrix shown in Figure
      14.3. There are four domains and four objects--three files (F1, F2, F3) and one
      laser printer. A process executing in domain D1 can read files F1 and F3. A
      process executing in domain D4 has the same privileges as one executing in
                               object
                                       F1           F2      F3       printer
                  domain
                  D1                   read                 read
                  D2                                                 print
                  D3                                read    execute
                  D4                   read                 read
                                       write                write
                                       Figure 14.3  Access  matrix.



                                                      14.4    Access Matrix             633
domain D1; but in addition, it can also write onto files F1 and F3. The laser
printer can be accessed only by a process executing in domain D2.
The access-matrix scheme provides us with the mechanism for specifying
a variety of policies. The mechanism consists of implementing the access
matrix and ensuring that the semantic properties we have outlined hold.
More specifically, we must ensure that a process executing in domain Di can
access only those objects specified in row i, and then only as allowed by the
access-matrix entries.
The access matrix can implement policy decisions concerning protection.
The policy decisions involve which rights should be included in the (i, j)th
entry. We must also decide the domain in which each process executes. This
last policy is usually decided by the operating system.
The users normally decide the contents of the access-matrix entries. When
a user creates a new object Oj , the column Oj is added to the access matrix
with the appropriate initialization entries, as dictated by the creator. The user
may decide to enter some rights in some entries in column j and other rights
in other entries, as needed.
The access matrix provides an appropriate mechanism for defining and
implementing strict control for both static and dynamic association between
processes and domains. When we switch a process from one domain to another,
we are executing an operation (switch) on an object (the domain). We can
control domain switching by including domains among the objects of the
access matrix. Similarly, when we change the content of the access matrix,
we are performing an operation on an object: the access matrix. Again, we
can control these changes by including the access matrix itself as an object.
Actually, since each entry in the access matrix can be modified individually,
we must consider each entry in the access matrix as an object to be protected.
Now, we need to consider only the operations possible on these new objects
(domains and the access matrix) and decide how we want processes to be able
to execute these operations.
Processes should be able to switch from one domain to another. Switching
from domain Di to domain Dj is allowed if and only if the access right switch
 access(i, j). Thus, in Figure 14.4, a process executing in domain D2 can switch
        object                               laser
                        F1    F2    F3       printer  D1      D2      D3        D4
domain
D1              read                read                      switch
D2                                           print                    switch    switch
D3                            read  execute
D4              read                read              switch
                write               write
Figure 14.4             Access matrix of Figure 14.3  with domains as objects.



634  Chapter 14       Protection
     to domain D3 or to domain D4. A process in domain D4 can switch to D1, and
     one in domain D1 can switch to D2.
         Allowing controlled change in the contents of the access-matrix entries
     requires three additional operations: copy, owner, and control. We examine
     these operations next.
         The ability to copy an access right from one domain (or row) of the access
     matrix to another is denoted by an asterisk (*) appended to the access right.
     The copy right allows the access right to be copied only within the column
     (that is, for the object) for which the right is defined. For example, in Figure
     14.5(a), a process executing in domain D2 can copy the read operation into any
     entry associated with file F2. Hence, the access matrix of Figure 14.5(a) can be
     modified to the access matrix shown in Figure 14.5(b).
         This scheme has two additional variants:
     1.     A right is copied from access(i, j) to access(k, j); it is then removed from
            access(i, j). This action is a of a right, rather than a copy.
     2.     Propagation of the copy right may be limited. That is, when the right
            R is copied from access(i, j) to access(k, j), only the right R (not R)
            is created. A process executing in domain Dk cannot further copy the
            right R.
     A system may select only one of these three copy rights, or it may provide
     all three by identifying them as separate rights: copy, transfer, and limited
     copy.
         We also need a mechanism to allow addition of new rights and removal of
     some rights. The owner right controls these operations. If access(i, j) includes
     the owner right, then a process executing in domain Di can add and remove
                                  object
                                          F1       F2              F3
                      domain
                      D1                  execute                  write*
                      D2                  execute  read*           execute
                      D3                  execute
                                              (a)
                                  object
                                          F1       F2              F3
                      domain
                      D1                  execute                  write*
                      D2                  execute  read*           execute
                      D3                  execute  read
                                              (b)
                      Figure 14.5         Access matrix with copy  rights.



                                                    14.4  Access   Matrix            635
        object               F1             F2            F3
domain
D1                           owner                        write
                             execute
                                            read*         read*
D2                                          owner         owner
                                                          write
D3                           execute
                                    (a)
        object               F1             F2            F3
domain
D1                           owner                        write
                             execute
                                            owner         read*
D2                                          read*         owner
                                            write*        write
D3                                          write         write
                                    (b)
Figure 14.6                  Access matrix  with owner    rights.
any right in any entry in column j. For example, in Figure 14.6(a), domain D1
is the owner of F1 and thus can add and delete any valid right in column F1.
Similarly, domain D2 is the owner of F2 and F3 and thus can add and remove
any valid right within these two columns. Thus, the access matrix of Figure
14.6(a) can be modified to the access matrix shown in Figure 14.6(b).
The copy and owner rights allow a process to change the entries in a
column. A mechanism is also needed to change the entries in a row. The
control right is applicable only to domain objects. If access(i, j) includes the
control right, then a process executing in domain Di can remove any access
right from row j. For example, suppose that, in Figure 14.4, we include the
control right in access(D2,  D4). Then, a process executing in domain D2
could modify domain D4, as shown in Figure 14.7.
The copy and owner rights provide us with a mechanism to limit the
propagation of access rights. However, they do not give us the appropriate tools
for preventing the propagation (or disclosure) of information. The problem of
guaranteeing that no information initially held in an object can migrate outside
of its execution environment is called the confinement problem. This problem
is in general unsolvable (see the bibliographical notes at the end of the chapter).
These operations on the domains and the access matrix are not in them-
selves important, but they illustrate the ability of the access-matrix model to
allow us to implement and control dynamic protection requirements. New
objects and new domains can be created dynamically and included in the



636   Chapter 14      Protection
                          object  F1       F2    F3       laser    D1      D2      D3      D4
                  domain                                  printer
                      D1          read           read                      switch
                      D2                                  print                    switch  switch
                                                                                           control
                      D3                   read  execute
                      D4          write          write             switch
                          Figure 14.7      Modified access matrix of Figure 14.4.
      access-matrix model. However, we have shown only that the basic mechanism
      exists. System designers and users must make the policy decisions concerning
      which domains are to have access to which objects in which ways.
14.5  Implementation of the Access Matrix
      How can the access matrix be implemented effectively? In general, the matrix
      will be sparse; that is, most of the entries will be empty. Although data-
      structure techniques are available for representing sparse matrices, they are
      not particularly useful for this application, because of the way in which
      the protection facility is used. Here, we first describe several methods of
      implementing the access matrix and then compare the methods.
      14.5.1      Global Table
      The simplest implementation of the access matrix is a global table consisting
      of  a  set  of  ordered     triples  <domain,     object,    rights-set>.            Whenever  an
      operation M is executed on an object Oj within domain Di , the global table
      is searched for a triple <Di , Oj , Rk>, with M  Rk. If this triple is found, the
      operation is allowed to continue; otherwise, an exception (or error) condition
      is raised.
             This implementation suffers from several drawbacks. The table is usually
      large and thus cannot be kept in main memory, so additional I/O is needed.
      Virtual memory techniques are often used for managing this table. In addition,
      it is difficult to take advantage of special groupings of objects or domains.
      For example, if everyone can read a particular object, this object must have a
      separate entry in every domain.
      14.5.2      Access Lists for Objects
      Each column in the access matrix can be implemented as an access list for
      one object, as described in Section 11.6.2. Obviously, the empty entries can be
      discarded. The resulting list for each object consists of ordered pairs <domain,
      rights-set>, which define all domains with a nonempty set of access rights
      for that object.
             This approach can be extended easily to define a list plus a default set of
      access rights. When an operation M on an object Oj is attempted in domain



                          14.5     Implementation of the Access Matrix                 637
Di , we search the access list for object Oj , looking for an entry <Di , Rk> with
M  Rk. If the entry is found, we allow the operation; if it is not, we check the
default set. If M is in the default set, we allow the access. Otherwise, access is
denied, and an exception condition occurs. For efficiency, we may check the
default set first and then search the access list.
14.5.3  Capability Lists for Domains
Rather than associating the columns of the access matrix with the objects as
access lists, we can associate each row with its domain. A capability list for
a domain is a list of objects together with the operations allowed on those
objects. An object is often represented by its physical name or address, called
a capability. To execute operation M on object Oj , the process executes the
operation M, specifying the capability (or pointer) for object Oj as a parameter.
Simple possession of the capability means that access is allowed.
   The capability list is associated with a domain, but it is never directly
accessible to a process executing in that domain. Rather, the capability list
is itself a protected object, maintained by the operating system and accessed
by the user only indirectly. Capability-based protection relies on the fact that
the capabilities are never allowed to migrate into any address space directly
accessible by a user process (where they could be modified). If all capabilities
are secure, the object they protect is also secure against unauthorized access.
   Capabilities  were  originally  proposed         as  a  kind  of  secure  pointer,  to
meet the need for resource protection that was foreseen as multiprogrammed
computer systems came of age. The idea of an inherently protected pointer
provides a foundation for protection that can be extended up to the application
level.
   To provide inherent protection, we must distinguish capabilities from other
kinds of objects, and they must be interpreted by an abstract machine on which
higher-level programs run. Capabilities are usually distinguished from other
data in one of two ways:
·  Each object has a tag to denote whether it is a capability or accessible
   data. The tags themselves must not be directly accessible by an application
   program. Hardware or firmware support may be used to enforce this
   restriction. Although only one bit is necessary to distinguish between
   capabilities and other objects, more bits are often used. This extension
   allows all objects to be tagged with their types by the hardware. Thus,
   the hardware can distinguish integers, floating-point numbers, pointers,
   Booleans, characters, instructions, capabilities, and uninitialized values by
   their tags.
·  Alternatively, the address space associated with a program can be split into
   two parts. One part is accessible to the program and contains the program's
   normal data and instructions. The other part, containing the capability list,
   is accessible only by the operating system. A segmented memory space
   (Section 8.4) is useful to support this approach.
Several capability-based protection systems have been developed; we describe
them briefly in Section 14.8. The Mach operating system also uses a version of
capability-based protection; it is described in Appendix B.



638  Chapter 14  Protection
     14.5.4  A Lock ­ Key Mechanism
     The lock ­key scheme is a compromise between access lists and capability
     lists. Each object has a list of unique bit patterns, called locks. Similarly, each
     domain has a list of unique bit patterns, called keys. A process executing in a
     domain can access an object only if that domain has a key that matches one of
     the locks of the object.
     As with capability lists, the list of keys for a domain must be managed
     by the operating system on behalf of the domain. Users are not allowed to
     examine or modify the list of keys (or locks) directly.
     14.5.5  Comparison
     As you might expect, choosing a technique for implementing an access matrix
     involves various trade-offs. Using a global table is simple; however, the table
     can be quite large and often cannot take advantage of special groupings of
     objects or domains. Access lists correspond directly to the needs of users.
     When a user creates an object, he can specify which domains can access the
     object, as well as what operations are allowed. However, because access-right
     information for a particular domain is not localized, determining the set of
     access rights for each domain is difficult. In addition, every access to the object
     must be checked, requiring a search of the access list. In a large system with
     long access lists, this search can be time consuming.
     Capability lists do not correspond directly to the needs of users, but they are
     useful for localizing information for a given process. The process attempting
     access must present a capability for that access. Then, the protection system
     needs only to verify that the capability is valid. Revocation of capabilities,
     however, may be inefficient (Section 14.7).
     The lock­key mechanism, as mentioned, is a compromise between access
     lists and capability lists. The mechanism can be both effective and flexible,
     depending on the length of the keys. The keys can be passed freely from
     domain to domain. In addition, access privileges can be effectively revoked by
     the simple technique of changing some of the locks associated with the object
     (Section 14.7).
     Most systems use a combination of access lists and capabilities. When a
     process first tries to access an object, the access list is searched. If access is
     denied, an exception condition occurs. Otherwise, a capability is created and
     attached to the process. Additional references use the capability to demonstrate
     swiftly that access is allowed. After the last access, the capability is destroyed.
     This strategy is used in the MULTICS system and in the CAL system.
     As an example of how such a strategy works, consider a file system in
     which each file has an associated access list. When a process opens a file, the
     directory structure is searched to find the file, access permission is checked, and
     buffers are allocated. All this information is recorded in a new entry in a file
     table associated with the process. The operation returns an index into this table
     for the newly opened file. All operations on the file are made by specification
     of the index into the file table. The entry in the file table then points to the file
     and its buffers. When the file is closed, the file-table entry is deleted. Since the
     file table is maintained by the operating system, the user cannot accidentally
     corrupt it. Thus, the user can access only those files that have been opened.



                                                     14.6              Access Control     639
      Since access is checked when the file is opened, protection is ensured. This
      strategy is used in the UNIX system.
      The right to access must still be checked on each access, and the file-table
      entry has a capability only for the allowed operations. If a file is opened for
      reading, then a capability for read access is placed in the file-table entry. If
      an attempt is made to write onto the file, the system identifies this protection
      violation by comparing the requested operation with the capability in the
      file-table entry.
14.6  Access Control
      In Section 11.6.2, we described how access controls can be used on files within
      a file system. Each file and directory is assigned an owner, a group, or possibly
      a list of users, and for each of those entities, access-control information is
      assigned. A similar function can be added to other aspects of a computer
      system. A good example of this is found in Solaris 10.
      Solaris 10 advances the protection available in the operating system by
      explicitly adding the principle of least privilege via role-based access control
      (RBAC). This facility revolves around privileges. A privilege is the right to
      execute a system call or to use an option within that system call (such as opening
      a file with write access). Privileges can be assigned to processes, limiting them
      to exactly the access they need to perform their work. Privileges and programs
      can also be assigned to roles. Users are assigned roles or can take roles based
      on passwords to the roles. In this way, a user can take a role that enables a
      privilege, allowing the user to run a program to accomplish a specific task,
      as depicted in Figure 14.8. This implementation of privileges decreases the
      security risk associated with superusers and setuid programs.
                                            user 1
                                            role 1
                                      privileges 1
                                      privileges 2
                                      executes with role 1 privileges
                                            process
                         Figure 14.8  Role-based access control in Solaris 10.



640   Chapter 14  Protection
         Notice that this facility is similar to the access matrix described in Section
      14.4. This relationship is further explored in the exercises at the end of the
      chapter.
14.7  Revocation of Access Rights
      In a dynamic protection system, we may sometimes need to revoke access
      rights to objects shared by different users. Various questions about revocation
      may arise:
      ·  Immediate versus delayed. Does revocation occur immediately, or is it
         delayed? If revocation is delayed, can we find out when it will take place?
      ·  Selective versus general. When an access right to an object is revoked,
         does it affect all the users who have an access right to that object, or can
         we specify a select group of users whose access rights should be revoked?
      ·  Partial versus total. Can a subset of the rights associated with an object be
         revoked, or must we revoke all access rights for this object?
      ·  Temporary versus permanent. Can access be revoked permanently (that
         is, the revoked access right will never again be available), or can access be
         revoked and later be obtained again?
         With an access-list scheme, revocation is easy. The access list is searched for
      any access rights to be revoked, and they are deleted from the list. Revocation
      is immediate and can be general or selective, total or partial, and permanent
      or temporary.
         Capabilities, however, present a much more difficult revocation problem,
      as mentioned earlier. Since the capabilities are distributed throughout the
      system, we must find them before we can revoke them. Schemes that implement
      revocation for capabilities include the following:
      ·  Reacquisition. Periodically, capabilities are deleted from each domain. If
         a process wants to use a capability, it may find that that capability has been
         deleted. The process may then try to reacquire the capability. If access has
         been revoked, the process will not be able to reacquire the capability.
      ·  Back-pointers. A list of pointers is maintained with each object, pointing
         to all capabilities associated with that object. When revocation is required,
         we can follow these pointers, changing the capabilities as necessary. This
         scheme was adopted in the MULTICS system. It is quite general, but its
         implementation is costly.
      ·  Indirection. The capabilities point indirectly, not directly, to the objects.
         Each capability points to a unique entry in a global table, which in turn
         points to the object. We implement revocation by searching the global table
         for the desired entry and deleting it. Then, when an access is attempted,
         the capability is found to point to an illegal table entry. Table entries can
         be reused for other capabilities without difficulty, since both the capability
         and the table entry contain the unique name of the object. The object for a



                                         14.8          Capability-Based Systems            641
         capability and its table entry must match. This scheme was adopted in the
         CAL system. It does not allow selective revocation.
      ·  Keys. A key is a unique bit pattern that can be associated with a capability.
         This key is defined when the capability is created, and it can be neither
         modified nor inspected by the process that owns the capability. A master
         key is associated with each object; it can be defined or replaced with
         the set-key operation. When a capability is created, the current value
         of the master key is associated with the capability. When the capability
         is exercised, its key is compared with the master key. If the keys match,
         the operation is allowed to continue; otherwise, an exception condition
         is raised. Revocation replaces the master key with a new value via the
         set-key operation, invalidating all previous capabilities for this object.
              This scheme does not allow selective revocation, since only one master
         key is associated with each object. If we associate a list of keys with each
         object, then selective revocation can be implemented. Finally, we can group
         all keys into one global table of keys. A capability is valid only if its
         key matches some key in the global table. We implement revocation by
         removing the matching key from the table. With this scheme, a key can be
         associated with several objects, and several keys can be associated with
         each object, providing maximum flexibility.
              In key-based schemes, the operations of defining keys, inserting them
         into lists, and deleting them from lists should not be available to all users.
         In particular, it would be reasonable to allow only the owner of an object
         to set the keys for that object. This choice, however, is a policy decision
         that the protection system can implement but should not define.
14.8  Capability-Based Systems
      In this section, we survey two capability-based protection systems. These
      systems differ in their complexity and in the types of policies that can be
      implemented    on  them.  Neither  system    is  widely  used,  but   both  provide
      interesting proving grounds for protection theories.
      14.8.1  An Example: Hydra
      Hydra   is  a  capability-based  protection  system   that  provides  considerable
      flexibility. The system implements a fixed set of possible access rights, including
      such basic forms of access as the right to read, write, or execute a memory
      segment. In addition, a user (of the protection system) can declare other rights.
      The interpretation of user-defined rights is performed solely by the user's
      program, but the system provides access protection for the use of these rights,
      as well as for the use of system-defined rights. These facilities constitute a
      significant development in protection technology.
         Operations  on  objects  are    defined   procedurally.  The  procedures    that
      implement such operations are themselves a form of object, and they are
      accessed indirectly by capabilities. The names of user-defined procedures must
      be identified to the protection system if it is to deal with objects of the user-
      defined type. When the definition of an object is made known to Hydra, the
      names of operations on the type become auxiliary rights. Auxiliary rights



642  Chapter 14  Protection
     can be described in a capability for an instance of the type. For a process to
     perform an operation on a typed object, the capability it holds for that object
     must contain the name of the operation being invoked among its auxiliary
     rights. This restriction enables discrimination of access rights to be made on an
     instance-by-instance and process-by-process basis.
     Hydra also provides rights amplification. This scheme allows a procedure
     to be certified as trustworthy to act on a formal parameter of a specified type
     on behalf of any process that holds a right to execute the procedure. The rights
     held by a trustworthy procedure are independent of, and may exceed, the
     rights held by the calling process. However, such a procedure must not be
     regarded as universally trustworthy (the procedure is not allowed to act on
     other types, for instance), and the trustworthiness must not be extended to any
     other procedures or program segments that might be executed by a process.
     Amplification allows implementation procedures access to the representa-
     tion variables of an abstract data type. If a process holds a capability to a typed
     object A, for instance, this capability may include an auxiliary right to invoke
     some operation P but does not include any of the so-called kernel rights, such
     as read, write, or execute, on the segment that represents A. Such a capability
     gives a process a means of indirect access (through the operation P) to the
     representation of A, but only for specific purposes.
     When a process invokes the operation P on an object A, however, the
     capability for access to A may be amplified as control passes to the code body
     of P. This amplification may be necessary to allow P the right to access the
     storage segment representing A so as to implement the operation that P defines
     on the abstract data type. The code body of P may be allowed to read or to
     write to the segment of A directly, even though the calling process cannot.
     On return from P, the capability for A is restored to its original, unamplified
     state. This case is a typical one in which the rights held by a process for access
     to a protected segment must change dynamically, depending on the task to
     be performed. The dynamic adjustment of rights is performed to guarantee
     consistency of a programmer-defined abstraction. Amplification of rights can
     be stated explicitly in the declaration of an abstract type to the Hydra operating
     system.
     When a user passes an object as an argument to a procedure, we may need
     to ensure that the procedure cannot modify the object. We can implement this
     restriction readily by passing an access right that does not have the modification
     (write) right. However, if amplification may occur, the right to modify may
     be reinstated. Thus, the user-protection requirement can be circumvented.
     In general, of course, a user may trust that a procedure performs its task
     correctly. This assumption is not always correct, however, because of hardware
     or software errors. Hydra solves this problem by restricting amplifications.
     The procedure-call mechanism of Hydra was designed as a direct solution
     to the problem of mutually suspicious subsystems. This problem is defined
     as follows. Suppose that a program can be invoked as a service by a number
     of different users (for example, a sort routine, a compiler, a game). When
     users invoke this service program, they take the risk that the program will
     malfunction and will either damage the given data or retain some access right to
     the data to be used (without authority) later. Similarly, the service program may
     have some private files (for accounting purposes, for example) that should not



                                         14.8  Capability-Based Systems               643
be accessed directly by the calling user program. Hydra provides mechanisms
for directly dealing with this problem.
A Hydra subsystem is built on top of its protection kernel and may require
protection of its own components. A subsystem interacts with the kernel
through calls on a set of kernel-defined primitives that define access rights to
resources defined by the subsystem. The subsystem designer can define policies
for use of these resources by user processes, but the policies are enforced by
use of the standard access protection provided by the capability system.
Programmers can make direct use of the protection system after acquaint-
ing themselves with its features in the appropriate reference manual. Hydra
provides a large library of system-defined procedures that can be called by
user programs. Programmers can explicitly incorporate calls on these system
procedures into their program code or can use a program translator that has
been interfaced to Hydra.
14.8.2  An Example: Cambridge CAP System
A different approach to capability-based protection has been taken in the
design of the Cambridge CAP system. CAP's capability system is simpler and
superficially less powerful than that of Hydra. However, closer examination
shows that it, too, can be used to provide secure protection of user-defined
objects. CAP has two kinds of capabilities. The ordinary kind is called a
data capability. It can be used to provide access to objects, but the only
rights provided are the standard read, write, and execute of the individual
storage segments associated with the object. Data capabilities are interpreted
by microcode in the CAP machine.
The second kind of capability is the so-called software capability, which
is protected, but not interpreted, by the CAP microcode. It is interpreted
by a protected (that is, privileged) procedure, which may be written by an
application programmer as part of a subsystem. A particular kind of rights
amplification is associated with a protected procedure. When executing the
code body of such a procedure, a process temporarily acquires the right to
read or write the contents of a software capability itself. This specific kind
of rights amplification corresponds to an implementation of the seal and
unseal primitives on capabilities. Of course, this privilege is still subject to
type verification to ensure that only software capabilities for a specified abstract
type are passed to any such procedure. Universal trust is not placed in any code
other than the CAP machine's microcode. (See the bibliographical notes at the
end of the chapter for references.)
The interpretation of a software capability is left completely to the sub-
system, through the protected procedures it contains. This scheme allows a
variety of protection policies to be implemented. Although programmers can
define their own protected procedures (any of which might be incorrect), the
security of the overall system cannot be compromised. The basic protection
system will not allow an unverified, user-defined, protected procedure access
to any storage segments (or capabilities) that do not belong to the protection
environment in which it resides. The most serious consequence of an insecure
protected procedure is a protection breakdown of the subsystem for which that
procedure has responsibility.



644   Chapter 14    Protection
      The designers of the CAP system have noted that the use of software
      capabilities allowed them to realize considerable economies in formulating
      and implementing protection policies commensurate with the requirements of
      abstract resources. However, subsystem designers who want to make use of
      this facility cannot simply study a reference manual, as is the case with Hydra.
      Instead, they must learn the principles and techniques of protection, since the
      system provides them with no library of procedures.
14.9  Language-Based Protection
      To the degree that protection is provided in existing computer systems, it is
      usually achieved through an operating-system kernel, which acts as a security
      agent to inspect and validate each attempt to access a protected resource. Since
      comprehensive access validation may be a source of considerable overhead,
      either we must give it hardware support to reduce the cost of each validation,
      or we must allow the system designer to compromise the goals of protection.
      Satisfying all these goals is difficult if the flexibility to implement protection
      policies is restricted by the support mechanisms provided or if protection
      environments are made larger than necessary to secure greater operational
      efficiency.
      As operating systems have become more complex, and particularly as they
      have attempted to provide higher-level user interfaces, the goals of protection
      have become much more refined. The designers of protection systems have
      drawn   heavily  on  ideas     that  originated    in  programming  languages       and
      especially on the concepts of abstract data types and objects. Protection systems
      are now concerned not only with the identity of a resource to which access is
      attempted but also with the functional nature of that access. In the newest
      protection systems, concern for the function to be invoked extends beyond
      a set of system-defined functions, such as standard file-access methods, to
      include functions that may be user-defined as well.
      Policies for resource use may also vary, depending on the application, and
      they may be subject to change over time. For these reasons, protection can no
      longer be considered a matter of concern only to the designer of an operating
      system. It should also be available as a tool for use by the application designer,
      so that resources of an application subsystem can be guarded against tampering
      or the influence of an error.
      14.9.1  Compiler-Based Enforcement
      At this point, programming languages enter the picture. Specifying the desired
      control of access to a shared resource in a system is making a declarative
      statement about the resource. This kind of statement can be integrated into a
      language by an extension of its typing facility. When protection is declared
      along   with  data  typing,    the   designer  of  each  subsystem  can  specify    its
      requirements for protection, as well as its need for use of other resources in a
      system. Such a specification should be given directly as a program is composed,
      and in the language in which the program itself is stated. This approach has
      several significant advantages:



                                     14.9  Language-Based Protection                 645
   1.  Protection needs are simply declared, rather than programmed as a
       sequence of calls on procedures of an operating system.
   2.  Protection requirements can be stated independently of the facilities
       provided by a particular operating system.
   3.  The means for enforcement need not be provided by the designer of a
       subsystem.
   4.  A declarative notation is natural because access privileges are closely
       related to the linguistic concept of data type.
       A variety of techniques can be provided by a programming-language
implementation to enforce protection, but any of these must depend on some
degree of support from an underlying machine and its operating system. For
example, suppose a language is used to generate code to run on the Cambridge
CAP system. On this system, every storage reference made on the underlying
hardware occurs indirectly through a capability. This restriction prevents any
process from accessing a resource outside of its protection environment at
any time. However, a program may impose arbitrary restrictions on how
a  resource  can   be  used  during  execution   of     a  particular  code  segment.
We     can  implement  such  restrictions  most  readily   by  using   the   software
capabilities provided by CAP. A language implementation might provide
standard protected procedures to interpret software capabilities that would
realize the protection policies that could be specified in the language. This
scheme puts policy specification at the disposal of the programmers, while
freeing them from implementing its enforcement.
       Even if a system does not provide a protection kernel as powerful as those
of Hydra or CAP, mechanisms are still available for implementing protection
specifications given in a programming language. The principal distinction is
that the security of this protection will not be as great as that supported by
a protection kernel, because the mechanism must rely on more assumptions
about the operational state of the system. A compiler can separate references
for which it can certify that no protection violation could occur from those
for which a violation might be possible, and it can treat them differently. The
security provided by this form of protection rests on the assumption that the
code generated by the compiler will not be modified prior to or during its
execution.
       What, then, are the relative merits of enforcement based solely on a kernel,
as opposed to enforcement provided largely by a compiler?
·      Security. Enforcement by a kernel provides a greater degree of security
       of the protection system itself than does the generation of protection-
       checking code by a compiler. In a compiler-supported scheme, security
       rests on correctness of the translator, on some underlying mechanism of
       storage management that protects the segments from which compiled
       code is executed, and, ultimately, on the security of files from which a
       program is loaded. Some of these considerations also apply to a software-
       supported protection kernel, but to a lesser degree, since the kernel may
       reside in fixed physical storage segments and may be loaded only from
       a designated file. With a tagged-capability system, in which all address



646  Chapter 14     Protection
        computation is performed either by hardware or by a fixed microprogram,
        even greater security is possible. Hardware-supported protection is also
        relatively immune to protection violations that might occur as a result of
        either hardware or system software malfunction.
     ·  Flexibility. There are limits to the flexibility of a protection kernel in
        implementing a user-defined policy, although it may supply adequate
        facilities  for  the    system  to  provide  enforcement       of  its  own  policies.
        With a programming language, protection policy can be declared and
        enforcement provided as needed by an implementation. If a language
        does  not   provide     sufficient  flexibility,  it  can  be  extended  or  replaced
        with less disturbance than would be caused by the modification of an
        operating-system kernel.
     ·  Efficiency. The greatest efficiency is obtained when enforcement of protec-
        tion is supported directly by hardware (or microcode). Insofar as software
        support is required, language-based enforcement has the advantage that
        static access enforcement can be verified off-line at compile time. Also,
        since an intelligent compiler can tailor the enforcement mechanism to
        meet the specified need, the fixed overhead of kernel calls can often be
        avoided.
        In summary, the specification of protection in a programming language
     allows the high-level description of policies for the allocation and use of
     resources. A language implementation can provide software for protection
     enforcement when automatic hardware-supported checking is unavailable. In
     addition, it can interpret protection specifications to generate calls on whatever
     protection system is provided by the hardware and the operating system.
        One way of making protection available to the application program is
     through the use of a software capability that could be used as an object
     of computation. Inherent in this concept is the idea that certain program
     components might have the privilege of creating or examining these software
     capabilities. A capability-creating program would be able to execute a primitive
     operation that would seal a data structure, rendering the latter's contents
     inaccessible to any program components that did not hold either the seal or
     the unseal privilege. Such components might copy the data structure or pass
     its address to other program components, but they could not gain access to
     its contents. The reason for introducing such software capabilities is to bring a
     protection mechanism into the programming language. The only problem with
     the concept as proposed is that the use of the seal and unseal operations takes
     a procedural approach to specifying protection. A nonprocedural or declarative
     notation seems a preferable way to make protection available to the application
     programmer.
        What is needed is a safe, dynamic access-control mechanism for distribut-
     ing capabilities to system resources among user processes. To contribute to the
     overall reliability of a system, the access-control mechanism should be safe
     to use. To be useful in practice, it should also be reasonably efficient. This
     requirement has led to the development of a number of language constructs
     that allow the programmer to declare various restrictions on the use of a specific
     managed resource. (See the bibliographical notes for appropriate references.)
     These constructs provide mechanisms for three functions:



                                         14.9   Language-Based Protection              647
1.   Distributing capabilities safely and efficiently among customer processes.
     In particular, mechanisms ensure that a user process will use the managed
     resource only if it was granted a capability to that resource.
2.   Specifying the type of operations that a particular process may invoke on
     an allocated resource (for example, a reader of a file should be allowed
     only to read the file, whereas a writer should be able both to read and
     to write). It should not be necessary to grant the same set of rights to
     every user process, and it should be impossible for a process to enlarge
     its set of access rights, except with the authorization of the access-control
     mechanism.
3.   Specifying the order in which a particular process may invoke the various
     operations of a resource (for example, a file must be opened before it can
     be read). It should be possible to give two processes different restrictions
     on the order in which they can invoke the operations of the allocated
     resource.
     The incorporation of protection concepts into programming languages, as
a practical tool for system design, is in its infancy. Protection will likely become
a matter of greater concern to the designers of new systems with distributed
architectures and increasingly stringent requirements on data security. Then
the importance of suitable language notations in which to express protection
requirements will be recognized more widely.
14.9.2  Protection in Java
Because Java was designed to run in a distributed environment, the Java
virtual machine --or JVM--has many built-in protection mechanisms. Java
programs are composed of classes, each of which is a collection of data fields
and functions (called methods) that operate on those fields. The JVM loads a
class in response to a request to create instances (or objects) of that class. One of
the most novel and useful features of Java is its support for dynamically loading
untrusted classes over a network and for executing mutually distrusting classes
within the same JVM.
     Because of these capabilities, protection is a paramount concern. Classes
running in the same JVM may be from different sources and may not be equally
trusted. As a result, enforcing protection at the granularity of the JVM process
is insufficient. Intuitively, whether a request to open a file should be allowed
will generally depend on which class has requested the open. The operating
system lacks this knowledge.
     Thus, such protection decisions are handled within the JVM. When the
JVM  loads  a  class,  it  assigns  the  class  to  a  protection  domain  that  gives
the permissions of that class. The protection domain to which the class is
assigned depends on the URL from which the class was loaded and any digital
signatures on the class file. (Digital signatures are covered in Section 15.4.1.3.)
A configurable policy file determines the permissions granted to the domain
(and its classes). For example, classes loaded from a trusted server might be
placed in a protection domain that allows them to access files in the user's
home directory, whereas classes loaded from an untrusted server might have
no file access permissions at all.



648  Chapter 14      Protection
            It can be complicated for the JVM to determine what class is responsible for a
     request to access a protected resource. Accesses are often performed indirectly,
     through system libraries or other classes. For example, consider a class that
     is not allowed to open network connections. It could call a system library to
     request the load of the contents of a URL. The JVM must decide whether or not
     to open a network connection for this request. But which class should be used
     to determine if the connection should be allowed, the application or the system
     library?
            The philosophy adopted in Java is to require the library class to explicitly
     permit a network connection. More generally, in order to access a protected
     resource, some method in the calling sequence that resulted in the request must
     explicitly assert the privilege to access the resource. By doing so, this method
     takes responsibility for the request. Presumably, it will also perform whatever
     checks are necessary to ensure the safety of the request. Of course, not every
     method is allowed to assert a privilege; a method can assert a privilege only if
     its class is in a protection domain that is itself allowed to exercise the privilege.
            This implementation approach is called stack inspection. Every thread
     in the JVM has an associated stack of its ongoing method invocations. When
     a caller may not be trusted, a method executes an access request within a
     doPrivileged block to perform the access to a protected resource directly or
     indirectly. doPrivileged() is a static method in the AccessController class
     that is passed a class with a run() method to invoke. When the doPrivileged
     block is entered, the stack frame for this method is annotated to indicate this
     fact. Then, the contents of the block are executed. When an access to a protected
     resource is subsequently requested, either by this method or a method it
     calls, a call to checkPermissions() is used to invoke stack inspection to
     determine if the request should be allowed. The inspection examines stack
     frames on the calling thread's stack, starting from the most recently added
     frame and working toward the oldest. If a stack frame is first found that has the
     doPrivileged() annotation, then checkPermissions() returns immediately
     and silently, allowing the access. If a stack frame is first found for which
     access is disallowed based on the protection domain of the method's class,
     then checkPermissions() throws an AccessControlException. If the stack
     inspection      exhausts  the   stack    without  finding  either  type   of  frame,   then
     whether access is allowed depends on the implementation (for example, some
     implementations of the JVM may allow access, while other implementations
     may not).
            Stack inspection is illustrated in Figure 14.9. Here, the gui() method of
     a class in the untrusted applet protection domain performs two operations,
     first  a   get()  and     then  an  open().     The  former  is    an  invocation  of  the
     get() method of a class in the URL loader protection domain, which is
     permitted to open() sessions to sites in the lucent.com domain, in particular
     a proxy server proxy.lucent.com for retrieving URLs. For this reason, the
     untrusted applet's get() invocation will succeed: the checkPermissions()
     call   in  the  networking      library  encounters  the   stack   frame  of  the  get()
     method, which performed its open() in a doPrivileged block. However,
     the untrusted applet's open() invocation will result in an exception, because
     the    checkPermissions()       call     finds  no   doPrivileged      annotation  before
     encountering the stack frame of the gui() method.



                                                                  14.10  Summary           649
protection    untrusted        URL loader                                networking
domain:       applet
socket        none             *.lucent.com:80, connect                  any
permission:
class:        gui:...          ...get(URL u):                            ...open(Addr a):
               get(url);       doPrivileged {                            checkPermission
               ...open(addr);     open(`proxy.lucent.com:80');           (a, connect);
                               }                                         ...connect (a);
                               ...request u from proxy
                               Figure 14.9     Stack inspection.
Of course, for stack inspection to work, a program must be unable to
modify the annotations on its own stack frame or to otherwise manipulate
stack inspection. This is one of the most important differences between Java
and many other languages (including C++). A Java program cannot directly
access memory; it can manipulate only an object for which it has a reference.
References cannot be forged, and manipulations are made only through well-
defined interfaces. Compliance is enforced through a sophisticated collection of
load-time and run-time checks. As a result, an object cannot manipulate its run-
time stack, because it cannot get a reference to the stack or other components
of the protection system.
More generally, Java's load-time and run-time checks enforce type safety of
Java classes. Type safety ensures that classes cannot treat integers as pointers,
write past the end of an array, or otherwise access memory in arbitrary ways.
Rather, a program can access an object only via the methods defined on that
object by its class. This is the foundation of Java protection, since it enables a
class to effectively encapsulate and protect its data and methods from other
classes loaded in the same JVM. For example, a variable can be defined as
private so that only the class that contains it can access it or protected so
that it can be accessed only by the class that contains it, subclasses of that class,
or classes in the same package. Type safety ensures that these restrictions can
be enforced.
14.10 Summary
Computer systems contain many objects, and they need to be protected from
misuse. Objects may be hardware (such as memory, CPU time, and I/O devices)
or software (such as files, programs, and semaphores). An access right is
permission to perform an operation on an object. A domain is a set of access
rights. Processes execute in domains and may use any of the access rights in
the domain to access and manipulate objects. During its lifetime, a process may
be either bound to a protection domain or allowed to switch from one domain
to another.



650  Chapter 14  Protection
     The   access      matrix  is  a   general  model  of  protection  that  provides     a
     mechanism for protection without imposing a particular protection policy on
     the system or its users. The separation of policy and mechanism is an important
     design property.
     The access matrix is sparse. It is normally implemented either as access lists
     associated with each object or as capability lists associated with each domain.
     We can include dynamic protection in the access-matrix model by considering
     domains and the access matrix itself as objects. Revocation of access rights in a
     dynamic protection model is typically easier to implement with an access-list
     scheme than with a capability list.
     Real systems are much more limited than the general model and tend to
     provide protection only for files. UNIX is representative, providing read, write,
     and execution protection separately for the owner, group, and general public
     for each file. MULTICS uses a ring structure in addition to file access. Hydra, the
     Cambridge CAP system, and Mach are capability systems that extend protection
     to user-defined software objects. Solaris 10 implements the principle of least
     privilege via role-based access control, a form of the access matrix.
     Language-based protection provides finer-grained arbitration of requests
     and privileges than the operating system is able to provide. For example, a
     single Java JVM can run several threads, each in a different protection class. It
     enforces the resource requests through sophisticated stack inspection and via
     the type safety of the language.
Practice Exercises
     14.1  What are the main differences between capability lists and access lists?
     14.2  A Burroughs B7000/B6000 MCP file can be tagged as sensitive data.
           When such a file is deleted, its storage area is overwritten by some
           random bits. For what purpose would such a scheme be useful?
     14.3  In a ring-protection system, level 0 has the greatest access to objects,
           and level n (where n > 0) has fewer access rights. The access rights of
           a program at a particular level in the ring structure are considered a
           set of capabilities. What is the relationship between the capabilities of
           a domain at level j and a domain at level i to an object (for j > i)?
     14.4  The RC 4000 system, among others, has defined a tree of processes
           (called a process tree) such that all the descendants of a process can
           be given resources (objects) and access rights by their ancestors only.
           Thus, a descendant can never have the ability to do anything that its
           ancestors cannot do. The root of the tree is the operating system, which
           has the ability to do anything. Assume that the set of access rights is
           represented by an access matrix, A. A(x,y) defines the access rights of
           process x to object y. If x is a descendant of z, what is the relationship
           between A(x,y) and A(z,y) for an arbitrary object y?
     14.5  What protection problems may arise if a shared stack is used for
           parameter passing?



                                                                      Exercises         651
14.6       Consider a computing environment where a unique number is associ-
           ated with each process and each object in the system. Suppose that we
           allow a process with number n to access an object with number m only
           if n > m. What type of protection structure do we have?
14.7       Consider      a  computing  environment   where     a  process   is  given   the
           privilege of accessing an object only n times. Suggest a scheme for
           implementing this policy.
14.8       If all the access rights to an object are deleted, the object can no longer
           be accessed. At this point, the object should also be deleted, and the
           space it occupies should be returned to the system. Suggest an efficient
           implementation of this scheme.
14.9       Why is it difficult to protect a system in which users are allowed to do
           their own I/O?
14.10      Capability lists are usually kept within the address space of the user.
           How does the system ensure that the user cannot modify the contents
           of the list?
Exercises
14.11      Consider the ring-protection scheme in MULTICS. If we were to imple-
           ment the system calls of a typical operating system and store them in a
           segment associated with ring 0, what should be the values stored in the
           ring field of the segment descriptor? What happens during a system
           call when a process executing in a higher-numbered ring invokes a
           procedure in ring 0?
14.12      The access-control matrix can be used to determine whether a process
           can switch from, say, domain A to domain B and enjoy the access
           privileges of domain B. Is this approach equivalent to including the
           access privileges of domain B in those of domain A?
14.13      Consider a computer system in which computer games can be played
           by students only between 10 P.M. and 6 A.M., by faculty members
           between 5 P.M. and 8 A.M., and by the computer center staff at all
           times. Suggest a scheme for implementing this policy efficiently.
14.14      What hardware features does a computer system need for efficient
           capability    manipulation?  Can  these   features     be  used  for  memory
           protection?
14.15      Discuss the strengths and weaknesses of implementing an access matrix
           using access lists that are associated with objects.
14.16      Discuss the strengths and weaknesses of implementing an access matrix
           using capabilities that are associated with domains.
14.17      Explain why a capability-based system such as Hydra provides greater
           flexibility   than  the  ring-protection  scheme  in   enforcing     protection
           policies.



652  Chapter 14       Protection
     14.18     Discuss the need for rights amplification in Hydra. How does this
               practice compare with the cross-ring calls in a ring-protection scheme?
     14.19     What is the need-to-know principle? Why is it important for a protec-
               tion system to adhere to this principle?
     14.20     Discuss which of the following systems allow module designers to
               enforce the need-to-know principle.
               a.     The MULTICS ring-protection scheme
               b.     Hydra's capabilities
               c.     JVM's stack-inspection scheme
     14.21     Describe how the Java protection model would be compromised if a
               Java program were allowed to directly alter the annotations of its stack
               frame.
     14.22     How are the access-matrix facility and the role-based access-control
               facility similar? How do they differ?
     14.23     How does the principle of least privilege aid in the creation of protection
               systems?
     14.24     How can systems that implement the principle of least privilege still
               have protection failures that lead to security violations?
Bibliographical Notes
     The access-matrix model of protection between domains and objects was
     developed by [Lampson (1969)] and [Lampson (1971)]. [Popek (1974)] and
     [Saltzer  and        Schroeder  (1975)]   provided    excellent  surveys   on   the  subject
     of protection. [Harrison et al. (1976)] used a formal version of the access-
     matrix model to enable them to prove properties of a protection system
     mathematically.
     The concept of a capability evolved from Iliffe's and Jodeit's codewords,
     which were implemented in the Rice University computer ([Iliffe and Jodeit
     (1962)]). The term capability was introduced by [Dennis and Horn (1966)].
     The Hydra system was described by [Wulf et al. (1981)]. The CAP system
     was described by [Needham and Walker (1977)]. [Organick (1972)] discussed
     the MULTICS ring-protection system.
     Revocation           was     discussed   by  [Redell  and  Fabry  (1974)],     [Cohen  and
     Jefferson (1975)], and [Ekanadham and Bernstein (1979)]. The principle of
     separation       of  policy  and  mechanism    was    advocated   by      the  designer  of
     Hydra ([Levin et al. (1975)]). The confinement problem was first discussed
     by [Lampson (1973)] and was further examined by [Lipner (1975)].
     The use of higher-level languages for specifying access control was sug-
     gested    first  by  [Morris    (1973)],  who  proposed    the    use  of  the  seal   and
     unseal operations discussed in Section 14.9. [Kieburtz and Silberschatz (1978)],
     [Kieburtz and Silberschatz (1983)], and [McGraw and Andrews (1979)] pro-
     posed various language constructs for dealing with general dynamic-resource-
     management schemes. [Jones and Liskov (1978)] considered how a static access-



                                                                  Bibliography      653
control scheme can be incorporated in a programming language that supports
abstract data types. The use of minimal operating-system support to enforce
protection was advocated by the Exokernel Project ([Ganger et al. (2002)],
[Kaashoek et al. (1997)]). Extensibility of system code through language-based
protection mechanisms was discussed in [Bershad et al. (1995)]. Other tech-
niques for enforcing protection include sandboxing ([Goldberg et al. (1996)])
and software fault isolation ([Wahbe et al. (1993)]). The issues of lowering the
overhead associated with protection costs and enabling user-level access to
networking devices were discussed in [McCanne and Jacobson (1993)] and
[Basu et al. (1995)].
More detailed analyses of stack inspection, including comparisons with
other approaches to Java security, can be found in [Wallach et al. (1997)] and
[Gong et al. (1997)].
Bibliography
[Basu et al. (1995)]     A. Basu, V. Buch, W. Vogels, and T. von Eicken, "U-Net:
A  User-Level         Network  Interface  for  Parallel  and  Distributed   Computing",
Proceedings of the ACM Symposium on Operating Systems Principles (1995).
[Bershad et al. (1995)]   B.   N.  Bershad,    S.  Savage,    P.  Pardyak,  E.  G.  Sirer,
M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers, "Extensibility, Safety and
Performance in the SPIN Operating System", Proceedings of the ACM Symposium
on Operating Systems Principles (1995), pages 267­284.
[Cohen and Jefferson (1975)]       E. S. Cohen and D. Jefferson, "Protection in the
Hydra Operating System", Proceedings of the ACM Symposium on Operating
Systems Principles (1975), pages 141­160.
[Dennis and Horn (1966)]       J. B. Dennis and E. C. V. Horn, "Programming Seman-
tics for Multiprogrammed Computations", Communications of the ACM, Volume
9, Number 3 (1966), pages 143­155.
[Ekanadham and Bernstein (1979)]          K. Ekanadham and A. J. Bernstein, "Con-
ditional Capabilities", IEEE Transactions on Software Engineering, Volume SE-5,
Number 5 (1979), pages 458­464.
[Ganger et al. (2002)]    G. R. Ganger, D. R. Engler, M. F. Kaashoek, H. M. Briceno,
R. Hunt, and T. Pinckney, "Fast and Flexible Application-Level Networking on
Exokernel Systems", ACM Transactions on Computer Systems, Volume 20, Number
1 (2002), pages 49­83.
[Goldberg et al. (1996)]       I. Goldberg, D. Wagner, R. Thomas, and E. A. Brewer,
"A Secure Environment for Untrusted Helper Applications", Proceedings of the
6th Usenix Security Symposium (1996).
[Gong et al. (1997)]      L. Gong, M. Mueller, H. Prafullchandra, and R. Schemers,
"Going Beyond the Sandbox: An Overview of the New Security Architecture in
the Java Development Kit 1.2", Proceedings of the USENIX Symposium on Internet
Technologies and Systems (1997).



654  Chapter 14  Protection
     [Harrison et al. (1976)]    M. A. Harrison, W. L. Ruzzo, and J. D. Ullman, "Protec-
     tion in Operating Systems", Communications of the ACM, Volume 19, Number 8
     (1976), pages 461­471.
     [Iliffe and Jodeit (1962)]      J. K. Iliffe and J. G. Jodeit, "A Dynamic Storage Alloca-
     tion System", Computer Journal, Volume 5, Number 3 (1962), pages 200­209.
     [Jones and Liskov (1978)]       A. K. Jones and B. H. Liskov, "A Language Extension
     for Expressing Constraints on Data Access", Communications of the ACM, Volume
     21, Number 5 (1978), pages 358­367.
     [Kaashoek et al. (1997)]        M. F. Kaashoek, D. R. Engler, G. R. Ganger, H. M.
     Briceno, R. Hunt, D. Mazieres, T. Pinckney, R. Grimm, J. Jannotti, and K. Macken-
     zie,  "Application     Performance  and       Flexibility  on   Exokernel   Systems",  Pro-
     ceedings of the ACM Symposium on Operating Systems Principles (1997), pages
     52­65.
     [Kieburtz and Silberschatz (1978)]        R. B. Kieburtz and A. Silberschatz, "Capabil-
     ity Managers", IEEE Transactions on Software Engineering, Volume SE-4, Number
     6 (1978), pages 467­477.
     [Kieburtz and Silberschatz (1983)]        R. B. Kieburtz and A. Silberschatz, "Access
     Right Expressions", ACM Transactions on Programming Languages and Systems,
     Volume 5, Number 1 (1983), pages 78­96.
     [Lampson (1969)]       B. W. Lampson, "Dynamic Protection Structures", Proceedings
     of the AFIPS Fall Joint Computer Conference (1969), pages 27­38.
     [Lampson (1971)]       B. W. Lampson, "Protection", Proceedings of the Fifth Annual
     Princeton Conference on Information Systems Science (1971), pages 437­443.
     [Lampson (1973)]       B.   W.  Lampson,  "A  Note    on   the  Confinement  Problem",
     Communications of the ACM, Volume 10, Number 16 (1973), pages 613­615.
     [Levin et al. (1975)]     R. Levin, E. S. Cohen, W. M. Corwin, F. J. Pollack, and
     W. A. Wulf, "Policy/Mechanism Separation in Hydra", Proceedings of the ACM
     Symposium on Operating Systems Principles (1975), pages 132­140.
     [Lipner (1975)]   S. Lipner, "A Comment on the Confinement Problem", Operating
     System Review, Volume 9, Number 5 (1975), pages 192­196.
     [McCanne and Jacobson (1993)]       S. McCanne and V. Jacobson, "The BSD Packet
     Filter: A New Architecture for User-level Packet Capture", USENIX Winter
     (1993), pages 259­270.
     [McGraw and Andrews (1979)]         J.    R.  McGraw       and  G.  R.  Andrews,  "Access
     Control in Parallel Programs", IEEE Transactions on Software Engineering, Volume
     SE-5, Number 1 (1979), pages 1­9.
     [Morris (1973)]   J. H. Morris, "Protection in Programming Languages", Commu-
     nications of the ACM, Volume 16, Number 1 (1973), pages 15­21.
     [Needham and Walker (1977)]         R.  M.    Needham      and  R.  D.  H.  Walker,    "The
     Cambridge CAP Computer and Its Protection System", Proceedings of the Sixth
     Symposium on Operating System Principles (1977), pages 1­10.



                                                                   Bibliography         655
[Organick (1972)]        E.  I.  Organick,  The  Multics  System:  An  Examination  of  Its
Structure, MIT Press (1972).
[Popek (1974)]        G. J. Popek, "Protection Structures", Computer, Volume 7, Num-
ber 6 (1974), pages 22­33.
[Redell and Fabry (1974)]        D. D. Redell and R. S. Fabry, "Selective Revocation
of Capabilities", Proceedings of the IRIA International Workshop on Protection in
Operating Systems (1974), pages 197­210.
[Saltzer and Schroeder (1975)]   J. H. Saltzer and M. D. Schroeder, "The Protec-
tion of Information in Computer Systems", Proceedings of the IEEE (1975), pages
1278­1308.
[Wahbe et al. (1993)]        R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham,
"Efficient  Software-Based       Fault      Isolation",  ACM  SIGOPS   Operating  Systems
Review, Volume 27, Number 5 (1993), pages 203­216.
[Wallach et al. (1997)]      D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten,
"Extensible Security Architectures for Java", Proceedings of the ACM Symposium
on Operating Systems Principles (1997), pages 116­128.
[Wulf et al. (1981)]     W. A. Wulf, R. Levin, and S. P. Harbison, Hydra/C.mmp: An
Experimental Computer System, McGraw-Hill (1981).



