Now we outline the Boyer-Moore algorithm itself. If the first comparison of the
rightmost character in the pattern with the corresponding character c in the text
fails, the algorithm does exactly the same thing as Horspool's algorithm. Namely,
it shifts the pattern to the right by the number of characters retrieved from the
table precomputed as explained earlier.
The two algorithms act differently, however, after some positive number k
(0 < k < m) of the pattern's characters are matched successfully before a mismatch
is encountered:
s0  ...                           c           si-k+1            ...               si  ...   sn-1  text
    p0               ...   pm-k-1                pm-k           ...         pm-1                  pattern
In this situation, the Boyer-Moore algorithm determines the shift size by consid-
ering two quantities. The first one is guided by the text's character c that caused
a mismatch with its counterpart in the pattern. Accordingly, it is called the bad-
symbol shift. The reasoning behind this shift is the reasoning we used in Hor-
spool's algorithm. If c is not in the pattern, we shift the pattern to just pass this
c in the text. Conveniently, the size of this shift can be computed by the formula
t1(c) - k where t1(c) is the entry in the precomputed table used by Horspool's
algorithm (see above) and k is the number of matched characters:
s0  ...                        c           si-k+1            ...               si     ...   sn-1  text
    p0           ...      pm-k-1              pm-k           ...            pm-1                  pattern
                                                 p0          ...                      pm-1
For example, if we search for the pattern BARBER in some text and match the last
two characters before failing on letter S in the text, we can shift the pattern by
t1(S) - 2 = 6 - 2 = 4 positions:
                 s0   ...                        S     E     R                        ...   sn-1
                               B     A     R     B     E     R
                                                       B     A     R     B     E   R
The same formula can also be used when the mismatching character c of the
text occurs in the pattern, provided t1(c) - k > 0. For example, if we search for the
pattern BARBER in some text and match the last two characters before failing on
letter A, we can shift the pattern by t1(A) - 2 = 4 - 2 = 2 positions:
                 s0       ...                       A     E     R                     ...   sn-1
                                  B     A     R     B     E     R
                                              B     A     R     B     E     R
     If t1(c) - k  0, we obviously do not want to shift the pattern by 0 or a negative
     number of positions. Rather, we can fall back on the brute-force thinking and
     simply shift the pattern by one position to the right.
     To summarize, the bad-symbol shift d1 is computed by the Boyer-Moore
     algorithm either as t1(c) - k if this quantity is positive and as 1 if it is negative
     or zero. This can be expressed by the following compact formula:
                                   d1 = max{t1(c) - k, 1}.                            (7.2)
     The second type of shift is guided by a successful match of the last k > 0
     characters of the pattern. We refer to the ending portion of the pattern as its suffix
     of size k and denote it suff (k). Accordingly, we call this type of shift the good-suffix
     shift. We now apply the reasoning that guided us in filling the bad-symbol shift
     table, which was based on a single alphabet character c, to the pattern's suffixes
     of sizes 1, . . . , m - 1 to fill in the good-suffix shift table.
     Let us first consider the case when there is another occurrence of suff (k) in
     the pattern or, to be more accurate, there is another occurrence of suff (k) not
     preceded by the same character as in its rightmost occurrence. (It would be useless
     to shift the pattern to match another occurrence of suff (k) preceded by the same
     character because this would simply repeat a failed trial.) In this case, we can shift
     the pattern by the distance d2 between such a second rightmost occurrence (not
     preceded by the same character as in the rightmost occurrence) of suff (k) and its
     rightmost occurrence. For example, for the pattern ABCBAB, these distances for
     k = 1 and 2 will be 2 and 4, respectively:
                                      k     pattern         d2
                                      1     ABCBAB          2
                                      2     ABCBAB          4
     What is to be done if there is no other occurrence of suff (k) not preceded by
     the same character as in its rightmost occurrence? In most cases, we can shift the
     pattern by its entire length m. For example, for the pattern DBCBAB and k = 3, we
     can shift the pattern by its entire length of 6 characters:
     s0  ...                       c     B  A  B                           ...  sn-1
              D                 B  C     B  A  B
                                                   D  B  C  B   A       B
     Unfortunately, shifting the pattern by its entire length when there is no other
     occurrence of suff (k) not preceded by the same character as in its rightmost
     occurrence is not always correct. For example, for the pattern ABCBAB and k = 3,
     shifting by 6 could miss a matching substring that starts with the text's AB aligned
     with the last two characters of the pattern:
        s0  ...              c     B  A  B  C  B  A  B         ...  sn-1
                       A  B  C     B  A  B
                                            A  B  C  B   A  B
Note that the shift by 6 is correct for the pattern DBCBAB but not for ABCBAB,
because the latter pattern has the same substring AB as its prefix (beginning part
of the pattern) and as its suffix (ending part of the pattern). To avoid such an
erroneous shift based on a suffix of size k, for which there is no other occurrence
in the pattern not preceded by the same character as in its rightmost occurrence,
we need to find the longest prefix of size l < k that matches the suffix of the same
size l. If such a prefix exists, the shift size d2 is computed as the distance between
this prefix and the corresponding suffix; otherwise, d2 is set to the pattern's length
m. As an example, here is the complete list of the d2 values--the good-suffix table
of the Boyer-Moore algorithm--for the pattern ABCBAB:
                                k        pattern     d2
                                1        ABCBAB      2
                                2        ABCBAB      4
                                3        ABCBAB      4
                                4        ABCBAB      4
                                5        ABCBAB      4
Now we are prepared to summarize the Boyer-Moore algorithm in its entirety.
The Boyer-Moore algorithm
Step 1 For a given pattern and the alphabet used in both the pattern and the
        text, construct the bad-symbol shift table as described earlier.
Step 2 Using the pattern, construct the good-suffix shift table as described
        earlier.
Step 3 Align the pattern against the beginning of the text.
Step 4  Repeat the following step until either a matching substring is found or
        the pattern reaches beyond the last character of the text. Starting with
        the last character in the pattern, compare the corresponding characters
        in the pattern and the text until either all m character pairs are matched
        (then stop) or a mismatching pair is encountered after k  0 character
        pairs are matched successfully. In the latter case, retrieve the entry
        t1(c) from the c's column of the bad-symbol table where c is the text's
        mismatched character. If k > 0, also retrieve the corresponding d2
        entry from the good-suffix table. Shift the pattern to the right by the
                  number of positions computed by the formula
                                            d=     d1           if k = 0,     (7.3)
                                                   max{d1, d2}  if k > 0,
                  where d1 = max{t1(c) - k, 1}.
          Shifting by the maximum of the two available shifts when k > 0 is quite log-
     ical. The two shifts are based on the observations--the first one about a text's
     mismatched character, and the second one about a matched group of the pattern's
     rightmost characters--that imply that shifting by less than d1 and d2 characters, re-
     spectively, cannot lead to aligning the pattern with a matching substring in the text.
     Since we are interested in shifting the pattern as far as possible without missing a
     possible matching substring, we take the maximum of these two numbers.
     EXAMPLE      As a complete example, let us consider searching for the pattern
     BAOBAB in a text made of English letters and spaces. The bad-symbol table looks
     as follows:
                  c      A      B           C   D      ...  O   ...  Z     _
                  t1(c)  1      2           6   6      6    3   6    6     6
     The good-suffix table is filled as follows:
                                         k      pattern     d2
                                         1      BAOBAB      2
                                         2      BAOBAB      5
                                         3      BAOBAB      5
                                         4      BAOBAB      5
                                         5      BAOBAB      5
          The actual search for this pattern in the text given in Figure 7.3 proceeds as
     follows. After the last B of the pattern fails to match its counterpart K in the text,
     the algorithm retrieves t1(K) = 6 from the bad-symbol table and shifts the pat-
     tern by d1 = max{t1(K) - 0, 1} = 6 positions to the right. The new try successfully
     matches two pairs of characters. After the failure of the third comparison on the
     space character in the text, the algorithm retrieves t1(      ) = 6 from the bad-symbol
     table and d2 = 5 from the good-suffix table to shift the pattern by max{d1, d2} =
     max{6 - 2, 5} = 5. Note that on this iteration it is the good-suffix rule that leads
     to a farther shift of the pattern.
          The next try successfully matches just one pair of B's. After the failure of
     the next comparison on the space character in the text, the algorithm retrieves
     t1(  ) = 6 from the bad-symbol table and d2 = 2 from the good-suffix table to shift
B  E  S  S  _       K   N   E   W     _  A    B  O      U  T      _  B  A  O        B  A  B     S
B  A  O  B  A       B
d1 = t1(K) - 0 = 6      B   A   O     B  A    B
                        d1 = t1( ) - 2 = 4    B  A      O  B      A  B
                        d2 = 5                d1 = t1(  )-1=5
                        d = max{4, 5} = 5     d2 = 2
                                              d = max{5, 2} = 5
                                                                     B  A  O        B  A  B
                    FIGURE 7.3 Example of string matching with the   Boyer-Moore    algorithm.
                    the pattern by max{d1,d2} = max{6 - 1, 2} = 5. Note that on this iteration it is the
                    bad-symbol rule that leads to a farther shift of the pattern. The next try finds a
                    matching substring in the text after successfully matching all six characters of the
                    pattern with their counterparts in the text.
                        When searching for the first occurrence of the pattern, the worst-case effi-
                    ciency of the Boyer-Moore algorithm is known to be linear. Though this algorithm
                    runs very fast, especially on large alphabets (relative to the length of the pattern),
                    many people prefer its simplified versions, such as Horspool's algorithm, when
                    dealing with natural-language­like strings.
                    Exercises 7.2
                    1.  Apply Horspool's algorithm to search for the pattern BAOBAB in the text
                                                 BESS KNEW ABOUT BAOBABS
                    2.  Consider the problem of searching for genes in DNA sequences using Hor-
                        spool's algorithm. A DNA sequence is represented by a text on the alphabet
                        {A, C, G, T}, and the gene or gene segment is the pattern.
                        a.  Construct the shift table for the following gene segment of your chromo-
                            some 10:
                                                           TCCTATTCTT
                        b. Apply Horspool's algorithm to locate the above pattern in the following
                            DNA sequence:
                                         TTATAGATCTCGTATTCTTTTATAGATCTCCTATTCTT
     3.   How many character comparisons will be made by Horspool's algorithm in
          searching for each of the following patterns in the binary text of 1000 zeros?
              a. 00001       b. 10000  c. 01010
     4.   For searching in a text of length n for a pattern of length m (n  m) with
          Horspool's algorithm, give an example of
              a. worst-case input.     b. best-case input.
     5.   Is it possible for Horspool's algorithm to make more character comparisons
          than the brute-force algorithm would make in searching for the same pattern
          in the same text?
     6.   If Horspool's algorithm discovers a matching substring, how large a shift
          should it make to search for a next possible match?
     7.   How many character comparisons will the Boyer-Moore algorithm make in
          searching for each of the following patterns in the binary text of 1000 zeros?
              a. 00001       b. 10000  c. 01010
     8.   a.  Would the Boyer-Moore algorithm work correctly with just the bad-symbol
              table to guide pattern shifts?
          b.  Would the Boyer-Moore algorithm work correctly with just the good-suffix
              table to guide pattern shifts?
     9.   a.  If the last characters of a pattern and its counterpart in the text do match,
              does Horspool's algorithm have to check other characters right to left, or
              can it check them left to right too?
          b.  Answer the same question for the Boyer-Moore algorithm.
     10.  Implement Horspool's algorithm, the Boyer-Moore algorithm, and the brute-
          force algorithm of Section 3.2 in the language of your choice and run an
          experiment to compare their efficiencies for matching
          a.  random binary patterns in random binary texts.
          b. random natural-language patterns in natural-language texts.
     11.  You are given two strings S and T , each n characters long. You have to
          establish whether one of them is a right cyclic shift of the other. For example,
          PLEA is a right cyclic shift of LEAP, and vice versa. (Formally, T is a right cyclic
          shift of S if T can be obtained by concatenating the (n - i)-character suffix of
          S and the i-character prefix of S for some 1  i  n.)
          a.  Design a space-efficient algorithm for the task. Indicate the space and time
              efficiencies of your algorithm.
          b. Design a time-efficient algorithm for the task. Indicate the time and space
              efficiencies of your algorithm.
