Breadth-First Search
If depth-first search is a traversal for the brave (the algorithm goes as far from
"home" as it can), breadth-first search is a traversal for the cautious. It proceeds in
a concentric manner by visiting first all the vertices that are adjacent to a starting
vertex, then all unvisited vertices two edges apart from it, and so on, until all
the vertices in the same connected component as the starting vertex are visited.
If there still remain unvisited vertices, the algorithm has to be restarted at an
arbitrary vertex of another connected component of the graph.
It is convenient to use a queue (note the difference from depth-first search!)
to trace the operation of breadth-first search. The queue is initialized with the
traversal's starting vertex, which is marked as visited. On each iteration, the
algorithm identifies all unvisited vertices that are adjacent to the front vertex,
marks them as visited, and adds them to the queue; after that, the front vertex is
removed from the queue.
Similarly to a DFS traversal, it is useful to accompany a BFS traversal by con-
structing the so-called breadth-first search forest. The traversal's starting vertex
serves as the root of the first tree in such a forest. Whenever a new unvisited vertex
is reached for the first time, the vertex is attached as a child to the vertex it is being
reached from with an edge called a tree edge. If an edge leading to a previously
visited vertex other than its immediate predecessor (i.e., its parent in the tree)
is encountered, the edge is noted as a cross edge. Figure 3.11 provides an exam-
ple of a breadth-first search traversal, with the traversal queue and corresponding
breadth-first search forest shown.
     g                                  h
                                                                     a                g
        a                     e
                c          f               a1 c2 d3 e4 f5 b6  c      d     e       h            j
                                           g7 h8 j9 i10
        d                     b
                                                              f            b       i
     j                                  i
                   (a)                     (b)                                (c)
     FIGURE  3.11  Example of a BFS traversal. (a) Graph. (b) Traversal queue, with the
                   numbers indicating the order in which the vertices are visited, i.e., added
                   to (and removed from) the queue. (c) BFS forest with the tree and cross
                   edges shown with solid and dotted lines, respectively.
        Here is pseudocode of the breadth-first search.
     ALGORITHM     BFS(G)
        //Implements a breadth-first search traversal of a given graph
        //Input: Graph G =    V, E
        //Output: Graph G with its vertices marked with consecutive integers
        //         in the order they are visited by the BFS traversal
        mark each vertex in V with 0 as a mark of being "unvisited"
        count  0
        for each vertex v in V do
             if v is marked with 0
                   bfs(v)
        bfs(v)
        //visits all the unvisited vertices connected to vertex v
        //by a path and numbers them in the order they are visited
        //via global variable count
        count  count + 1;     mark v with count and initialize a queue with v
        while the queue is not empty do
             for each vertex w in V adjacent to the front vertex do
                   if w is marked with 0
                   count  count + 1;       mark w with count
                   add w to the queue
             remove the front vertex from the queue
                                                                        a
a            b             c  d
                                                                b          e
e            f             g  h                       c            f
                                 d                           g
                  (a)                                              (b)
FIGURE 3.12  Illustration of the BFS-based algorithm for finding a minimum-edge path.
             (a) Graph. (b) Part of its BFS tree that identifies the minimum-edge path
             from a to g.
Breadth-first search has the same efficiency as depth-first search: it is in
(|V |2) for the adjacency matrix representation and in       (|V | + |E|) for the adja-
cency list representation. Unlike depth-first search, it yields a single ordering of
vertices because the queue is a FIFO (first-in first-out) structure and hence the
order in which vertices are added to the queue is the same order in which they
are removed from it. As to the structure of a BFS forest of an undirected graph,
it can also have two kinds of edges: tree edges and cross edges. Tree edges are the
ones used to reach previously unvisited vertices. Cross edges connect vertices to
those visited before, but, unlike back edges in a DFS tree, they connect vertices
either on the same or adjacent levels of a BFS tree.
BFS can be used to check connectivity and acyclicity of a graph, essentially
in the same manner as DFS can. It is not applicable, however, for several less
straightforward applications such as finding articulation points. On the other hand,
it can be helpful in some situations where DFS cannot. For example, BFS can
be used for finding a path with the fewest number of edges between two given
vertices. To do this, we start a BFS traversal at one of the two vertices and stop
it as soon as the other vertex is reached. The simple path from the root of the
BFS tree to the second vertex is the path sought. For example, path a - b - c - g
in the graph in Figure 3.12 has the fewest number of edges among all the paths
between vertices a and g. Although the correctness of this application appears to
stem immediately from the way BFS operates, a mathematical proof of its validity
is not quite elementary (see, e.g., [Cor09, Section 22.2]).
Table 3.1 summarizes the main facts about depth-first search and breadth-first
search.
         TABLE 3.1 Main facts about depth-first search (DFS)
             and breadth-first search (BFS)
                                                DFS                  BFS
         Data structure                         a stack              a queue
         Number of vertex orderings             two orderings        one ordering
         Edge types (undirected graphs)         tree and back edges  tree and cross edges
         Applications                           connectivity,        connectivity,
                                                acyclicity,          acyclicity,
                                                articulation points  minimum-edge paths
         Efficiency for adjacency matrix        (|V 2|)              (|V 2|)
         Efficiency for adjacency lists         (|V | + |E|)         (|V | + |E|)
     Exercises 3.5
     1. Consider the following graph.
                                          f     b        c        g
                                             d       a         e
         a.  Write down the adjacency matrix and adjacency lists specifying this graph.
             (Assume that the matrix rows and columns and vertices in the adjacency
             lists follow in the alphabetical order of the vertex labels.)
         b.  Starting at vertex a and resolving ties by the vertex alphabetical order,
             traverse the graph by depth-first search and construct the corresponding
             depth-first search tree. Give the order in which the vertices were reached
             for the first time (pushed onto the traversal stack) and the order in which
             the vertices became dead ends (popped off the stack).
     2.  If we define sparse graphs as graphs for which |E|  O(|V |), which implemen-
         tation of DFS will have a better time efficiency for such graphs, the one that
         uses the adjacency matrix or the one that uses the adjacency lists?
     3.  Let G be a graph with n vertices and m edges.
         a.  True or false: All its DFS forests (for traversals starting at different ver-
             tices) will have the same number of trees?
         b. True or false: All its DFS forests will have the same number of tree edges
             and the same number of back edges?
     4.  Traverse the graph of Problem 1 by breadth-first search and construct the
         corresponding breadth-first search tree. Start the traversal at vertex a and
         resolve ties by the vertex alphabetical order.
5.   Prove that a cross edge in a BFS tree of an undirected graph can connect
     vertices only on either the same level or on two adjacent levels of a BFS tree.
6.   a.  Explain how one can check a graph's acyclicity by using breadth-first
         search.
     b.  Does either of the two traversals--DFS or BFS--always find a cycle faster
         than the other? If you answer yes, indicate which of them is better and
         explain why it is the case; if you answer no, give two examples supporting
         your answer.
7.   Explain how one can identify connected components of a graph by using
     a.  a depth-first search.
     b. a breadth-first search.
8.   A graph is said to be bipartite if all its vertices can be partitioned into two
     disjoint subsets X and Y so that every edge connects a vertex in X with a vertex
     in Y . (One can also say that a graph is bipartite if its vertices can be colored in
     two colors so that every edge has its vertices colored in different colors; such
     graphs are also called 2-colorable.) For example, graph (i) is bipartite while
     graph (ii) is not.
                         x1      y1   x3                  a        b
                         y2      x2   y3                  c        d
                                 (i)                         (ii)
     a.  Design a DFS-based algorithm for checking whether a graph is bipartite.
     b. Design a BFS-based algorithm for checking whether a graph is bipartite.
9.   Write a program that, for a given graph, outputs:
     a.  vertices of each connected component
     b. its cycle or a message that the graph is acyclic
10.  One can model a maze by having a vertex for a starting point, a finishing point,
     dead ends, and all the points in the maze where more than one path can be
     taken, and then connecting the vertices according to the paths in the maze.
     a.  Construct such a graph for the following maze.
          b. Which traversal--DFS or BFS--would you use if you found yourself in a
             maze and why?
     11.  Three Jugs   Sime´ on Denis Poisson (1781­1840), a famous French mathemati-
          cian and physicist, is said to have become interested in mathematics after
          encountering some version of the following old puzzle. Given an 8-pint jug
          full of water and two empty jugs of 5- and 3-pint capacity, get exactly 4 pints
          of water in one of the jugs by completely filling up and/or emptying jugs into
          others. Solve this puzzle by using breadth-first search.
     SUMMARY
          Brute force is a straightforward approach to solving a problem, usually directly
          based on the problem statement and definitions of the concepts involved.
          The principal strengths of the brute-force approach are wide applicability and
          simplicity; its principal weakness is the subpar efficiency of most brute-force
          algorithms.
          A first application of the brute-force approach often results in an algorithm
          that can be improved with a modest amount of effort.
          The following noted algorithms can be considered as examples of the brute-
          force approach:
          .  definition-based algorithm for matrix multiplication
          .  selection sort
          .  sequential search
          .  straightforward string-matching algorithm
          Exhaustive search is a brute-force approach to combinatorial problems. It
          suggests generating each and every combinatorial object of the problem,
          selecting those of them that satisfy all the constraints, and then finding a
          desired object.
          The traveling salesman problem, the knapsack problem, and the assignment
          problem are typical examples of problems that can be solved, at least
          theoretically, by exhaustive-search algorithms.
          Exhaustive search is impractical for all but very small instances of problems
          it can be applied to.
          Depth-first search (DFS) and breadth-first search (BFS) are two principal
          graph-traversal algorithms. By representing a graph in a form of a depth-first
          or breadth-first search forest, they help in the investigation of many important
          properties of the graph. Both algorithms have the same time efficiency:
             (|V |2) for the adjacency matrix representation and    (|V | + |E|) for the
          adjacency list representation.
