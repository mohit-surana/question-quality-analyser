Marking cellsDesign an algorithm for the following task. For any even n, mark n cells on an infinite sheet of graph paper so that each marked cell has an odd number of marked neighbors. Two cells are considered neighbors if they are next to each other either horizontally or vertically but not diagonally. The marked cells must form a contiguous region, i.e., a region in which there is a path between any pair of marked cells that goes through a sequence of marked neighbors. [Kor05] Design a decrease-by-one algorithm for generating the power set of a set of n elements. (The power set of a set S is the set of all the subsets of S, including the empty set and S itself.) Consider the following algorithm to check connectivity of a graph defined by its adjacency matrix. ALGORITHM  Connected(A[0..n 1, 0..n 1])
//Input: Adjacency matrix A[0..n 1, 0..n 1]) of an undirected graph G
//Output: 1 (true) if G is connected and 0 (false) if it is not if n = 1 return 1  //one-vertex graph is connected by definition else
if not Connected(A[0..n 2, 0..n 2]) return 0 else for j  0 to n 2 do if A[n 1, j ] return 1 return 0 Does this algorithm work correctly for every undirected graph with n > 0 vertices? If you answer yes, indicate the algorithm's efficiency class in the worst case; if you answer no, explain why. Team ordering  You have the results of a completed round-robin tournament in which n teams played each other once. Each game ended either with a victory for one of the teams or with a tie. Design an algorithm that lists the teams in a sequence so that every team did not lose the game with the team listed immediately after it. What is the time efficiency class of your algorithm? Apply insertion sort to sort the list E, X, A, M, P , L, E in alphabetical order. a.  What sentinel should be put before the first element of an array being sorted in order to avoid checking the in-bound condition j  0 on each iteration of the inner loop of insertion sort? b.  Is the sentinel version in the same efficiency class as the original version? Is it possible to implement insertion sort for sorting linked lists? Will it have the same O(n2) time efficiency as the array version? Compare the text's implementation of insertion sort with the following version. ALGORITHM  InsertSort2(A[0..n 1]) for i  1 to n 1 do j i-1 while j  0 and A[j ] > A[j + 1] do swap(A[j ], A[j + 1]) j j -1 What is the time efficiency of this algorithm? How is it compared to that of the version given in Section 4.1? Let A[0..n 1] be an array of n sortable elements. (For simplicity, you may assume that all the elements are distinct.) A pair (A[i], A[j ]) is called an inversion if i < j and A[i] > A[j ]. a.  What arrays of size n have the largest number of inversions and what is this number? Answer the same questions for the smallest number of inversions. b. Show that the average-case number of key comparisons in insertion sort is given by the formula Cavg(n)n2  .
4 Shellsort (more accurately Shell's sort) is an important sorting algorithm that works by applying insertion sort to each of several interleaving sublists of a given list. On each pass through the list, the sublists in question are formed by stepping through the list with an increment hi taken from some predefined decreasing sequence of step sizes, h1 > . . . > hi > . . . > 1, which must end with
(The algorithm works for any such sequence, though some sequences are known to yield a better efficiency than others. For example, the sequence 1,
4, 13, 40, 121, . . . , used, of course, in reverse, is known to be among the best for this purpose.) a.  Apply shellsort to the list S, H, E, L, L, S, O, R, T , I, S, U, S, E, F, U, L b.  Is shellsort a stable sorting algorithm? c.  Implement shellsort, straight insertion sort, selection sort, and bubble sort in the language of your choice and compare their performance on random arrays of sizes 10n for n = 2, 3, 4, 5, and 6 as well as on increasing and decreasing arrays of these sizes. Apply the DFS-based algorithm to solve the topological sorting problem for the following digraphs: ab a  b   c   d c de g e   f   g f
(a) (b) a.  Prove that the topological sorting problem has a solution if and only if it is a dag. b. For a digraph with n vertices, what is the largest number of distinct solutions the topological sorting problem can have? a.  What is the  time efficiency   of  the DFS-based  algorithm   for  topological sorting? b. How can one modify the DFS-based algorithm to avoid reversing the vertex ordering generated by DFS? Can one use the order in which vertices are pushed onto the DFS stack
(instead of the order they are popped off it) to solve the topological sorting problem? Apply the source-removal algorithm to the digraphs of Problem 1 above. a.  Prove that a nonempty dag must have at least one source. b.  How would you find a source (or determine that such a vertex does not exist) in a digraph represented by its adjacency matrix? What is the time efficiency of this operation? c.  How would you find a source (or determine that such a vertex does not exist) in a digraph represented by its adjacency lists? What is the time efficiency of this operation? Can you implement the source-removal algorithm for a digraph represented by its adjacency lists so that its running time is in O(|V | + |E|)? Implement the two topological sorting algorithms in the language of your choice. Run an experiment to compare their running times. A digraph is called strongly connected if for any pair of two distinct vertices u and v there exists a directed path from u to v and a directed path from v to u. In general, a digraph's vertices can be partitioned into disjoint maximal subsets of vertices that are mutually accessible via directed paths; these subsets are called strongly connected components of the digraph. There are two DFSbased algorithms for identifying strongly connected components. Here is the simpler (but somewhat less efficient) one of the two: Step 1  Perform a DFS traversal of the digraph given and number its vertices in the order they become dead ends. Step 2  Reverse the directions of all the edges of the digraph. Step 3  Perform a DFS traversal of the new digraph by starting (and, if necessary, restarting) the traversal at the highest numbered vertex among still unvisited vertices. The strongly connected components are exactly the vertices of the DFS trees obtained during the last traversal. a.  Apply this  algorithm to  the following  digraph  to  determine its strongly connected components: a  b c de
f  g h b.  What is the time efficiency class of this algorithm? Give separate answers for the adjacency matrix representation and adjacency list representation of an input digraph. c.  How many strongly connected components does a dag have? Spider's webA spider sits at the bottom (point S) of its web, and a fly sits at the top (F). How many different ways can the spider reach the fly by moving along the web's lines in the directions indicated by the arrows? [Kor05] F
S Is it realistic to implement an algorithm that requires generating all permutations of a 25-element set on your computer? What about all the subsets of such a set? Generate all permutations of {1, 2, 3, 4} by a.  the bottom-up minimal-change algorithm. b. the Johnson-Trotter algorithm. c.  the lexicographic-order algorithm. Apply LexicographicPermute to multiset {1, 2, 2, 3}. Does it generate correctly all the permutations in lexicographic order? Consider the following implementation of the algorithm for generating permutations discovered by B. Heap [Hea63]. ALGORITHM  HeapPermute(n)
//Implements Heap's algorithm for generating permutations
//Input: A positive integer n and a global array A[.n]
//Output: All permutations of elements of A if n = 1 write A else
for i  1 to n do HeapPermute(n 1) if n is odd swap A[1] and A[n] else swap A[i] and A[n] a.  Trace the algorithm by hand for n = 2, 3, and 4. b. Prove the correctness of Heap's algorithm. c.  What is the time efficiency of HeapPermute? Generate all the subsets of a four-element set A = {a1, a2, a3, a4} by each of the two algorithms outlined in this section. What simple trick would make the bit string­based algorithm generate subsets in squashed order? Write pseudocode for a recursive algorithm for generating all 2n bit strings of length n. Write a nonrecursive algorithm for generating 2n bit strings of length n that implements bit strings as arrays and does not use binary additions. a.  Generate the binary reflexive Gray code of order 4. b.  Trace the following nonrecursive algorithm to generate the binary reflexive Gray code of order 4. Start with the n-bit string of all 0's. For i = 1, 2, . . . , 2n-1, generate the ith bit string by flipping bit b in the previous bit string, where b is the position of the least significant 1 in the binary representation of i. Design a decrease-and-conquer algorithm for generating all combinations of k items chosen from n, i.e., all k-element subsets of a given n-element set. Is your algorithm a minimal-change algorithm? Gray code and the Tower of Hanoi a.  Show that the disk moves made in the classic recursive algorithm for the Tower of Hanoi puzzle can be used for generating the binary reflected Gray code. b. Show how the binary reflected Gray code can be used for solving the Tower of Hanoi puzzle. Fair attraction  In olden days, one could encounter the following attraction at a fair. A light bulb was connected to several switches in such a way that it lighted up only when all the switches were closed. Each switch was controlled by a push button; pressing the button toggled the switch, but there was no way to know the state of the switch. The object was to turn the light bulb on. Design an algorithm to turn on the light bulb with the minimum number of button pushes needed in the worst case for n switches. Cutting a stick A stick n inches long needs to be cut into n 1-inch pieces. Outline an algorithm that performs this task with the minimum number of cuts if several pieces of the stick can be cut at the same time. Also give a formula for the minimum number of cuts. Design a decrease-by-half algorithm for computinglog2 n  and determine its time efficiency. a.  What is the largest number of key comparisons made by binary search in searching for a key in the following array?
3  14   27  31  39  42  55  70   74  81  85  93  98 b. List all the keys of this array that will require the largest number of key comparisons when searched for by binary search. c.  Find the average number of key comparisons made by binary search in a successful search in this array. Assume that each key is searched for with the same probability. d. Find the average number of key comparisons made by binary search in an unsuccessful search in this array. Assume that searches for keys in each of the 14 intervals formed by the array's elements are equally likely. Estimate how many times faster an average successful search will be in a sorted array of one million elements if it is done by binary search versus sequential search. The time efficiency of sequential search does not depend on whether a list is implemented as an array or as a linked list. Is it also true for searching a sorted list by binary search? a.  Design a version of binary search that uses only two-way comparisons such as  and =. Implement your algorithm in the language of your choice and carefully debug it: such programs are notorious for being prone to bugs. b. Analyze the time efficiency of the two-way comparison version designed in part a. Picture guessing A version of the popular problem-solving task involves presenting people with an array of 42 pictures--seven rows of six pictures each-and asking them to identify the target picture by asking questions that can be answered yes or no. Further, people are then required to identify the picture with as few questions as possible. Suggest the most efficient algorithm for this problem and indicate the largest number of questions that may be necessary. Consider ternary search--the following algorithm for searching in a sorted array A[0..n 1]. If n = 1, simply compare the search key K with the single element of the array; otherwise, search recursively by comparing K with A[ n/3 ], and if K is larger, compare it with A[ 2n/3 ] to determine in which third of the array to continue the search. a.  What design technique is this algorithm based on? b.  Set up a recurrence for the number of key comparisons in the worst case. You may assume that n = 3k. c.  Solve the recurrence for n = 3k. d. Compare this algorithm's efficiency with that of binary search. An array A[0..n 2] contains n 1 integers from 1 to n in increasing order.
(Thus one integer in this range is missing.) Design the most efficient algorithm you can to find the missing integer and indicate its time efficiency. a.  Write pseudocode for the divide-into-three algorithm for the fake-coin problem. Make sure that your algorithm handles properly all values of n, not only those that are multiples of 3. b.  Set up a recurrence relation for the number of weighings in the divide-intothree algorithm for the fake-coin problem and solve it for n = 3k. c.  For large values of n, about how many times faster is this algorithm than the one based on dividing coins into two piles? Your answer should not depend on n. a.  Apply the Russian peasant algorithm to compute 26 . 47. b. From the standpoint of time efficiency, does it matter whether we multiply n by m or m by n by the Russian peasant algorithm? a.  Write pseudocode for the Russian peasant multiplication algorithm. b. What is the time efficiency class of Russian peasant multiplication? Find J (40)--the solution to the Josephus problem for n = 40. Prove that the solution to the Josephus problem is 1 for every n that is a power of 2. For the Josephus problem, a.  compute J (n) for n = 1, 2, . . . , 15. b. discern a pattern in the solutions for the first fifteen values of n and prove its general validity. c.  prove the validity of getting J (n) by a 1-bit cyclic shift left of the binary representation of n. a.  If we measure an instance size of computing the greatest common divisor of m and n by the size of the second number n, by how much can the size decrease after one iteration of Euclid's algorithm? b. Prove that an instance size will always decrease at least by a factor of two after two successive iterations of Euclid's algorithm. Apply quickselect to find the median of the list of numbers 9, 12, 5, 17, 20,
30, 8. Write pseudocode for a nonrecursive implementation of quickselect. Derive the formula underlying interpolation search. Give an example of the worst-case input for interpolation search and show that the algorithm is linear in the worst case. a.  Find the smallest value of n for which log2 log2 n + 1 is greater than 6. b.  Determine which, if any, of the following assertions are true:
i. log log n  o(log n)  ii. log log n(log n)  iii. log log n   (log n) a.  Outline an algorithm for finding the largest key in a binary search tree. Would you classify your algorithm as a variable-size-decrease algorithm? b. What is the time efficiency class of your algorithm in the worst case? a.  Outline an algorithm for deleting a key from a binary search tree. Would you classify this algorithm as a variable-size-decrease algorithm? b. What is the time efficiency class of your algorithm in the worst case? Outline a variable-size-decrease algorithm for constructing an Eulerian circuit in a connected graph with all vertices of even degrees. Mise`re one-pile Nim  Consider the so-called mise`re version of the one-pile Nim, in which the player taking the last chip loses the game. All the other conditions of the game remain the same, i.e., the pile contains n chips and on each move a player takes at least one but no more than m chips. Identify the winning and losing positions (for the player to move next) in this game. a.  Moldy chocolate   Two players take turns by breaking an m × n chocolate bar, which has one spoiled 1 × 1 square. Each break must be a single straight line cutting all the way across the bar along the boundaries between the squares. After each break, the player who broke the bar last eats the piece that does not contain the spoiled square.The player left with the spoiled square loses the game. Is it better to go first or second in this game? b.  Write an interactive program to play this game with the computer. Your program should make a winning move in a winning position and a random legitimate move in a losing position. Flipping pancakes There are n pancakes all of different sizes that are stacked on top of each other. You are allowed to slip a flipper under one of the pancakes and flip over the whole stack above the flipper. The purpose is to arrange pancakes according to their size with the biggest at the bottom. (You can see a visualization of this puzzle on the Interactive Mathematics Miscellany and Puzzles site [Bog].) Design an algorithm for solving this puzzle. You need to search for a given number in an n × n matrix in which every row and every column is sorted in increasing order. Can you design a O(n) algorithm for this problem? [Laa10] a.  Write pseudocode for a divide-and-conquer algorithm for finding the position of the largest element in an array of n numbers. b.  What will be your algorithm's output for arrays with several elements of the largest value? c.  Set up and solve a recurrence relation for the number of key comparisons made by your algorithm. d.  How does this algorithm compare with the brute-force algorithm for this problem? a.  Write pseudocode for a divide-and-conquer algorithm for finding values of both the largest and smallest elements in an array of n numbers. b.  Set up and solve (for n = 2k) a recurrence relation for the number of key comparisons made by your algorithm. c.  How does this algorithm compare with the brute-force algorithm for this problem? a.  Write pseudocode for a divide-and-conquer algorithm for the exponentiation problem of computing an where n is a positive integer. b.  Set up and solve a recurrence relation for the number of multiplications made by this algorithm. As we shall see in Section 12, this theoretical minimum is  log2 n!n log2 n 44n . c.  How does this algorithm compare with the brute-force algorithm for this problem? As mentioned in Chapter 2, logarithm bases are irrelevant in most contexts arising in analyzing an algorithm's efficiency class. Is this true for both assertions of the Master Theorem that include logarithms? Find the order of growth for solutions of the following recurrences. a.  T (n) = 4T (n/2) + n, T (1) = 1 b.  T (n) = 4T (n/2) + n2, T (1) = 1 c.  T (n) = 4T (n/2) + n3, T (1) = 1 Apply mergesort to sort the list E, X, A, M, P, L, E in alphabetical order. Is mergesort a stable sorting algorithm? a.  Solve the recurrence relation for the number of key comparisons made by mergesort in the worst case. You may assume that n = 2k. b.  Set up a recurrence relation for the number of key comparisons made by mergesort on best-case inputs and solve it for n = 2k. c.  Set up a recurrence relation for the number of key moves made by the version of mergesort given in Section 5. Does taking the number of key moves into account change the algorithm's efficiency class? Let A[0..n 1] be an array of n real numbers. A pair (A[i], A[j ]) is said to be an inversion if these numbers are out of order, i.e., i < j but A[i] > A[j ]. Design an O(n log n) algorithm for counting the number of inversions. Implement the bottom-up version of mergesort in the language of your choice. Tromino puzzle  A tromino (more accurately, a right tromino) is an L-shaped tile formed by three 1 × 1 squares. The problem is to cover any 2n × 2n chessboard with a missing square with trominoes. Trominoes can be oriented in an arbitrary way, but they should cover all the squares of the board except the missing one exactly and with no overlaps. [Gol94] Design a divide-and-conquer algorithm for this problem. Apply quicksort to sort the list E, X, A, M, P , L, E in alphabetical order. Draw the tree of the recursive calls made. For the partitioning procedure outlined in this section: a.  Prove that if the scanning indices stop while pointing to the same element,
i.e., i = j, the value they are pointing to must be equal to p. b. Prove that when the scanning indices stop, j cannot point to an element more than one position to the left of the one pointed to by i. Give an example showing that quicksort is not a stable sorting algorithm. Give an example of an array of n elements for which the sentinel mentioned in the text is actually needed. What should be its value? Also explain why a single sentinel suffices for any input. For the version of quicksort given in this section: a.  Are arrays made up of all equal elements the worst-case input, the bestcase input, or neither? b. Are strictly decreasing arrays the worst-case input, the best-case input, or neither? a.  For quicksort with the median-of-three pivot selection, are strictly increasing arrays the worst-case input, the best-case input, or neither? b. Answer the same question for strictly decreasing arrays. a.  Estimate how many times faster quicksort will sort an array of one million random numbers than insertion sort. b. True or false: For every n > 1, there are n-element arrays that are sorted faster by insertion sort than by quicksort? Design an algorithm to rearrange elements of a given array of n real numbers so that all its negative elements precede all its positive elements.  Your algorithm should be both time efficient and space efficient. a.  The Dutch national flag problem is to rearrange an array of characters R, W, and B (red, white, and blue are the colors of the Dutch national flag) so that all the R's come first, the W's come next, and the B's come last. [Dij76] Design a linear in-place algorithm for this problem. b. Explain how a solution to the Dutch national flag problem can be used in quicksort. Implement quicksort in the language of your choice. Run your program on a sample of inputs to verify the theoretical assertions about the algorithm's efficiency. Nuts and bolts You are given a collection of n bolts of different widths and n corresponding nuts. You are allowed to try a nut and bolt together, from which you can determine whether the nut is larger than the bolt, smaller than the bolt, or matches the bolt exactly. However, there is no way to compare two nuts together or two bolts together.  The problem is to match each bolt to its nut. Design an algorithm for this problem with average-case efficiency in  (n log n). [Raw91] Design a divide-and-conquer algorithm for computing the number of levels in a binary tree. (In particular, the algorithm must return 0 and 1 for the empty and single-node trees, respectively.) What is the time efficiency class of your algorithm? The following algorithm seeks to compute the number of leaves in a binary tree. ALGORITHM   LeafCounter(T )
//Computes recursively the number of leaves in a binary tree
//Input: A binary tree T
//Output: The number of leaves in T if T =  return 0 else return LeafCounter(Tlef t)+ LeafCounter(Tright) Is this algorithm correct? If it is, prove it; if it is not, make an appropriate correction. Can you compute the height of a binary tree with the same asymptotic efficiency as the section's divide-and-conquer algorithm but without using a stack explicitly or implicitly? Of course, you may use a different algorithm altogether. Prove equality (5.2) by mathematical induction. Traverse the following binary tree a.  in preorder. b. in inorder. c.  in postorder. a
b c d   ef Write pseudocode for one of the classic traversal algorithms (preorder, inorder, and postorder) for binary trees. Assuming that your algorithm is recursive, find the number of recursive calls made. Which of the three classic traversal algorithms yields a sorted list if applied to a binary search tree? Prove this property. a.  Draw a binary tree with 10 nodes labeled 0, 1, . . . , 9 in such a way that the inorder and postorder traversals of the tree yield the following lists: 9, 3,
1, 0, 4, 2, 7, 6, 8, 5 (inorder) and 9, 1, 4, 0, 3, 6, 7, 5, 8, 2 (postorder). b. Give an example of two permutations of the same n labels 0, 1, . . . , n 1 that cannot be inorder and postorder traversal lists of the same binary tree. c.  Design an algorithm that constructs a binary tree for which two given lists of n labels 0, 1, . . . , n 1 are generated by the inorder and postorder traversals of the tree. Your algorithm should also identify inputs for which the problem has no solution. The internal path length I of an extended binary tree is defined as the sum of the lengths of the paths--taken over all internal nodes--from the root to each internal node. Similarly, the external path length E of an extended binary tree is defined as the sum of the lengths of the paths--taken over all external nodes--from the root to each external node. Prove that E = I + 2n where n is the number of internal nodes in the tree. Write a program for computing the internal path length of an extended binary tree. Use it to investigate empirically the average number of key comparisons for searching in a randomly generated binary search tree. Chocolate bar puzzle Given an n × m chocolate bar, you need to break it into nm 1 × 1 pieces. You can break a bar only in a straight line, and only one bar can be broken at a time. Design an algorithm that solves the problem with the minimum number of bar breaks. What is this minimum number? Justify your answer by using properties of a binary tree. What are the smallest and largest numbers of digits the product of two decimal n-digit integers can have? Compute 2101  1130 by applying the divide-and-conquer algorithm outlined in the text. a.  Prove the equality alogb c = clogb a, which was used in Section 5.4. b.  Why is nlog2 3 better than 3log2 n as a closed-form formula for M(n)? a.  Why did we not include multiplications by 10n in the multiplication count M(n) of the large-integer multiplication algorithm? b.  In addition to assuming that n is a power of 2, we made, for the sake of simplicity, another, more subtle, assumption in setting up the recurrences for M(n) and A(n), which is not always true (it does not change the final answers, however). What is this assumption? How many one-digit additions are made by the pen-and-pencil algorithm in multiplying two n-digit integers? You may disregard potential carries. Verify the formulas underlying Strassen's algorithm for multiplying 2 × 2 matrices. Apply Strassen's algorithm to compute
1  0 2  1  0  1  0  1
4  1 1  0  2  1  0  4
0  1 3  0  2  0  1  1
5  0 2  1  1  3  5  0 exiting the recursion when n = 2, i.e., computing the products of 2 × 2 matrices by the brute-force algorithm. Solve the recurrence for the number of additions required by Strassen's algorithm. Assume that n is a power of 2.
V. Pan [Pan78] has discovered a divide-and-conquer matrix multiplication algorithm that is based on multiplying two 70 × 70 matrices using 143,640 multiplications. Find the asymptotic efficiency of Pan's algorithm (you may ignore additions) and compare it with that of Strassen's algorithm. Practical implementations of Strassen's algorithm usually switch to the bruteforce method after matrix sizes become smaller than some crossover point. Run an experiment to determine such a crossover point on your computer system. a.  For the one-dimensional version of the closest-pair problem, i.e., for the problem of finding two closest numbers among a given set of n real numbers, design an algorithm that is directly based on the divide-and-conquer technique and determine its efficiency class. b.  Is it a good algorithm for this problem? Prove that the divide-and-conquer algorithm for the closest-pair problem examines, for every point p in the vertical strip (see Figures 5.7a and 5.7b), no more than seven other points that can be closer to p than dmin, the minimum distance between two points encountered by the algorithm up to that point. Consider the version of the divide-and-conquer two-dimensional closest-pair algorithm in which, instead of presorting input set P , we simply sort each of the two sets Pl and Pr in nondecreasing order of their y coordinates on each recursive call. Assuming that sorting is done by mergesort, set up a recurrence relation for the running time in the worst case and solve it for n = 2k. Implement the divide-and-conquer closest-pair algorithm, outlined in this section, in the language of your choice. Find on the Web a visualization of an algorithm for the closest-pair problem. What algorithm does this visualization represent? The Voronoi polygon for a point p of a set S of points in the plane is defined to be the perimeter of the set of all points in the plane closer to p than to any other point in S. The union of all the Voronoi polygons of the points in S is called the Voronoi diagram of S. a.  What is the Voronoi diagram for a set of three points? b.  Find a visualization of an algorithm for generating the Voronoi diagram on the Web and study a few examples of such diagrams. Based on your observations, can you tell how the solution to the previous question is generalized to the general case? Explain how one can find point pmax in the quickhull algorithm analytically. What is the best-case efficiency of quickhull? Give a specific example of inputs that make quickhull run in quadratic time. Implement quickhull in the language of your choice. Creating decagons There are 1000 points in the plane, no three of them on the same line. Devise an algorithm to construct 100 decagons with their vertices at these points. The decagons need not be convex, but each of them has to be simple, i.e., its boundary should not cross itself, and no two decagons may have a common point. Shortest path around There is a fenced area in the two-dimensional Euclidean  plane  in  the  shape  of  a  convex   polygon  with  vertices  at  points p1(x1, y1), p2(x2, y2), . . . , pn(xn, yn) (not necessarily in this order). There are two more points, a(xa, ya) and b(xb, yb) such that xa < min{x1, x2, . . . , xn} and xb > max{x1, x2, . . . , xn}. Design a reasonably efficient algorithm for computing the length of the shortest path between a and b. [ORo98] Consider the problem of finding the distance between the two closest numbers in an array of n numbers. (The distance between two numbers x and y is computed as |x y|.) a.  Design a presorting-based algorithm for solving this problem and determine its efficiency class. b. Compare the efficiency of this algorithm with that of the brute-force algorithm (see Problem 9 in Exercises 2). Let A = {a1, . . . , an} and B = {b1, . . . , bm} be two sets of numbers. Consider the problem of finding their intersection, i.e., the set C of all the numbers that are in both A and B. a.  Design a brute-force algorithm for solving this problem and determine its efficiency class. b. Design a presorting-based algorithm for solving this problem and determine its efficiency class. Consider the problem of finding the smallest and largest elements in an array of n numbers. a.  Design a presorting-based algorithm for solving this problem and determine its efficiency class. b.  Compare the efficiency of the three algorithms: (i) the brute-force algorithm, (ii) this presorting-based algorithm, and (iii) the divide-and-conquer algorithm (see Problem 2 in Exercises 5.1). Estimate how many searches will be needed to justify time spent on presorting an array of 103 elements if sorting is done by mergesort and searching is done by binary search. (You may assume that all searches are for elements known to be in the array.) What about an array of 106 elements? To sort or not to sort? Design a reasonably efficient algorithm for solving each of the following problems and determine its efficiency class. a.  You are given n telephone bills and m checks sent to pay the bills (n  m). Assuming that telephone numbers are written on the checks, find out who failed to pay. (For simplicity, you may also assume that only one check is written for a particular bill and that it covers the bill in full.) b.  You have a file of n student records indicating each student's   number, name, home address, and date of birth. Find out the number ofstudents from each of the 50 U.S. states. Given a set of n  3 points in the Cartesian plane, connect them in a simple polygon, i.e., a closed path through all the points so that its line segments
(the polygon's edges) do not intersect (except for neighboring edges at their common vertex). For example, P3   P3 P6   P1   P6  P1 P2   P2 P4   P4 P5P5 a.  Does the problem always have a solution? Does it always have a unique solution? b. Design a reasonably efficient algorithm for solving this problem and indicate its efficiency class. You have an array of n real numbers and another integer s. Find out whether the array contains two elements whose sum is s. (For example, for the array 5,
9, 1, 3 and s = 6, the answer is yes, but for the same array and s = 7, the answer is no.) Design an algorithm for this problem with a better than quadratic time efficiency. You have a list of n open intervals (a1, b1), (a2, b2), . . . , (an, bn) on the real line.
(An open interval (a, b) comprises all the points strictly between its endpoints a and b, i.e., (a, b) = {x| a < x < b}.) Find the maximum number of these intervals that have a common point. For example, for the intervals (1, 4),
(0, 3), (-5, 2), (3.6, 5), this maximum number is 3. Design an algorithm for this problem with a better than quadratic time efficiency. Number placement Given a list of n distinct integers and a sequence of n boxes with pre-set inequality signs inserted between them, design an algorithm that places the numbers into the boxes to satisfy those inequalities. For example, the numbers 4, 6, 3, 1, 8 can be placed in the five boxes as shown below:
1<8>3<4<6 Maxima search a.  A point (xi, yi) in the Cartesian plane is said to be dominated by point
(xj , yj ) if xi  xj and yi  yj with at least one of the two inequalities being strict. Given a set of n points, one of them is said to be a maximum of the set if it is not dominated by any other point in the set. For example, in the figure below, all the maximum points of the set of 10 points are circled. y
x Design an efficient algorithm for finding all the maximum points of a given set of n points in the Cartesian plane. What is the time efficiency class of your algorithm? b.  Give a few real-world applications of this algorithm. Anagram detection a.  Design an efficient algorithm for finding all sets of anagrams in a large file such as a dictionary of English words [Ben00]. For example, eat, ate, and tea belong to one such set. b. Write a program implementing the algorithm. Solve the following system by Gaussian elimination: x1 + x2 + x3 = 2
2x1 + x2 + x3 = 3 x1 x2 + 3x3 = 8. a.  Solve the system  ofthe previous question  by the  LU   decomposition method. b. From the standpoint of general algorithm design techniques, how would you classify the LU decomposition method? Solve the system of Problem 1 by computing the inverse of its coefficient matrix and then multiplying it by the vector on the right-hand side. Would it be correct to get the efficiency class of the forward elimination stage of Gaussian elimination as follows? n-1   n  n+1  n-1 C(n) = 1=   (n + 2 i)(n i) i=1 j =i+1 k=ii=1 n-1
= [(n + 2)n i(2n + 2) + i2] i=1 n-1 n-1n-1
= (n + 2)n  (2n + 2)i +i2. i=1 i=1i=1 Sinces1(n) =  ni=-11(n + 2)n(n3),  s2(n) = in=-11(2n + 2)i   (n3),   and s3(n) = n-1   i2(n3), s1(n) s2(n) + s3(n)(n3). i=1 Write pseudocode for the back-substitution stage of Gaussian elimination and show that its running time is in(n2). Assuming that division of two numbers takes three times longer than their multiplication, estimate how much faster BetterForwardElimination is than ForwardElimination. (Of course, you should also assume that a compiler is not going to eliminate the inefficiency in ForwardElimination.) a.  Give an example of a system of two linear equations in two unknowns that has a unique solution and solve it by Gaussian elimination. b.  Give an example of a system of two linear equations in two unknowns that has no solution and apply Gaussian elimination to it. c.  Give an example of a system of two linear equations in two unknowns that has infinitely many solutions and apply Gaussian elimination to it. The Gauss-Jordan elimination method differs from Gaussian elimination in that the elements above the main diagonal of the coefficient matrix are made zero at the same time and by the same use of a pivot row as the elements below the main diagonal. a.  Apply the   Gauss-Jordan  method  tothe  systemof  Problem   1  of  these exercises. b. What general design strategy is this algorithm based on? c.  In general, how many multiplications are made by this method in solving a system of n equations in n unknowns? How does this compare with the number of multiplications made by the Gaussian elimination method in both its elimination and back-substitution stages? A system Ax = b of n linear equations in n unknowns has a unique solution if and only if det A = 0. Is it a good idea to check this condition before applying Gaussian elimination to the system? a.  Apply Cramer's rule to solve the system of Problem 1 of these exercises. b.  Estimate how many times longer it will take to solve a system of n linear equations in n unknowns by Cramer's rule than by Gaussian elimination. Assume that all the determinants in Cramer's rule formulas are computed independently by Gaussian elimination. Lights out  This one-person game is played on an n × n board composed of 1 × 1 light panels. Each panel has a switch that can be turned on and off, thereby toggling the on/off state of this and four vertically and horizontally adjacent panels. (Of course, toggling a corner square affects a total of three panels, and toggling a noncorner panel on the board's border affects a total of four squares.) Given an initial subset of lighted squares, the goal is to turn all the lights off. a.  Show that an answer can be found by solving a system of linear equations with 0/1 coefficients and right-hand sides using the modulo 2 arithmetic. b. Use Gaussian elimination to solve the 2 × 2 all-ones instance of this problem, where all the panels of the 2 × 2 board are initially lit. c.  Use Gaussian elimination to solve the 3 × 3 all-ones instance of this problem, where all the panels of the 3 × 3 board are initially lit. Which of the following binary trees are AVL trees?
5   5  5
3   64 6 3   6
2   82 8   1   279
1   3 79
(a)  (b) (c) a.  For n = 1, 2, 3, 4, and 5, draw all the binary treeswith  n  nodes that   satisfy the balance requirement of AVL trees. b. Draw a binary tree of height 4 that can be an AVL tree and has the smallest number of nodes among all such trees. Draw diagrams of the single L-rotation and of the double RL-rotation in their general form. For each of the following lists, construct an AVL tree by inserting their elements successively, starting with the empty tree. a.  1, 2, 3, 4, 5, 6 b. 6, 5, 4, 3, 2, 1 c.  3, 6, 5, 1, 2, 4 a.  For an AVL tree containing real numbers, design an algorithm for computing the range (i.e., the difference between the largest and smallest numbers in the tree) and determine its worst-case efficiency. b.  True or false: The smallest and the largest keys in an AVL tree can always be found on either the last level or the next-to-last level? Write a program for constructing an AVL tree for a given list of n distinct integers. a.  Construct a 2-3 tree for the list C, O, M, P, U, T, I, N, G. Use the alphabetical order of the letters and insert them successively starting with the empty tree. b.  Assuming that the probabilities of searching for each of the keys (i.e., the letters) are the same, find the largest number and the average number of key comparisons for successful searches in this tree. Let TB and T2-3 be, respectively, a classical binary search tree and a 2-3 tree constructed for the same list of keys inserted in the corresponding trees in the same order. True or false: Searching for the same key in T2-3 always takes fewer or the same number of key comparisons as searching in TB? For a 2-3 tree containing real numbers, design an algorithm for computing the range (i.e., the difference between the largest and smallest numbers in the tree) and determine its worst-case efficiency. Write a program for constructing a 2-3 tree for a given list of n integers. a.  Construct a heap for the list 1, 8, 6, 5, 3, 7, 4 by the bottom-up algorithm. b.  Construct a heap for the list 1, 8, 6, 5, 3, 7, 4 by successive key insertions
(top-down algorithm). c.  Is it always true that the bottom-up and top-down algorithms yield the same heap for the same input? Outline an algorithm for checking whether an array H [.n] is a heap and determine its time efficiency. a.  Find the smallest and the largest number of keys that a heap of height h can contain. b.  Prove that the height of a heap with n nodes is equal to  log2 n . Prove the following equality used in Section 6.4: h-1
2(h i)2i = 2(n log2(n + 1)),  where n = 2h+1  i=0 a.  Design an efficient algorithm for finding and deleting an element of the smallest value in a heap and determine its time efficiency. b.  Design an efficient algorithm for finding and deleting an element of a given value v in a heap H and determine its time efficiency. Indicate the time efficiency classes of the three main operations of the priority queue implemented as a.  an unsorted array. b. a sorted array. c.  a binary search tree. d. an AVL tree. e.  a heap. Sort the following lists by heapsort by using the array representation of heaps. a.  1, 2, 3, 4, 5 (in increasing order) b. 5, 4, 3, 2, 1 (in increasing order) c.  S, O, R, T, I, N, G (in alphabetical order) Is heapsort a stable sorting algorithm? What variety of the transform-and-conquer technique does heapsort represent? Which sorting algorithm other than heapsort uses a priority queue? Implement three advanced sorting algorithms--mergesort, quicksort, and heapsort--in the language of your choice and investigate their performance on arrays of sizes n = 103, 104, 105, and 106. For each of these sizes consider a.  randomly generated files of integers in the range [.n]. b. increasing files of integers 1, 2, . . . , n. c.  decreasing files of integers n, n 1, . . . ,  Spaghetti sort  Imagine a handful of uncooked spaghetti, individual rods whose lengths represent numbers that need to be sorted. a.  Outline a spaghetti sort--a sorting algorithm that takes advantage of this unorthodox representation. b. What does this example of computer science folklore (see [Dew93]) have to do with the topic of this chapter in general and heapsort in particular? Consider the following brute-force algorithm for evaluating a polynomial. ALGORITHM BruteForcePolynomialEvaluation(P [0..n], x)
//Computes the value of polynomial P at a given point x
//by the highest to lowest term brute-force algorithm
//Input: An array P [0..n] of the coefficients of a polynomial of  degree   n,
//stored from the lowest to the highest and a number x
//Output: The value of the polynomial at the point x p  0.0 for i  n downto 0 do power  1 for j  1 to i do power  power  x p  p + P [i]  power return p Find the total number of multiplications and the total number of additions made by this algorithm. Write pseudocode for the brute-force polynomial evaluation that stems from substituting a given value of the variable into the polynomial's formula and evaluating it from the lowest term to the highest one. Determine the number of multiplications and the number of additions made by this algorithm. a.  Estimate how much faster Horner's rule is compared to the lowest-tohighest term brute-force algorithm of Problem 2 if (i) the time of one multiplication is significantly larger than the time of one addition; (ii) the time of one multiplication is about the same as the time of one addition. b. Is Horner's rule more time efficient at the expense of being less space efficient than the brute-force algorithm? a.  Apply Horner's rule to evaluate the polynomial p(x) = 3x4 x3 + 2x + 5at x = -2. b. Use the results of the above application of Horner's rule to find the quotient and remainder of the division of p(x) by x + 2. Apply Horner's rule to convert 110100101 from binary to decimal. Compare the number of multiplications and additions/subtractions needed by the long division of a polynomial p(x) = anxn + an-1xn-1 + . . . + a0 by x c, where c is some constant, with the number of these operations in the synthetic division. a.  Apply the left-to-right binary exponentiation algorithm to compute a17. b.  Is it possible to extend the left-to-right binary exponentiation algorithm to work for every nonnegative integer exponent? Apply the right-to-left binary exponentiation algorithm to compute a17. Design a nonrecursive algorithm for computing an that mimics the right-to-left binary exponentiation but does not explicitly use the binary representation of n. Is it a good idea to use a general-purpose polynomial-evaluation algorithm such as Horner's rule to evaluate the polynomial p(x) = xn + xn-1 + . . . + x + 1? According to the corollary of the Fundamental Theorem of Algebra, every polynomial
p(x) = anxn + an-1xn-1 + . . . + a0 can be represented in the form p(x) = an(x x1)(x x2) . . . (x xn) where x1, x2, . . . , xn are the roots of the polynomial (generally, complex and not necessarily distinct). Discuss which of the two representations is more convenient for each of the following operations: a.  polynomial evaluation at a given point b. addition of two polynomials c.  multiplication of two polynomials Polynomial interpolation  Given a set of n data points (xi, yi) where no two xi are the same, find a polynomial p(x) of degree at most n 1 such that p(xi) = yi for every i = 1, 2, . . . , n. a.  Prove the equality lcm(m, n) =  m.n gcd(m, n) that underlies the algorithm for computing lcm(m, n). b.  Euclid's algorithm is known to be in O(log n). If it is the algorithm that is used for computing gcd(m, n), what is the efficiency of the algorithm for computing lcm(m, n)? You are given a list of numbers for which you need to construct a min-heap.
(A min-heap is a complete binary tree in which every key is less than or equal to the keys in its children.) How would you use an algorithm for constructing a max-heap (a heap as defined in Section 6.4) to construct a min-heap? Prove that the number of different paths of length k > 0 from the ith vertex to the j th vertex in a graph (undirected or directed) equals the (i, j )th element of Ak where A is the adjacency matrix of the graph. a.  Design an algorithm with a time efficiency better than cubic for checking whether a graph with n vertices contains a cycle of length 3 [Man89]. b.  Consider the following algorithm for the same problem. Starting at an arbitrary vertex, traverse the graph by depth-first search and check whether its depth-first search forest has a vertex with a back edge leading to its grandparent. If it does, the graph contains a triangle; if it does not, the graph does not contain a triangle as its subgraph. Is this algorithm correct? Given n > 3 points P1 = (x1, y1), . . . , Pn = (xn, yn) in the coordinate plane, design an algorithm to check whether all the points lie within a triangle with its vertices at three of the points given. (You can either design an algorithm from scratch or reduce the problem to another one with a known algorithm.) Consider the problem of finding, for a given positive integer n, the pair of integers whose sum is n and whose product is as large as possible. Design an efficient algorithm for this problem and indicate its efficiency class. The assignment problem introduced in Section 3.4 can be stated as follows: There are n people who need to be assigned to execute n jobs, one person per job. (That is, each person is assigned to exactly one job and each job is assigned to exactly one person.) The cost that would accrue if the ith person is assigned to the j th job is a known quantity C[i, j ] for each pair i, j = 1, . . . , n. The problem is to assign the people to the jobs to minimize the total cost of the assignment. Express the assignment problem as a 0-1 linear programming problem. Solve the instance of the linear programming problem given in Section 6.6: maximize0.10x + 0.07y + 0.03z subject to  x + y + z = 100 x1  y
3 z  0.25(x + y) x  0,  y  0,  z  0. The graph-coloring problem is usually stated as the vertex-coloring problem: Assign the smallest number of colors to vertices of a given graph so that no two adjacent vertices are the same color. Consider the edge-coloring problem: Assign the smallest number of colors possible to edges of a given graph so that no two edges with the same endpoint are the same color. Explain how the edge-coloring problem can be reduced to a vertex-coloring problem. Consider the two-dimensional post office location problem: given n points
(x1, y1), . . . , (xn, yn) in the Cartesian plane, find a location (x, y) for a post
1  ni=1(|xi x| + |yi y|), the average Manhattan disoffice  that  minimizes n
tance from the post office to these points. Explain how this problem can be efficiently solved by the problem reduction technique, provided the post office does not have to be located at one of the input points. Jealous husbands   There are n  2 married couples who need to cross a river. They have a boat that can hold no more than two people at a time. To complicate matters, all the husbands are jealous and will not agree on any crossing procedure that would put a wife on the same bank of the river with another woman's husband without the wife's husband being there too, even if there are other people on the same bank. Can they cross the river under such constraints? a.  Solve the problem for n = 2. b. Solve the problem for n = 3, which is the classical version of this problem. c.  Does the problem have a solution for n  4? If it does, indicate how many river crossings it will take; if it does not, explain why. Double-n dominoesDominoes are small rectangular tiles with dots called spots or pips embossed at both halves of the tiles. A standard double-six domino set has 28 tiles: one for each unordered pair of integers from (0, 0) to (6, 6). In general, a double-n domino set would consist of domino tiles for each unordered pair of integers from (0, 0) to (n, n). Determine all values of n for which one constructs a ring made up of all the tiles in a double-n domino set. Is it possible to exchange numeric values of two variables, say, u and v, without using any extra storage? Will the comparison-counting algorithm work correctly for arrays with equal values? Assuming that the set of possible list values is {a, b, c, d}, sort the following list in alphabetical order by the distribution-counting algorithm: b, c, d,  c,   b,  a,  a,  b. Is the distribution-counting algorithm stable? Design a one-line algorithm for sorting any array of size n whose values are n distinct integers from 1 to n. The ancestry problem asks to determine whether a vertex u is an ancestor of vertex v in a given binary (or, more generally, rooted ordered) tree of n vertices. Design a O(n) input-enhancement algorithm that provides sufficient information to solve this problem for any pair of the tree's vertices in constant time. The following technique, known as virtual initialization, provides a timeefficient way to initialize just some elements of a given array A[0..n 1] so that for each of its elements, we can say in constant time whether it has been initialized and, if it has been, with which value. This is done by utilizing a variable counter for the number of initialized elements in A and two auxiliary arrays of the same size, say B[0..n 1] and C[0..n 1], defined as follows. B[0], . . . , B[counter 1] contain the indices of the elements of A that were initialized: B[0] contains the index of the element initialized first, B[1] contains the index of the element initialized second, etc. Furthermore, if A[i] was the kth element (0  k  counter 1) to be initialized, C[i] contains k. a.  Sketch the state of arrays A[0..7], B[0..7], and C[0..7] after the three assignments
A[3]  x; A[7]  z;A[1]  y. b. In general, how can we check with this scheme whether A[i] has been initialized and, if it has been, with which value? Least distance sorting  There are 10 Egyptian stone statues standing in a row in an art gallery hall. A new curator wants to move them so that the statues are ordered by their height. How should this be done to minimize the total distance that the statues are moved? You may assume for simplicity that all the statues have different heights. [Azi10] a.  Write a program for multiplying two sparse matrices, a p × q matrix A and a q × r matrix B. b. Write a program for multiplying two sparse polynomials p(x) and q(x) of degrees m and n, respectively. Is it a good idea to write a program that plays the classic game of tic-tac-toe with the human user by storing all possible positions on the game's 3 × 3 board along with the best move for each of them? Apply Horspool's algorithm to search for the pattern BAOBAB in the text BESS KNEW ABOUT BAOBABS Consider the problem of searching for genes in DNA sequences using Horspool's algorithm. A DNA sequence is represented by a text on the alphabet
{A, C, G, T}, and the gene or gene segment is the pattern. a.  Construct the shift table for the following gene segment of your chromosome 10: TCCTATTCTT b. Apply Horspool's algorithm to locate the above pattern in the following DNA sequence: TTATAGATCTCGTATTCTTTTATAGATCTCCTATTCTT
How many character comparisons will be made by Horspool's algorithm in searching for each of the following patterns in the binary text of 1000 zeros? a. 00001   b. 10000  c. 01010 For searching in a text of length n for a pattern of length m (n  m) with Horspool's algorithm, give an example of a. worst-case input. b. best-case input. Is it possible for Horspool's algorithm to make more character comparisons than the brute-force algorithm would make in searching for the same pattern in the same text? If Horspool's algorithm discovers a matching substring, how large a shift should it make to search for a next possible match? How many character comparisons will the Boyer-Moore algorithm make in searching for each of the following patterns in the binary text of 1000 zeros? a. 00001   b. 10000  c. 01010 a.  Would the Boyer-Moore algorithm work correctly with just the bad-symbol table to guide pattern shifts? b.  Would the Boyer-Moore algorithm work correctly with just the good-suffix table to guide pattern shifts? a.  If the last characters of a pattern and its counterpart in the text do match, does Horspool's algorithm have to check other characters right to left, or can it check them left to right too? b.  Answer the same question for the Boyer-Moore algorithm. Implement Horspool's algorithm, the Boyer-Moore algorithm, and the bruteforce algorithm of Section 3.2 in the language of your choice and run an experiment to compare their efficiencies for matching a.  random binary patterns in random binary texts. b. random natural-language patterns in natural-language texts. You are given two strings S and T , each n characters long. You have to establish whether one of them is a right cyclic shift of the other. For example, PLEA is a right cyclic shift of LEAP, and vice versa. (Formally, T is a right cyclic shift of S if T can be obtained by concatenating the (n i)-character suffix of S and the i-character prefix of S for some 1  i  n.) a.  Design a space-efficient algorithm for the task. Indicate the space and time efficiencies of your algorithm. b. Design a time-efficient algorithm for the task. Indicate the time and space efficiencies of your algorithm. For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11 a.  construct the open hash table. b. find the largest number of key comparisons in a successful search in this table. c.  find the average number of key comparisons in a successful search in this table. For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11 a.  construct the closed hash table. b. find the largest number of key comparisons in a successful search in this table. c.  find the average number of key comparisons in a successful search in this table. Why is it not a good idea for a hash function to depend on just one letter (say, the first one) of a natural-language word? Find the probability of all n keys being hashed to the same cell of a hash table of size m if the hash function distributes keys evenly among all the cells of the table. Birthday paradox  The birthday paradox asks how many people should be in a room so that the chances are better than even that two of them will have the same birthday (month and day). Find the quite unexpected answer to this problem. What implication for hashing does this result have? Answer the following questions for the separate-chaining version of hashing. a.  Where would you insert keys if you knew that all the keys in the dictionary are distinct? Which dictionary operations, if any, would benefit from this modification? b.  We could keep keys of the same linked list sorted. Which of the dictionary operations would benefit from this modification? How could we take advantage of this if all the keys stored in the entire table need to be sorted? Explain how to use hashing to check whether all elements of a list are distinct. What is the time efficiency of this application? Compare its efficiency with that of the brute-force algorithm (Section 2.3) and of the presorting-based algorithm (Section 6.1). Fill in the following table with the average-case (as the first entry) and worstcase (as the second entry) efficiency classes for the five implementations of the ADT dictionary: unordered  ordered   binary  balanced array   arraysearch tree  search tree  hashing search
insertion deletion
We have discussed hashing in the context of techniques based on space­time trade-offs. But it also takes advantage of another general strategy. Which one? Write a computer program that uses hashing for the following problem. Given a natural-language text, generate a list of distinct words with the number of occurrences of each word in the text. Insert appropriate counters in the program to compare the empirical efficiency of hashing with the corresponding theoretical results. p0   K1  p1...  pi ­1   Ki  pi  ...   pn ­2   Kn ­1  pn ­1 T0   T1 Ti ­1   Ti   Tn ­2   Tn ­1 FIGURE 7.7   Parental  node  of  a B-tree. Give examples of using an index in real-life applications that do not involve computers.
a.Prove the equality h-1
1+   2  m/2  i-1(   m/2  1) + 2 m/2 h-1 = 4 m/2 h-1 1, i=1 which was used in the derivation of upper bound (7.7) for the height of a B-tree.
b.Complete the derivation of inequality (7.7). Find the minimum order of the B-tree that guarantees that the number of disk accesses in searching in a file of 100 million records does not exceed 3. Assume that the root's page is stored in main memory. Draw the B-tree obtained after inserting 30 and then 31 in the B-tree in Figure 7.8. Assume that a leaf cannot contain more than three items. Outline an algorithm for finding the largest key in a B-tree.
a.A top-down 2-3-4 tree is a B-tree of order 4 with the following modification of the insert operation: Whenever a search for a leaf for a new key encounters a full node (i.e., a node with three keys), the node is split into two nodes by sending its middle key to the node's parent, or, if the full node happens to be the root, the new root for the middle key is created. Construct a top-down 2-3-4 tree by inserting the following list of keys in the initially empty tree:
10,  6,  15,  31,  20,  27,  50,   44,  18. b.  What is the principal advantage of this insertion procedure compared with the one used for 2-3 trees in Section 6.3? What is its disadvantage? a.  Write a program implementing a key insertion algorithm in a B-tree. b.  Write a program for visualization of a key insertion algorithm in a B-tree. What does dynamic programming have in common with divide-and-conquer? What is a principal difference between them? Solve the instance 5, 1, 2, 10, 6 of the coin-row problem. a.  Show that the time efficiency of solving the coin-row problem by straightforward application of recurrence (8.3) is exponential. b. Show that the time efficiency of solving the coin-row problem by exhaustive search is at least exponential. Apply the dynamic programming algorithm to find all the solutions to the change-makingproblem for  the denominations   1,  3,  5and  the  amount n = 9. How would you modify the dynamic programming algorithm for the coincollecting problem if some cells on the board are inaccessible for the robot? Apply your algorithm to the board below, where the inaccessible cells are shown by X's. How many optimal paths are there for this board?
1  2   3 4 5 6
1
2
3
4
5 Rod-cutting problem Design a dynamic programming algorithm for the following problem. Find the maximum total sale price that can be obtained by cutting a rod of n units long into integer-length pieces if the sale price of a piece i units long is pi for i = 1, 2, . . . , n. What are the time and space efficiencies of your algorithm? Shortest-path counting  A chess rook can move horizontally or vertically to any square in the same row or in the same column of a chessboard. Find the number of shortest paths by which a rook can move from one corner of a chessboard to the diagonally opposite corner. The length of a path is measured by the number of squares it passes through, including the first and the last squares. Solve the problem a.  by a dynamic programming algorithm. b. by using elementary combinatorics. Minimum-sum descentSome positive integers are arranged in an equilateral triangle with n numbers in its base like the one shown in the figure below for n = 4. The problem is to find the smallest sum in a descent from the triangle apex to its base through a sequence of adjacent numbers (shown in the figure by the circles). Design a dynamic programming algorithm for this problem and indicate its time efficiency.
2
54
1  4 7
8   696 Binomial coefficient Design an efficient algorithm for computing the binomial coefficient C(n, k) that uses no multiplications. What are the time and space efficiencies of your algorithm? Longest path in a dag a.  Design an efficient algorithm for finding the length of the longest path in a dag. (This problem is important both as a prototype of many other dynamic programming applications and in its own right because it determines the minimal time needed for completing a project comprising precedenceconstrained tasks.) b. Show how to reduce the coin-row problem discussed in this section to the problem of finding a longest path in a dag. Maximum square submatrix   Given an m × n boolean matrix B, find its largest square submatrix whose elements are all zeros. Design a dynamic programming algorithm and indicate its time efficiency. (The algorithm may be useful for, say, finding the largest free square area on a computer screen or for selecting a construction site.) World Series odds  Consider two teams, A and B, playing a series of games until one of the teams wins n games. Assume that the probability of A winning a game is the same for each game and equal to p, and the probability of A losing a game is q = 1 p. (Hence, there are no ties.) Let P (i, j ) be the probability of A winning the series if A needs i more games to win the series and B needs j more games to win the series. a.  Set up a recurrence relation for P (i, j )  that  can  be used  by   a dynamic programming algorithm. b. Find the probability of team A winning a seven-game series if the probability of it winning a game is 0.4. c.  Write pseudocode of the dynamic programming algorithm for solving this problem and determine its time and space efficiencies. a.  Apply the bottom-up dynamic programming algorithm to the following instance of the knapsack problem: item  weightvalue
1 3 $25
2 2 $20
3 1 $15capacity W = 6.
4 4 $40
5 5 $50 b.  How many different optimal subsets does the instance of part (a) have? c.  In general, how can we use the table generated by the dynamic programming algorithm to tell whether there is more than one optimal subset for the knapsack problem's instance? a.  Write pseudocode of the bottom-up dynamic programming algorithm for the knapsack problem. b.  Write pseudocode of the algorithm that finds the composition of an optimal subset from the table generated by the bottom-up dynamic programming algorithm for the knapsack problem. For the bottom-up dynamic programming algorithm for the knapsack problem, prove that a.  its time efficiency is  (nW ). b. its space efficiency is  (nW ). c.  the time needed to find the composition of an optimal subset from a filled dynamic programming table is O(n). a.  True or false: A sequence of values in a row of the dynamic programming table for the knapsack problem is always nondecreasing? b. True or false: A sequence of values in a column of the dynamic programming table for the knapsack problem is always nondecreasing? Design a dynamic programming algorithm for the version of the knapsack problem in which there are unlimited quantities of copies for each of the n item kinds given. Indicate the time efficiency of the algorithm. Apply the memory function method to the instance of the knapsack problem given in Problem  Indicate the entries of the dynamic programming table that are (i) never computed by the memory function method, (ii) retrieved without a recomputation. Prove that the efficiency class of the memory function algorithm for the knapsack problem is the same as that of the bottom-up algorithm (see Problem 3). Explain why the memory function approach is unattractive for the problem of computing a binomial coefficient by the formula C(n, k) = C(n 1, k 1) + C(n 1, k). Write a research report on one of the following well-known applications of dynamic programming: a.  finding the longest common subsequence in two sequences b. optimal string editing c.  minimal triangulation of a polygon Finish the computations started in the section's example of constructing an optimal binary search tree. a.  Why is the time efficiency of algorithm OptimalBST  cubic? b. Why is the space efficiency of algorithm OptimalBST quadratic? Write pseudocode for a linear-time algorithm that generates the optimal binary search tree from the root table. Devise a way to compute the sums  jps , which  are  used  in   the  dynamic s=i programming algorithm for constructing an optimal binary search tree, in constant time (per sum). True or false: The root of an optimal binary search tree always contains the key with the highest search probability? How would you construct an optimal binary search tree for a set of n keys if all the keys are equally likely to be searched for? What will be the average number of comparisons in a successful search in such a tree if n = 2k? a.  Show that the number of distinct binary search trees b(n) that can be constructed for a set of n orderable keys satisfies the recurrence relation n-1 b(n) = b(k)b(n 1 k)  for n > 0,   b(0) =  k=0 b. It is known that the solution to this recurrence is given by the Catalan numbers. Verify this assertion for n = 1, 2, . . . , 5. c.  Find the order of growth of b(n). What implication does the answer to this question have for the exhaustive-search algorithm for constructing an optimal binary search tree? Design a  (n2) algorithm for finding an optimal binary search tree. Generalize the optimal binary search algorithm by taking into account unsuccessful searches. Write pseudocode of a memory function for the optimal binary search tree problem. You may limit your function to finding the smallest number of key comparisons in a successful search. Matrix chain multiplication   Consider the problem of minimizing the total number of multiplications made in computing the product of n matrices A1 . A2 . . . . . An whose dimensions are d0 × d1, d1 × d2, . . . , dn-1 × dn, respectively. Assume that all intermediate products of two matrices are computed by the bruteforce (definition-based) algorithm. a.  Give an example of three matrices for which the number of multiplications in (A1 . A2) . A3 and A1 . (A2 . A3) differ at least by a factor of 1000. b.  How many different ways are there to compute the product of n matrices? c.  Design a dynamic programming algorithm for finding an optimal order of multiplying n matrices. Apply Warshall's algorithm to find the transitive closure of the  digraph  defined by the following adjacency matrix:
0  10  0
0  01  0
0  00  1
0  00  0 a.  Prove that the time efficiency of Warshall's algorithm is cubic. b.  Explain why the time efficiency class of Warshall's algorithm is inferior to that of the traversal-based algorithm for sparse graphs represented by their adjacency lists. Explain how to implement Warshall's algorithm without using extra memory for storing elements of the algorithm's intermediate matrices. Explain how to restructure the innermost loop of the algorithm Warshall to make it run faster at least on some inputs. Rewrite pseudocode of Warshall's algorithm assuming that the matrix rows are represented by bit strings on which the bitwise or operation can be performed. a.  Explain how Warshall's algorithm can be used to determine whether a given digraph is a dag (directed acyclic graph). Is it a good algorithm for this problem? b. Is it a good idea to apply Warshall's algorithm to find the transitive closure of an undirected graph? Solve the all-pairs shortest-path problem for the digraph with the following weight matrix:
0  2  1  8
6  0  3   2
0   4
2   0  3
30 Prove that the next matrix in sequence (8.12) of Floyd's algorithm can be written over its predecessor. Give an example of a graph or a digraph with negative weights for which Floyd's algorithm does not yield the correct result. Enhance Floyd's algorithm so that shortest paths themselves, not just their lengths, can be found. Jack Straws In the game of Jack Straws, a number of plastic or wooden straws are dumped on the table and players try to remove them one by one without disturbing the other straws. Here, we are only concerned with whether various pairs of straws are connected by a path of touching straws. Given a list of the endpoints for n > 1 straws (as if they were dumped on a large piece of graph paper), determine all the pairs of straws that are connected. Note that touching is connecting, but also that two straws can be connected indirectly via other connected straws. [1994 East-Central Regionals of the ACM International Collegiate Programming Contest] Write pseudocode of the greedy algorithm for the change-making problem, with an amount n and coin denominations d1 > d2 > . . . > dm as its input. What is the time efficiency class of your algorithm? Design a greedy algorithm for the assignment problem (see Section 3.4). Does your greedy algorithm always yield an optimal solution? Job scheduling Consider the problem of scheduling n jobs of known durations t1, t2, . . . , tn for execution by a single processor. The jobs can be executed in any order, one job at a time. You want to find a schedule that minimizes the total time spent by all the jobs in the system. (The time spent by one job in the system is the sum of the time spent by this job in waiting plus the time spent on its execution.) Design a greedy algorithm for this problem. Does the greedy algorithm always yield an optimal solution? Compatible intervalsGiven n open intervals (a1, b1), (a2, b2), . . . , (an, bn) on the real line, each representing start and end times of some activity requiring the same resource, the task is to find the largest number of these intervals so that no two of them overlap. Investigate the three greedy algorithms based on a.  earliest start first. b. shortest duration first. c.  earliest finish first. For each of the three algorithms, either prove that the algorithm always yields an optimal solution or give a counterexample showing this not to be the case. Bridge crossing revisitedConsider the generalization of the bridge crossing puzzle (Problem 2 in Exercises 2) in which we have n > 1 people whose bridge crossing times are t1, t2, . . . , tn. All the other conditions of the problem remain the same: at most two people at a time can cross the bridge (and they move with the speed of the slower of the two) and they must carry with them the only flashlight the group has. Design a greedy algorithm for this problem and find how long it will take to cross the bridge by using this algorithm. Does your algorithm yield a minimum crossing time for every instance of the problem? If it does--prove it; if it does not--find an instance with the smallest number of people for which this happens. Averaging down   There are n > 1 identical vessels, one of them with W pints of water and the others empty. You are allowed to perform the following operation: take two of the vessels and split the total amount of water in them equally between them. The object is to achieve a minimum amount of water in the vessel containing all the water in the initial set up by a sequence of such operations. What is the best way to do this? Rumor spreadingThere are n people, each in possession of a different rumor. They want to share all the rumors with each other by sending electronic messages. Assume that a sender includes all the rumors he or she knows at the time the message is sent and that a message may only have one addressee. Design a greedy algorithm that always yields the minimum number of messages they need to send to guarantee that every one of them gets all the rumors. Bachet's problem of weights  Find an optimal set of n weights {w1, w2, . . . , wn} so that it would be possible to weigh on a balance scale any integer load in the largest possible range from 1 to W , provided a.  weights can be put only on the free cup of the scale. b. weights can be put on both cups of the scale. a.  Apply Prim's algorithm to the following graph.Include  in  the  priority queue all the vertices not already in the tree. a 5  b
2  e3
7 4   56 c 4  d b.  Apply Prim's algorithm to the following graph. Include in the priority queue only the fringe vertices (the vertices not in the current tree which are adjacent to at least one tree vertex). a 3   b
5   4 36 c 2 d 1   e2 f
4  5 4  5 g 3 h 6   i3 j
7 59
6 k 8   l The notion of a minimum spanning tree is applicable to a connected weighted graph. Do we have to check a graph's connectivity before applying Prim's algorithm, or can the algorithm do it by itself? Does Prim's algorithm always work correctly on graphs with negative edge weights? Let T be a minimum spanning tree of graph G obtained by Prim's algorithm. Let Gnew be a graph obtained by adding to G a new vertex and some edges, with weights, connecting the new vertex to some vertices in G. Can we construct a minimum spanning tree of Gnew by adding one of the new edges to T ? If you answer yes, explain how; if you answer no, explain why not. How can one use Prim's algorithm to find a spanning tree of a connected graph with no weights on its edges? Is it a good algorithm for this problem? Prove that any weighted connected graph with distinct weights has exactly one minimum spanning tree. Outline an efficient algorithm for changing an element's value in a min-heap. What is the time efficiency of your algorithm? Apply Kruskal's algorithm to find a minimum spanning tree of the following graphs. a. 1 bc
5  6
3   4 a 6   d2  e b.   a 3   b
54 3 6 c 2  d 1   e 2 f
4  5 4   5 g 3  h 6   i 3 j
7 5 9
6 k 8   l Indicate whether the following statements are true or false: a.  If e is a minimum-weight edge in a connected weighted graph, it must be among edges of at least one minimum spanning tree of the graph. b. If e is a minimum-weight edge in a connected weighted graph, it must be among edges of each minimum spanning tree of the graph. c.  If edge weights of a connected weighted graph are all distinct, the graph must have exactly one minimum spanning tree. d. If edge weights of a connected weighted graph are not all distinct, the graph must have more than one minimum spanning tree. What changes, if any, need to be made in algorithm Kruskal to make it find a minimum spanning forest for an arbitrary graph? (A minimum spanning forest is a forest whose trees are minimum spanning trees of the graph's connected components.) Does Kruskal's algorithm work correctly on graphs that have negative edge weights? Design an algorithm for finding a maximum spanning tree--a spanning tree with the largest possible edge weight--of a weighted connected graph. Rewrite pseudocode of Kruskal's algorithm in terms of the operations of the disjoint subsets' ADT. Prove the correctness of Kruskal's algorithm. Prove that the time efficiency of find(x) is in O(log n) for the union-by-size version of quick union. Find at least two Web sites with animations of Kruskal's and Prim's algorithms. Discuss their merits and demerits. Design and conduct an experiment to empirically compare the efficiencies of Prim's and Kruskal's algorithms on random graphs of different sizes and densities. Steiner tree  Four villages are located at the vertices of a unit square in the Euclidean plane. You are asked to connect them by the shortest network of roads so that there is a path between every pair of the villages along those roads. Find such a network. Write a program generating a random maze based on a.  Prim's algorithm. b. Kruskal's algorithm. Explain what adjustments if any need to be made in Dijkstra's algorithm and/or in an underlying graph to solve the following problems. a.  Solve  the  single-sourceshortest-paths  problem for  directed  weighted graphs. b. Find a shortest path between two given vertices of a weighted graph or digraph. (This variation is called the single-pair shortest-path problem.) c.  Find the shortest paths to a given vertex from each other vertex of a weighted graph or digraph. (This variation is called the single-destination shortest-paths problem.) d. Solve the single-source shortest-paths problem in a graph with nonnegative numbers assigned to its vertices (and the length of a path defined as the sum of the vertex numbers on the path). Solve the following instances of the single-source shortest-paths problem with vertex a as the source: a.   4 b   c
3   6
2 5 a7d  4e b. a 3   b
5   4 3 6 c2 d 1   e 2f
45 4  5 g3 h 6   i 3j
7 5 9
6 k 8   l Give a counterexample that shows that Dijkstra's algorithm may not work for a weighted connected graph with negative weights. Let T be a tree constructed by Dijkstra's algorithm in the process of solving the single-source shortest-paths problem for a weighted connected graph G. a.  True or false: T  is a spanning tree of G? b. True or false: T is a minimum spanning tree of G? Write pseudocode for a simpler version of Dijkstra's algorithm that finds only the distances (i.e., the lengths of shortest paths but not shortest paths themselves) from a given vertex to all other vertices of a graph represented by its weight matrix. Prove the correctness of Dijkstra's algorithm for graphs with positive weights. Design a linear-time algorithm for solving the single-source shortest-paths problem for dags (directed acyclic graphs) represented by their adjacency lists. Explain how the minimum-sum descent problem (Problem 8 in Exercises 8.1) can be solved by Dijkstra's algorithm. Shortest-path modeling  Assume you have a model of a weighted connected graph made of balls (representing the vertices) connected by strings of appropriate lengths (representing the edges). a.  Describe how you can solve the single-pair shortest-path problem with this model. b. Describe how you can solve the single-source shortest-paths problem with this model. Revisit the exercise from Section 3 about determining the best route for a subway passenger to take from one designated station to another in a welldeveloped subway system like those in Washington, DC, or London, UK. Write a program for this task. a.  Construct a Huffman code for the following data: symbol   A  BCD _ frequency0.40.1  0.2  0.15  0.15 b.  Encode ABACABAD using the code of question (a). c.  Decode 100010111001010 using the code of question (a). For data transmission purposes, it is often desirable to have a code with a minimum variance of the codeword lengths (among codes of the same average length). Compute the average and variance of the codeword length in two Huffman codes that result from a different tie breaking during a Huffman code construction for the following data: symbolA B  CD   E probability   0.1   0.10.2  0.2 0.4 Indicate whether each of the following properties is true for every Huffman code. a.  The codewords of the two least frequent symbols have the same length. b. The codeword's length of a more frequent symbol is always smaller than or equal to the codeword's length of a less frequent one. What is the maximal length of a codeword possible in a Huffman encoding of an alphabet of n symbols? a.  Write pseudocode of the Huffman-tree construction algorithm. b.  What is the time efficiency class of the algorithm for constructing a Huffman tree as a function of the alphabet size? Show that a Huffman tree can be constructed in linear time if the alphabet symbols are given in a sorted order of their frequencies. Given a Huffman coding tree, which algorithm would you use to get the codewords for all the symbols? What is its time-efficiency class as a function of the alphabet size? Explain how one can generate a Huffman code without an explicit generation of a Huffman coding tree. a.  Write a program that constructs a Huffman code for a given English text and encode it. b.  Write a program for decoding of an English text which has been encoded with a Huffman code. c.  Experiment with your encoding program to find a range of typical compression ratios for Huffman's encoding of English texts of, say, 1000 words. d.  Experiment with your encoding program to find out how sensitive the compression ratios are to using standard estimates of frequencies instead of actual frequencies of symbol occurrences in English texts. Card guessing   Design a strategy that minimizes the expected number of questions asked in the following game [Gar94]. You have a deck of cards that consists of one ace of spades, two deuces of spades, three threes, and on up to nine nines, making 45 cards in all. Someone draws a card from the shuffled deck, which you have to identify by asking questions answerable with yes or no. Consider the following version of the post office location problem (Problem
3 in Exercises 3.3): Given n integers x1, x2, . . . , xn representing coordinates of n villages located along a straight road, find a location for a post office that minimizes the average distance between the villages. The post office may be, but is not required to be, located at one of the villages. Devise an iterativeimprovement algorithm for this problem. Is this an efficient way to solve this problem? Solve the following linear programming problems geometrically. a.  maximize3x + y subject to -x + y  1
2x + y  4 x  0, y 0 b.  maximizex + 2y subject to 4x  y y 3+x x  0, y  0 Consider the linear programming problem minimizec1x  + c2y subject to  x+  y4 x+ 3y  6 x 0, y  0 where c1 and c2 are some real numbers not both equal to zero. a.  Give an example of the coefficient values c1 and c2 for which the problem has a unique optimal solution. b.  Give an example of the coefficient values c1 and c2 for which the problem has infinitely many optimal solutions. c.  Give an example of the coefficient values c1 and c2 for which the problem does not have an optimal solution. Would the solution to problem (10.2) be different if its inequality constraints were strict, i.e., x + y < 4 and x + 3y < 6, respectively? Trace the simplex method on a.  the problem of Exercise 2a. b. the problem of Exercise 2b. Trace the simplex method on the problem of Example 1 in Section 6.6 a.  by hand. b. by using one of the implementations available on the Internet. Determine how many iterations the simplex method needs to solve the problem
n maximize   xj j =1 subject to  0  xj  bj , where bj > 0 for j = 1, 2, . . . , n. Can we apply the simplex method to solve the knapsack problem (see Example 2 in Section 6.6)? If you answer yes, indicate whether it is a good algorithm for the problem in question; if you answer no, explain why not. Prove that no linear programming problem can have exactly k  1 optimal solutions unless k =  If a linear programming problem n
maximizecj xj j =1 n
subject to  aij xj  bifor i = 1, 2, . . . , m j =1 x1, x2, . . . , xn  0 is considered as primal, then its dual is defined as the linear programming problem
m minimizebi yi i=1 m
subject to  aij yi  cjfor  j  =  1,  2,  .  .  .  ,  n i=1 y1, y2, . . . , ym   0. a.  Express the primal and dual problems in matrix notations. b.  Find the dual of the linear programming problem maximize  x1 + 4x2  x3 subject tox1 +  x2 +  x3  6 x1  x2 2x3  2 x1, x2, x3  0. c.  Solve the primal and dual problems and compare the optimal  values of their objective functions. Since maximum-flow algorithms require processing edges in both directions, it is convenient to modify the adjacency matrix representation of a network as follows. If there is a directed edge from vertex i to vertex j of capacity uij , then the element in the ith row and the j th column is set to uij , and the element in the j th row and the ith column is set to -uij ; if there is no edge between vertices i and j , both these elements are set to zero. Outline a simple algorithm for identifying a source and a sink in a network presented by such a matrix and indicate its time efficiency. Apply the shortest-augmenting path algorithm to find a maximum flow and a minimum cut in the following networks. a.   5   2
12   5
6   4   4
3  7 4 8 6 b. 3
2   4
21
14 4  6
73   5   5
2 a.  Does the maximum-flow problem always have a unique solution? Would your answer be different for networks with different capacities on all their edges? b.  Answer the same questions for the minimum-cut problem of finding a cut of the smallest capacity in a given network. a.  Explain  how  the  maximum-flow problem for   a  network  with  several sources and sinks can be transformed into the same problem for a network with a single source and a single sink. b.  Some networks have capacity constraints on the flow amounts that can flow through their intermediate vertices. Explain how the maximum-flow problem for such a network can be transformed to the maximum-flow problem for a network with edge capacity constraints only. Consider a network that is a rooted tree, with the root as its source, the leaves as its sinks, and all the edges directed along the paths from the root to the leaves. Design an efficient algorithm for finding a maximum flow in such a network. What is the time efficiency of your algorithm? a.  Prove equality (10.9). b.   Prove that for any flow in a network and any cut in it, the value ofthe flow is equal to the flow across the cut (see equality (10.12)). Explainthe relationship between this property and equality (10.9). a.   Express the maximum-flow problem for the network in Figure 10.4 as a linear programming problem. b. Solve this linear programming problem by the simplex method. As an alternative to the shortest-augmenting-path algorithm, Edmonds and Karp [Edm72] suggested the maximum-capacity-augmenting-path algorithm, in which a flow is augmented along the path that increases the flow by the largest amount. Implement both these algorithms in the language of your choice and perform an empirical investigation of their relative efficiency. Write  a  report  on  amore  advancedmaximum-flow algorithm  suchas
(i)  Dinitz's  algorithm,  (ii)  Karzanov's  algorithm,(iii)  Malhotra-KamarMaheshwari algorithm, or (iv) Goldberg-Tarjan algorithm. Dining problemSeveral families go out to dinner together. To increase their social interaction, they would like to sit at tables so that no two members of the same family are at the same table. Show how to find a seating arrangement that meets this objective (or prove that no such arrangement exists) by using a maximum-flow problem. Assume that the dinner contingent has p families and that the ith family has ai members. Also assume that q tables are available and the j th table has a seating capacity of bj . [Ahu93] For each matching shown below in bold, find an augmentation or explain why no augmentation exists.
a.b.
1  2  3 4 1  2   3 4
5  6 75  6   7 8 Apply the maximum-matching algorithm to the following bipartite graph:
1 2  3
4 5  6 a.  What is the largest and what is the smallest possible cardinality of a matching in a bipartite graph G =   V, U, E   with n vertices in each vertex set V and U and at least n edges? b.  What is the largest and what is the smallest number of distinct solutions the maximum-cardinality-matching problem can have for a bipartite graph G= V, U, E  with n vertices in each vertex set V and U and at least n edges? a.  Hall's Marriage Theorem asserts that a bipartite graph G = V, U, E  has a matching that matches all vertices of the set V if and only if for each subset S  V , |R(S)|  |S| where R(S) is the set of all vertices adjacent to a vertex in S. Check this property for the following graph with (i) V = {1, 2, 3, 4} and (ii) V = {5, 6, 7}.
1   2   3   4
5   6 7 b.  You have to devise an algorithm that returns yes if there is a matching in a bipartite graph G =   V, U, E that matches all vertices in V and returns no otherwise. Would you base your algorithm on checking the condition of Hall's Marriage Theorem? Suppose there are five committees A, B, C, D, and E composed of six persons a, b, c, d, e, and f as follows: committee A's members are b and e; committee B's members are b, d, and e; committee C's members are a, c, d, e, and f ; committee D's members are b, d, and e; committee E's members are b and e. Is there a system of distinct representatives, i.e., is it possible to select a representative from each committee so that all the selected persons are distinct? Show how the maximum-cardinality-matching problem for a bipartite graph can be reduced to the maximum-flow problem discussed in Section 10.2. Consider the following greedy algorithm for finding a maximum matching in  a bipartite graph  G=   V , U, E . Sort  all the vertices  in  nondecreasing order of their degrees. Scan this sorted list to add to the current matching
(initially empty) the edge from the list's free vertex to an adjacent free vertex of the lowest degree. If the list's vertex is matched or if there are no adjacent free vertices for it, the vertex is simply skipped. Does this algorithm always produce a maximum matching in a bipartite graph? Design a linear-time algorithm for finding a maximum matching in a tree. Implement the maximum-matching algorithm of this section in the language of your choice. Experiment with its performance on bipartite graphs with n vertices in each of the vertex sets and randomly generated edges (in both dense and sparse modes) to compare the observed running time with the algorithm's theoretical efficiency. Domino puzzle A domino is a 2 × 1 tile that can be oriented either horizontally or vertically. A tiling of a given board composed of 1 × 1 squares is covering it with dominoes exactly and without overlap. Is it possible to tile with dominoes an 8 × 8 board without two unit squares at its diagonally opposite corners? Consider an instance of the stable marriage problem given by the following ranking matrix: AB C
1, 3 2, 2  3, 1
3, 1 1, 3  2, 2
2, 2 3, 1  1, 3 For each of its marriage matchings, indicate whether it is stable or not. For the unstable matchings, specify a blocking pair. For the stable matchings, indicate whether they are man-optimal, woman-optimal, or neither. (Assume that the Greek and Roman letters denote the men and women, respectively.) Design a simple algorithm for checking whether a given marriage matching is stable and determine its time efficiency class. Find a stable marriage matching for the instance given in Problem 1 by applying the stable marriage algorithm a.  in its men-proposing version. b. in its women-proposing version. Find a stable marriage matching for the instance defined by the following ranking matrix: A B  C D
1, 3  2, 3   3, 2  4, 3
1, 4  4, 1   3, 4  2, 2
2, 2  1, 4   3, 3  4, 1
4, 1  2, 2   3, 1  1, 4 Determine the time-efficiency class of the stable marriage algorithm a.  in the worst case. b. in the best case. Prove that a man-optimal stable marriage set is always unique. Is it also true for a woman-optimal stable marriage matching? Prove that in the man-optimal stable matching, each woman has the worst partner that she can have in any stable marriage matching. Implement the stable-marriage algorithm given in Section 10.4 so that its running time is in O(n2). Run an experiment to ascertain its average-case efficiency. Write a report on the college admission problem (residents-hospitals assignment) that generalizes the stable marriage problem in that a college can accept proposals from more than one applicant. Consider the problem of the roommates, which is related to but more difficult than the stable marriage problem: An even number of boys wish to divide up into pairs of roommates. A set of pairings is called stable if under it there are no two boys who are not roommates and who prefer each other to their actual roommates. [Gal62] Give an instance of this problem that does not have a stable pairing. Prove that any algorithm solving the alternating-disk puzzle (Problem 14 in Exercises 3.1) must make at least n(n + 1)/2 moves to solve it. Is this lower bound tight? Prove that the classic recursive algorithm for the Tower of Hanoi puzzle
(Section 2.4) makes the minimum number of disk moves needed to solve the problem. Find a trivial lower-bound class for each of the following problems and indicate, if you can, whether this bound is tight. a.  finding the largest element in an array b. checking completeness of a graph represented by its adjacency matrix c.  generating all the subsets of an n-element set d. determining whether n given real numbers are all distinct Consider the problem of identifying a lighter fake coin among n identicallooking   coins  withthe   help  ofa  balance  scale. Can   we  use  the  same information-theoretic argument as the one in the text for the number of questions in the guessing game to conclude that any algorithm for identifying the fake will need at least log2 n   weighings in the worst case? Prove that any comparison-based algorithm for finding the largest element of an n-element set of real numbers must make n 1 comparisons in the worst case. Find a tight lower bound for sorting an array by exchanging its adjacent elements. Give an adversary-argument proof that the time efficiency of any algorithm that checks connectivity of a graph with n vertices is in(n2), provided the only operation allowed for an algorithm is to inquire about the presence of an edge between two vertices of the graph. Is this lower bound tight? What is the minimum number of comparisons needed for a comparison-based sorting algorithm to merge any two sorted lists of sizes n and n + 1 elements, respectively? Prove the validity of your answer. Find the product of matrices A and B through a transformation to a product of two symmetric matrices if A= 1  -1  and  B=  0   1  .
2  3-1  2 a.  Can one use this section's formulas that indicate the complexity equivalence of multiplication and squaring of integers to show the complexity equivalence of multiplication and squaring of square matrices? b. Show that multiplication of two matrices of order n can be reduced to squaring a matrix of order 2n. Find a tight lower-bound class for the problem of finding two closest numbers among n real numbers x1, x2, . . . , xn. Find a tight lower-bound class for the number placement problem (Problem 9 in Exercises 6.1). Prove by mathematical induction that a.  h log2 l  for any binary tree with height h and the number of leaves l. b.  h log3 l  for any ternary tree with height h and the number of leaves l. Consider the problem of finding the median of a three-element set {a, b, c} of orderable items. a.  What is the information-theoretic lower bound for comparison-based algorithms solving this problem? b. Draw a decision tree for an algorithm solving this problem. c.  If the worst-case number of comparisons in your algorithm is greater than the information-theoretic lower bound, do you think an algorithm matching the lower bound exists? (Either find such an algorithm or prove its impossibility.) Draw a decision tree and find the number of key comparisons in the worst and average cases for a.  the three-element basic bubble sort. b. the three-element enhanced bubble sort (which stops if no swaps have been made on its last pass). Design a comparison-based algorithm for sorting a four-element array with the smallest number of element comparisons possible. Design a comparison-based algorithm for sorting a five-element array with seven comparisons in the worst case. Draw a binary decision tree for searching a four-element sorted list by sequential search. Compare the two lower bounds for searching a sorted array-log3(2n + 1) and  log2(n + 1) --to show that a.   log3(2n + 1)log2(n + 1)  for every positive integer n. b.   log3(2n + 1)  < log2(n + 1)  for every positive integer n  n0. What is the information-theoretic lower bound for finding the maximum of n numbers by comparison-based algorithms? Is this bound tight? A tournament tree is a complete binary tree reflecting results of a knockout tournament: its leaves represent n players entering the tournament, and each internal node represents a winner of a match played by the players represented by the node's children. Hence, the winner of the tournament is represented by the root of the tree. a.  What is the total number of games played in such a tournament? b. How many rounds are there in such a tournament? c.  Design an efficient algorithm to determine the second-best player using the information produced by the tournament. How many extra games does your algorithm require? Advanced fake-coin problem   There are n  3 coins identical in appearance; either all are genuine or exactly one of them is fake. It is unknown whether the fake coin is lighter or heavier than the genuine one. You have a balance scale with which you can compare any two sets of coins. That is, by tipping to the left, to the right, or staying even, the balance scale will tell whether the sets weigh the same or which of the sets is heavier than the other, but not by how much. The problem is to find whether all the coins are genuine and, if not, to find the fake coin and establish whether it is lighter or heavier than the genuine ones. a.  Prove that any algorithm for this problem must make at least  log3(2n + 1) weighings in the worst case. b. Draw a decision tree for an algorithm that solves the problem for n = 3 coins in two weighings. c.  Prove that there exists no algorithm that solves the problem for n = 4 coins in two weighings. d. Draw a decision tree for an algorithm that solves the problem for n = 4 coins in two weighings by using an extra coin known to be genuine. e.  Draw a decision tree for an algorithm that solves the classic version of the problem--that for n = 12 coins in three weighings (with no extra coins being used). Jigsaw puzzle A jigsaw puzzle contains n pieces. A section of the puzzle is a set of one or more pieces that have been connected to each other. A move consists of connecting two sections. What algorithm will minimize the number of moves required to complete the puzzle? A game of chess can be posed as the following decision problem: given a legal positioning of chess pieces and information about which side is to move, determine whether that side can win. Is this decision problem decidable? A certain problem can be solved by an algorithm whose running time is in O(nlog2 n). Which of the following assertions is true? a.  The problem is tractable. b. The problem is intractable. c.  Impossible to tell. Give examples of the following graphs or explain why such examples cannot exist. a.  graph with a Hamiltonian circuit but without an Eulerian circuit b. graph with an Eulerian circuit but without a Hamiltonian circuit c.  graph with both a Hamiltonian circuit and an Eulerian circuit d. graph with a cycle that includes all the vertices but with neither a Hamiltonian circuit nor an Eulerian circuit In 2000, The Clay Mathematics Institute (CMI) of Cambridge, Massachusetts, designated a $1 million prize for the solution to this problem. For eachof the following graphs,   find  its  chromatic  number. a.  a e  b.a c.  af e   bd b f  bg d c   e c g  ch d h Design a polynomial-time algorithm for the graph 2-coloring problem: determine whether vertices of a given graph can be colored in no more than two colors so that no two adjacent vertices are colored the same color. Consider the following brute-force algorithm for solving the composite number problem: Check successive integers from 2 ton/2  as possible divisors of
n. If one of them divides n evenly, return yes (i.e., the number is composite); if none of them does, return no. Why does this algorithm not put the problem in class P ? State the decision version for each of the following problems and outline a polynomial-time algorithm that verifies whether or not a proposed solution solves the problem. (You may assume that a proposed solution represents a legitimate input to your verification algorithm.) a. knapsack problem b. bin packing problem Show that the partition problem is polynomially reducible to the decision version of the knapsack problem. Show that the following three problems are polynomially reducible to each other.
(i) Determine, for a given graph G = V, E   and a positive integer m  |V |, whether G contains a clique of size m or more. (A clique of size k in a graph is its complete subgraph of k vertices.)
(ii) Determine, for a given graph G =V, E   and a positive integer m  |V |, whether there is a vertex cover of size m or less for G. (A vertex cover of size k for a graph G =  V, E  is a subset VV such that |V | = k and, for each edge (u, v)  E, at least one of u and v belongs to V .)
(iii) Determine, for a given graph G =   V, E   and a positive integer m  |V |, whether G contains an independent set of size m or more. (An independent set of size k for a graph G =  V, E  is a subset V   V such that |V | = k and for all u, v  V , vertices u and v are not adjacent in G.) Determine whether the following problem is NP-complete. Given several sequences of uppercase and lowercase letters, is it possible to select a letter from each sequence without selecting both the upperand lowercase versions of any letter? For example, if the sequences are Abc, BC, aB, and ac, it is possible to choose A from the first sequence, B from the second and third, and c from the fourth. An example where there is no way to make the required selections is given by the four sequences AB, Ab, aB, and ab. [Kar86] Which of the following diagrams do not contradict the current state of our knowledge about the complexity classes P, NP, and NPC (NP-complete problems)? a.   b. P = NP P = NP = NPC NPC
c.NP d. NP P NPC   P   NPC
e.NP P NPC King Arthur expects 150 knights for an annual dinner at Camelot. Unfortunately, some of the knights quarrel with each other, and Arthur knows who quarrels with whom. Arthur wants to seat his guests around a table so that no two quarreling knights sit next to each other. a.  Which standard problem can be used to model King Arthur's task? b. As a research project, find a proof that Arthur's problem has a solution if each knight does not quarrel with at least 75 other knights. Some textbooks define the number of significant digits in the approximation of number  by number  as the largest nonnegative integer k for which
| | <   5  .  10-k.
|| According to this definition, how many significant digits are there in the approximation of  by a. 3.1415?   b. 3.1417? If  = 5 is known to approximate some number  with the absolute error not exceeding 10-2, find a.  the range of possible values of . b. the range of the relative errors of these approximations. Find the approximate value of  e = 648721 . . . obtained by the fifth-degree Taylor's polynomial about 0 and compute the truncation error of this approximation. Does the result agree with the theoretical prediction made in the section? Derive formula (17) of the composite trapezoidal rule. Use the composite trapezoidal rule with n = 4 to approximate the following definite integrals. Find the truncation error of each approximation and compare it with the one given by formula (19).
a.1  x2d  x  b.3  x-1d  x
01 If  1  esin  xdx  is  to  be  computed  by  the  composite  trapezoidal  rule,  how  large
0 should the number of subintervals be to guarantee a truncation error smaller than 10-4? Smaller than 10-6? Solve the two systems of linear equations and indicate whether they are illconditioned.
a.2x + 5y = 7b. 2x + 5y = 7
2x + 5.000001y = 7.0000012x + 4.999999y = 7.000002 Write a computer program to solve the equation ax2 + bx + c = 0. a.  Prove that for any nonnegative number D, the sequence of Newton's method for computing   D is strictly decreasing and converges to D for any value of the initial approximation x0 >D. b.  Prove that if 0.25  D < 1 and x0 = (1 + D)/2, no more than four iterations of Newton's method are needed to guarantee that
|xn  D| 4  .  10-15.
< Apply four iterations of Newton's method to compute  3 and estimate the absolute and relative errors of this approximation. a.  Continue the backtracking search for a solution to the four-queens problem, which was started in this section, to find the second solution to the problem. b.  Explain how the board's symmetry can be used to find the second solution to the four-queens problem. a.  Which is the last solution to the five-queens problem found by the backtracking algorithm? b.  Use the board's symmetry to find at least four other solutions to the problem. a.  Implement the backtracking algorithm for the n-queens problem in the language of your choice. Run your program for a sample of n values to get the numbers of nodes in the algorithm's state-space trees. Compare these numbers with the numbers of candidate solutions generated by the exhaustivesearch algorithm for this problem (see Problem 9 in Exercises 3.4). b.  For each value of n for which you run your program in part (a), estimate the size of the state-space tree by the method described in Section 12.1 and compare the estimate with the actual number of nodes you obtained. Design a linear-time algorithm that finds a solution to the n-queens problem for any n  4. Apply backtracking to the problem of finding a Hamiltonian circuit in the following graph. a   b cd   e f   g Apply backtracking to solve the 3-coloring problem for the graph in Figure 12.3a. Generate all permutations of {1, 2, 3, 4} by backtracking. a.  Apply backtracking to solve the following instance of the subset sum problem: A = {1, 3, 4, 5} and d = 1 b.  Will the backtracking algorithm work correctly if we use just one of the two inequalities to terminate a node as nonpromising? The general template for backtracking algorithms, which is given in the section, works correctly only if no solution is a prefix to another solution to the problem. Change the template's pseudocode to work correctly without this restriction. Write a program implementing a backtracking algorithm for a.  the Hamiltonian circuit problem. b. the m-coloring problem. Puzzle pegsThis puzzle-like game is played on a board with 15 small holes arranged in an equilateral triangle. In an initial position, all but one of the holes are occupied by pegs, as in the example shown below. A legal move is a jump of a peg over its immediate neighbor into an empty square opposite; the jump removes the jumped-over neighbor from the board. Design and implement a backtracking algorithm for solving the following versions of this puzzle. a.  Starting with a given location of the empty hole, find a shortest sequence of moves that eliminates 14 pegs with no limitations on the final position of the remaining peg. b.  Starting with a given location of the empty hole, find a shortest sequence of moves that eliminates 14 pegs with the remaining peg at the empty hole of the initial board. What data structure would you use to keep track of live nodes in a best-first branch-and-bound algorithm? Solve the same instance of the assignment problem as the one solved in the section by the best-first branch-and-bound algorithm with the bounding function based on matrix columns rather than rows. a.  Give an example of the best-case input for the branch-and-bound algorithm for the assignment problem. b. In the best case, how many nodes will be in the state-space tree of the branch-and-bound algorithm for the assignment problem? Write a program for solving the assignment problem by the branch-and-bound algorithm. Experiment with your program to determine the average size of the cost matrices for which the problem is solved in a given amount of time, say,
1 minute on your computer. Solve the following instance of the knapsack problem by the branch-andbound algorithm: item  weight  value
1  10 $100
2  7  $63   W = 16
3  8  $56
4  4  $12 a.  Suggest a more sophisticated bounding function for solving the knapsack problem than the one used in the section. b. Use your bounding function in the branch-and-bound algorithm applied to the instance of Problem 5. Write a program to solve the knapsack problem with the branch-and-bound algorithm. a.  Prove the validity of the lower bound given by formula (12.2) for instances of the traveling salesman problem with symmetric matrices of integer intercity distances. b. How would you modify lower bound (12.2) for nonsymmetric distance matrices? Apply the branch-and-bound algorithm to solve the traveling salesman problem for the following graph: a   2 b
5 8   7 3 c d
1
(We solved this problem by exhaustive search in Section 3.4.) As a research project, write a report on how state-space trees are used for programming such games as chess, checkers, and tic-tac-toe. The two principal algorithms you should read about are the minimax algorithm and alpha-beta pruning. a.  Apply the nearest-neighbor algorithm to the instance defined by the intercity distance matrix below. Start the algorithm at the first city, assuming that the cities are numbered from 1 to 5.
0   14  4 10
14  0   5 8   7
4   5   0 9   16
10  8   9 0   32
7   1632  0 b. Compute the accuracy ratio of this approximate solution. a.  Write pseudocode for the nearest-neighbor algorithm. Assumethatits input is given by an n × n intercity distance matrix. b. What is the time efficiency of the nearest-neighbor algorithm? Apply the twice-around-the-tree algorithm to the graph in Figure 12.11a with a walk around the minimum spanning tree that starts at the same vertex a but differs from the walk in Figure 12.11b. Is the length of the obtained tour the same as the length of the tour in Figure 12.11b? Prove that making a shortcut of the kind used by the twice-around-the-tree algorithm cannot increase the tour's length in a Euclidean graph. What is the time efficiency class of the greedy algorithm for the knapsack problem? Prove that the performance ratio RA of the enhanced greedy algorithm for the knapsack problem is equal to 2. Consider the greedy algorithm for the bin-packing problem, which is called the first-fit (FF) algorithm: place each of the items in the order given into the first bin the item fits in; when there are no such bins, place the item in a new bin and add this bin to the end of the bin list. a.  Apply FF  to the instance s1 = 0.4,   s2 = 0.7,s3 = 0.2,   s4 = 0.1, s5 = 0.5 and determine whether the solution obtained is optimal. b. Determine the worst-case time efficiency of FF. c.  Prove that FF is a 2-approximation algorithm. The first-fit decreasing (FFD) approximation algorithm for the bin-packing problem starts by sorting the items in nonincreasing order of their sizes and then acts as the first-fit algorithm. a.  Apply FFD to the instance s1 = 0.4,   s2 = 0.7,s3 = 0.2,   s4 = 0.1, s5 = 0.5 and determine whether the solution obtained is optimal. b.  Does FFD always yield an optimal solution? Justify your answer. c.  Prove that FFD is a 5-approximation algorithm. d.  Run  an  experiment   to  determine which  of  the  two  algorithms--FFor FFD--yields more accurate approximations on a random sample of the problem's instances. a.  Design a simple 2-approximation algorithm for finding a minimum vertex cover (a vertex cover with the smallest number of vertices) in a given graph. b.  Consider the following approximation algorithm for finding a maximum independent set (an independent set with the largest number of vertices) in a given graph. Apply the 2-approximation algorithm of part (a) and output all the vertices that are not in the obtained vertex cover. Can we claim that this algorithm is a 2-approximation algorithm, too? a.  Design a polynomial-time greedy algorithm for the graph-coloring problem. b.  Show that the performance ratio of your approximation algorithm is infinitely large.
